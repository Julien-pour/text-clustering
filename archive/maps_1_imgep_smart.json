[
    {
        "fitness": 1.0,
        "program_str": "def f(n: int) -> bool:\n    return str(n * n).startswith('123456789')\ndef g():\n    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and string manipulation.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int) -> bool:\n    return str(n * n).startswith('123456789')",
        "solution_func": "def g():\n    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding a number that, when squared, starts with the digits '123456789'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, mathematical operations, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6888545155525208,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return s.count('o') == 1000 and s.count('oo') == 0\ndef g():\n    return ('h' + 'o') * 1000\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return s.count('o') == 1000 and s.count('oo') == 0",
        "solution_func": "def g():\n    return ('h' + 'o') * 1000",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a function that checks if a given string meets certain conditions related to the count of specific substrings."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and counting substrings in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.7113105654716492,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list and checking for a specific condition on the elements of the list. It also uses list comprehension and modulo operation. The solution generates a list based on a specific pattern to satisfy the conditions of the puzzle.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))",
        "solution_func": "def g():\n    return [((i + 1) % 999) for i in range(999)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a function that takes a list of integers and checks if the list is sorted in ascending order and contains all integers from 0 to 998. The solution function generates a list where each element is the remainder of (i+1) divided by 999."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list sorting and comparison, as well as list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5462035536766052,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li.count(i) == i for i in range(10)])\ndef g():\n    return [i for i in range(10) for j in range(i)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for a specific condition using list comprehension.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li.count(i) == i for i in range(10)])",
        "solution_func": "def g():\n    return [i for i in range(10) for j in range(i)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that checks if a given list of integers satisfies a specific condition. The solution involves generating a list based on a nested loop and passing it to the function to check."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, the all() function, and the count() method in Python. It also requires knowledge of nested loops and range() function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5800998210906982,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\ndef g():\n    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3",
        "solution_func": "def g():\n    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to define a function f(s: str) that checks if a certain condition is met, and a function g() that generates a string based on a mathematical operation and finds a substring with the highest count in the generated string. The assertion checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, mathematical operations, and set comprehension in Python. It tests the students' understanding of string slicing, counting substrings, and defining functions with specific conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6070785522460938,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return ['The quick brown fox jumps over the lazy dog'[i] for i in li] == list('The five boxing wizards jump quickly')\ndef g():\n    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and list operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return ['The quick brown fox jumps over the lazy dog'[i] for i in li] == list('The five boxing wizards jump quickly')",
        "solution_func": "def g():\n    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to write a function that takes a list of integers and returns a boolean value based on a comparison with a given string. The solution function generates a list of integers based on the index of characters in another string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves list comprehension, string manipulation, and comparison operations in Python. It tests the student's understanding of list indexing and comparison techniques in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5910705327987671,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return min(ls) == max(ls) == str(len(ls))\ndef g():\n    return ['1']\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return min(ls) == max(ls) == str(len(ls))",
        "solution_func": "def g():\n    return ['1']",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that takes a list of strings as input and returns True if the minimum and maximum values in the list are equal to the string representation of the length of the list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, comparison of strings and integers, and the use of the min, max, and len functions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6732421517372131,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: float) -> bool:\n    return str(x - 3.1415).startswith('123.456')\ndef g():\n    return 123.456 + 3.1415\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Mathematical Operations",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: float) -> bool:\n    return str(x - 3.1415).startswith('123.456')",
        "solution_func": "def g():\n    return 123.456 + 3.1415",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to determine if the result of a mathematical operation satisfies a specific condition using string manipulation."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if the result of adding two numbers satisfies a condition based on string manipulation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6866452693939209,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all((sum(li[:i]) == 2 ** i - 1 for i in range(20)))\ndef g():\n    return [(2 ** i) for i in range(20)]\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all((sum(li[:i]) == 2 ** i - 1 for i in range(20)))",
        "solution_func": "def g():\n    return [(2 ** i) for i in range(20)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that checks if the sum of the first i elements in a list matches a specific formula for all i from 0 to 19. The solution generates a list of powers of 2 from 0 to 19 and checks if the function returns True for this list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, summing elements in a list, and comparing the sum to a specific formula. The solution involves generating a list of powers of 2 using list comprehension and passing it to the function to check if it returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5634488463401794,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(i: int) -> bool:\n    return len(str(i + 1000)) > len(str(i + 1001))\ndef g():\n    return -1001\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and string manipulation to compare the lengths of two strings.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(i: int) -> bool:\n    return len(str(i + 1000)) > len(str(i + 1001))",
        "solution_func": "def g():\n    return -1001",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding a number that, when added to 1001, results in a number with a shorter length than when added to 1000."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how adding different numbers affects the length of the resulting number when converted to a string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.7066800594329834,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and list comprehension to check if the sum of all pairs of elements in the list is equal to a specific set.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}",
        "solution_func": "def g():\n    return [0, 1, 2, 3, 17]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function that takes a list of integers and checks if the sum of all possible pairs of integers in the list matches a specific set of values."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves set comprehension and comparison to a predefined set of values.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5671083331108093,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\ndef g():\n    return list(range(3)) * 10\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for unique elements in the list.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3",
        "solution_func": "def g():\n    return list(range(3)) * 10",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a function that takes a list of integers as input and returns True if all elements are different from their adjacent elements and the list contains exactly 3 unique elements."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking for uniqueness of elements in a list and the presence of exactly 3 unique elements.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6033552289009094,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\ndef g():\n    return list(next(zip('dee', 'doo', 'dah!')))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and iteration over a list of strings.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return tuple(ls) in zip('dee', 'doo', 'dah!')",
        "solution_func": "def g():\n    return list(next(zip('dee', 'doo', 'dah!')))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that checks if a given list of strings matches a specific pattern defined by the zip function."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how the zip function works in Python and how to compare tuples to check for a specific pattern.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.610962450504303,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\ndef g():\n    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, sorting and ordering, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]",
        "solution_func": "def g():\n    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a string that is a palindrome and is an anagram of the phrase 'Permute me true'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, sorting, and checking for palindromes and anagrams.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5375446677207947,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\ndef g():\n    return [1, 2, 3, 3]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int]) -> bool:\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]",
        "solution_func": "def g():\n    return [1, 2, 3, 3]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of integers and returns a boolean value based on specific conditions. The solution function g returns a list of integers that satisfies the conditions of function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list indexing and comparison operations in Python. It also requires the student to correctly implement the conditions specified in function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.64235520362854,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(l: List[int]) -> bool:\n    return all((i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j)) and len(set(l)) > 995\ndef g():\n    return [0, 4] + list(range(6, 1000))\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, list operations, and set operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(l: List[int]) -> bool:\n    return all((i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j)) and len(set(l)) > 995",
        "solution_func": "def g():\n    return [0, 4] + list(range(6, 1000))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of integers as input and returns True if the conditions specified in the function are met. The student also needs to implement a function g that generates a list of integers to be passed to function f, such that the assertion statement at the end of the code passes."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking conditions related to the elements in the input list and their properties. The solution function g generates a list that satisfies the conditions specified in function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6320575475692749,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(hands: List[int], target_angle=68) -> bool:\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 68):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(hands: List[int], target_angle=68) -> bool:\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]",
        "solution_func": "def g(target_angle = 68):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves calculating the angles of the hour and minute hands of a clock and checking if the absolute difference between them matches a target angle or its complement."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of angles, loops, and conditional statements in Python to calculate the angles of the clock hands and check for the target angle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5797739028930664,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Backtracking, Number Theory",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1",
        "solution_func": "def g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining two functions, f(n) and g(), where f checks a specific condition on an input integer n and g iterates through integers to find the first one that satisfies the condition in f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves a loop that checks a condition on an integer n and a loop in the solution function g() that iterates through integers to find the first one that satisfies the condition in f(). The solution function g() returns the first integer that satisfies the condition in f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6891191005706787,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(coords: List[List[int]], side=10, num_points=20) -> bool:\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 10, num_points = 20):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to solve a combinatorial problem.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(coords: List[List[int]], side=10, num_points=20) -> bool:\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points",
        "solution_func": "def g(side = 10, num_points = 20):\n    from itertools import combinations",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves generating a set of unique coordinates within a grid, ensuring that no three points are collinear, and checking if a specific condition is met based on the generated coordinates."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of nested loops, assertions, itertools combinations, and mathematical concepts related to collinearity of points in a plane.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3357096016407013,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]) -> bool:\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 271, max_stamps = 8, options = [37, 37, 12, 87, 39]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, iteration, and combination generation using itertools. It also includes conditional logic and assertion checks.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]) -> bool:\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
        "solution_func": "def g(target = 271, max_stamps = 8, options = [37, 37, 12, 87, 39]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to find a combination of stamps from a given set of options that sum up to a target value, while also considering a maximum number of stamps allowed."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given combination of stamps satisfies certain conditions, such as the total sum being equal to the target value and the number of stamps not exceeding a maximum limit.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.37857362627983093,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometric calculations and constraints to ensure that a set of rectangles form a perfect square. It also includes assertions to validate the input data. The solution generates a list of coordinates and side lengths for rectangles that form a perfect square when summed up.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2",
        "solution_func": "def g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of lists as input and performs certain checks on the input list to determine if it satisfies certain conditions. The solution function g generates a specific list of lists that satisfies the conditions of function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, iteration, and conditional checks in Python. It also requires knowledge of list comprehension and mathematical calculations. The solution function g provides a specific list that satisfies the conditions of function f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.41396039724349976,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, lace='brrrbrrbrbbbbbrrbbrr') -> bool:\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'brrrbrrbrbbbbbrrbbrr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, lace='brrrbrrbrbbbbbrrbbrr') -> bool:\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))",
        "solution_func": "def g(lace = 'brrrbrrbrbbbbbrrbbrr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that checks a specific condition on a given input string, and a function g that finds a specific value in the input string to satisfy the condition in function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of string manipulation, counting characters in a string, and using list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.7048175930976868,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int) -> bool:\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True\ndef g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, mathematical operations, conditional logic, and sorting and ordering.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int) -> bool:\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True",
        "solution_func": "def g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding a number 'n' such that the square of 'n' contains all digits from 0 to 9 exactly once."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if the square of a number 'n' contains all digits from 0 to 9 exactly once. The function f(n) checks this condition, and the function g() iterates through numbers to find the required 'n'.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6049342155456543,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and Exception Handling.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)",
        "solution_func": "def g():\n    return \"8*8-1\"",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a string expression using only the characters '1', '8', '-', '+', '*', and '/' that evaluates to 63 and contains two '8's and one '1'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves using the given characters to form a valid mathematical expression that evaluates to 63 with specific constraints on the number of '8's and '1's in the expression.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6632453799247742,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 3 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1**8\"\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, mathematical operations, conditional logic, and evaluating expressions using the `eval()` function.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 3 and (s.count('1') == 1) and (eval(s) == 63)",
        "solution_func": "def g():\n    return \"8*8-1**8\"",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a string expression using only the characters '1', '8', '-', '+', '*', and '/' that evaluates to 63 and contains three occurrences of the digit '8' and one occurrence of the digit '1'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves creating a mathematical expression using specific characters that evaluates to a specific value and satisfies certain conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6384337544441223,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Backtracking, List Manipulation, and Algorithm Optimization.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal",
        "solution_func": "def g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a problem of pouring water between jugs with different capacities to reach a specific goal state."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of list manipulation, loops, and conditionals in Python to solve the pouring water problem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5047335028648376,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, word='pawuzorythalirinasubyg', max_len=12) -> bool:\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'pawuzorythalirinasubyg', max_len = 12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, word='pawuzorythalirinasubyg', max_len=12) -> bool:\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])",
        "solution_func": "def g(word = 'pawuzorythalirinasubyg', max_len = 12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the functions f and g, and use them to determine if the assertion statement is True or False."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and comparison, as well as understanding the logic within the functions f and g. The student needs to analyze the code to determine if the assertion statement is correct based on the functions provided.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5220287442207336,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to cover a target area with given corners and dimensions.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
        "solution_func": "def g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of corners and some parameters, and checks if the corners cover a specific target area. The solution function g generates the corners based on the parameters and checks if f returns True for those corners."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, sets, and assertions in Python. It also requires knowledge of function definitions and function calls with default parameters. The solution function g generates the corners based on the parameters and checks if the function f returns True for those corners.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.539508581161499,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and list manipulation to check if the input list satisfies a certain condition based on a predefined list of trips. The solution function uses list comprehension to calculate the sum of elements in each sublist of trips and return a list of boolean values based on the condition 'sum(s) >= 2'. The assert statement checks if the puzzle function f returns True when applied to the solution function g.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))",
        "solution_func": "def g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of boolean values and checks if the length of the list matches a predefined list of trips, and if the sum of each trip is greater than or equal to 2. The solution function g generates a list of boolean values based on the sum of each trip in a given list of trips."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves working with lists, boolean values, list comprehension, and conditional statements in Python. It tests the student's understanding of list operations and boolean logic. The solution function g demonstrates list comprehension and boolean comparisons in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3871249258518219,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and list manipulation.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))",
        "solution_func": "def g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining two functions, f and g, where f checks if certain conditions are met based on a list of scores and a threshold value, and g calculates the number of scores that are greater than or equal to the threshold value. The puzzle requires understanding of list comprehension, conditionals, and function composition in Python."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given solution function g meets the conditions specified in function f. Function f checks if all scores before a certain index are greater than or equal to a threshold value, and all scores after that index are less than the threshold value. Function g calculates the number of scores that are greater than or equal to the threshold value. The assert statement at the end ensures that f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3620789051055908,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(t: str, s='kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL') -> bool:\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(t: str, s='kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL') -> bool:\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)",
        "solution_func": "def g(s = 'kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that generates a string with a dot between each consonant in a given string, excluding vowels. The solution function then checks if the generated string satisfies certain conditions based on the input string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, iteration, and assertion checks. It tests the student's understanding of string operations and control flow in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49040958285331726,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(squares: List[List[int]], m=35, n=46, target=1610) -> bool:\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 35, n = 46, target = 1610):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as List Manipulation, Conditional Logic, and Set Operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(squares: List[List[int]], m=35, n=46, target=1610) -> bool:\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
        "solution_func": "def g(m = 35, n = 46, target = 1610):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of squares and checks if they cover a specific target area in a grid. The solution function g generates a list of squares based on the dimensions of the grid and ensures that the target area is covered by these squares."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how the function f checks if a list of squares covers a target area in a grid, and how the function g generates squares to satisfy this condition. It requires knowledge of list comprehension, loops, and conditional statements in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46509242057800293,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, s='tExTYtOHahekomArof', t='TExTYTohaHeKomryGUSeteXTUrYgir') -> bool:\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'tExTYtOHahekomArof', t = 'TExTYTohaHeKomryGUSeteXTUrYgir'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, s='tExTYtOHahekomArof', t='TExTYTohaHeKomryGUSeteXTUrYgir') -> bool:\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
        "solution_func": "def g(s = 'tExTYtOHahekomArof', t = 'TExTYTohaHeKomryGUSeteXTUrYgir'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves comparing two strings with different conditions based on the value of n. The solution function g() compares the strings and returns a value based on the comparison. The puzzle function f() checks if the comparison result from g() satisfies certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string comparison and conditional checks based on the value of n. The solution function g() returns a value based on the comparison of two strings, and the puzzle function f() checks if the result from g() meets the specified conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4991007447242737,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, word='silon') -> bool:\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'silon'):\n    return word[0].upper() + word[1:]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, word='silon') -> bool:\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True",
        "solution_func": "def g(word = 'silon'):\n    return word[0].upper() + word[1:]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires defining a function f(s: str, word='silon') that checks if the input string s matches a specific pattern defined by the word 'silon'. The solution function g(word = 'silon') generates a modified version of the word 'silon' by capitalizing the first letter. The puzzle tests whether the solution function g satisfies the condition of the function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and conditional checks in Python. It tests the understanding of string indexing, comparison, and function composition. This puzzle can be used to teach Python programming concepts related to strings and functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.485058069229126,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(t: str, s='c', target=1) -> bool:\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'c', target = 1):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(t: str, s='c', target=1) -> bool:\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))",
        "solution_func": "def g(s = 'c', target = 1):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand and analyze a function f that compares characters in a string and a function g that manipulates the input string to remove consecutive duplicate characters. The goal is to ensure that the output of function g satisfies the conditions set by function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, iteration, and comprehension in Python. Students need to understand how the functions f and g interact and how to manipulate strings to meet the conditions of f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5187705755233765,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and list manipulation to solve a linear algebra problem.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))",
        "solution_func": "def g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of integers and a default list of lists of integers as input. The function checks if the sum of each column in the default list plus the corresponding element in the input list equals zero. The solution function g calculates the negation of the sum of each column in the default list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, summing elements in lists, and checking conditions using all(). The solution function g uses list comprehensions and negation to calculate the required sums.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4451604187488556,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=14, b=50, c=47) -> bool:\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and list comprehension. It does not explicitly involve any of the other topics listed.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=14, b=50, c=47) -> bool:\n    return n + a == sum([b * i for i in range(c)])",
        "solution_func": "def g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand how to define functions with default parameters and use list comprehension to calculate a sum. The student needs to ensure that the function g() returns the correct value to satisfy the condition in function f()."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding function definitions, default parameters, list comprehension, and function invocation. It tests the student's ability to correctly implement a function that satisfies a given condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6544429659843445,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and iterative algorithms.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
        "solution_func": "def g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the given functions f and g, and determine if g is a solution to f by checking if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding loops, assertions, and comparison operators in Python. The student needs to analyze the functions f and g to determine if g is a solution to f based on the given conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6317125558853149,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Conditional Logic, and Function Calls.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m",
        "solution_func": "def g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that checks if the result of another function g satisfies a certain condition after some operations on a given number."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle tests the understanding of Python functions, loops, conditional statements, and arithmetic operations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.681404173374176,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]) -> bool:\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]) -> bool:\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
        "solution_func": "def g(pairs = [[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves two functions, f and g, where f checks if a certain condition is met based on a list of pairs, and g calculates a value based on the same list of pairs. The goal is to find a pair of values that satisfies the condition in f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding the logic of the f function which checks if a certain condition is met based on the pairs provided. The g function calculates a value based on the pairs, and the goal is to find a pair of values that satisfies the condition in f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5254612565040588,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s_case: str, s='rAC') -> bool:\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'rAC'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s_case: str, s='rAC') -> bool:\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
        "solution_func": "def g(s = 'rAC'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand and implement a function that checks if the input string has more uppercase letters than lowercase letters, and returns True if the condition is met."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves counting the number of uppercase letters in a given string and comparing it to the length of the string to determine if the string should be converted to all uppercase or all lowercase. The solution function g() correctly implements this logic and returns the modified string based on the condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.47087469696998596,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(inds: List[int], string='gteliikeenGgqIHent') -> bool:\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'gteliikeenGgqIHent'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(inds: List[int], string='gteliikeenGgqIHent') -> bool:\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'",
        "solution_func": "def g(string = 'gteliikeenGgqIHent'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function g that finds the indices of characters in a given string that spell out the word 'intelligent'. The function f checks if the indices are in sorted order and if the characters at those indices form the word 'intelligent'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, iteration, and list operations in Python. It tests the student's understanding of loops, string indexing, and list comprehension.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49668022990226746,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(d: int, n=707) -> bool:\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 707):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, conditional logic, and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(d: int, n=707) -> bool:\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))",
        "solution_func": "def g(n = 707):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand the functions f and g, and use them to solve a challenge involving counting the occurrences of '4' and '7' in a number."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number meets certain conditions based on the count of '4' and '7' in the number. The solution function g generates a number based on the input number, and the puzzle is solved when f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6214923858642578,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, target='rechawewivetextovy', reverse=True) -> bool:\n    return (s[::-1] == target) == reverse\ndef g(target = 'rechawewivetextovy', reverse = True):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, target='rechawewivetextovy', reverse=True) -> bool:\n    return (s[::-1] == target) == reverse",
        "solution_func": "def g(target = 'rechawewivetextovy', reverse = True):\n    return target[::-1] if reverse else target + \"x\"",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand string manipulation in Python and boolean logic. The student needs to create a function g that reverses the target string if reverse is True, and appends 'x' to the target string if reverse is False. The function f then checks if the result of g is equal to the target string in reverse order based on the value of reverse parameter."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, understanding of slicing in Python, boolean logic, and function composition. It tests the student's ability to create a function that meets specific criteria and to understand how the functions interact to produce the desired result.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5138348340988159,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, a=4763, d=8408) -> bool:\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 4763, d = 8408):\n    return \"a\" * a + \"d\" * d\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, a=4763, d=8408) -> bool:\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)",
        "solution_func": "def g(a = 4763, d = 8408):\n    return \"a\" * a + \"d\" * d",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function g(a, d) that returns a string with 'a' repeated 'a' times and 'd' repeated 'd' times. The function f(s, a, d) checks if the input string 's' contains 'a' repeated 'a' times, 'd' repeated 'd' times, and has a length equal to the sum of 'a' and 'd'. The assert statement checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "This puzzle is a good exercise to test the student's understanding of string manipulation, function definition, and function invocation in Python. It also reinforces the concept of function composition and parameter passing in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6292084455490112,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(nums: List[int], a=136, b=176, count=34) -> bool:\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 136, b = 176, count = 34):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for unique digits in a number, as well as mathematical operations to generate a list of numbers within a range. It also includes conditional logic to filter the numbers based on a condition. Finally, it uses set operations to check for uniqueness in the generated list of numbers.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(nums: List[int], a=136, b=176, count=34) -> bool:\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count",
        "solution_func": "def g(a = 136, b = 176, count = 34):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function f that takes a list of integers and checks if each integer in the list has unique digits and falls within a specified range. The function g generates a list of integers within the specified range that have unique digits. The puzzle is to ensure that function f returns True when applied to the output of function g."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, set operations, and range generation in Python. It also tests the student's ability to define functions with default arguments and use assertions for validation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5654745697975159,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17) -> bool:\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [2, 8, 25, 18, 99, 11, 17, 16], thresh = 17):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and list comprehension.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17) -> bool:\n    return tot == sum((1 if i < thresh else 2 for i in nums))",
        "solution_func": "def g(nums = [2, 8, 25, 18, 99, 11, 17, 16], thresh = 17):\n    return sum(1 if i < thresh else 2 for i in nums)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the use of list comprehension and the sum function in Python to calculate a sum based on a condition."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if the sum of a list of numbers based on a condition is equal to a given total, and defining a function g that calculates this sum. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6002258062362671,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(ans: List[List[int]], target=17) -> bool:\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 17):\n    return [[0, 2]] * target\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and list manipulation to achieve a specific target value. It does not directly relate to other topics such as recursion, dynamic programming, or graph theory.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(ans: List[List[int]], target=17) -> bool:\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
        "solution_func": "def g(target = 17):\n    return [[0, 2]] * target",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of pairs of integers and a target value, and checks if the difference between the second and first element in each pair is at least 2. The function g generates a list of pairs of integers based on the target value. The puzzle is to ensure that f(g()) returns True for a specific target value."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, iteration, and conditional statements in Python. It also requires the student to correctly implement the logic to check the difference between elements in pairs. The solution function g generates the input list based on the target value, and the challenge is to ensure that f correctly evaluates this list to return True.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.605104923248291,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, n=2) -> bool:\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, n=2) -> bool:\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
        "solution_func": "def g(n = 2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand string manipulation and mathematical operations in Python to determine if a given string satisfies a specific condition based on a mathematical calculation."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves converting numbers to strings, manipulating strings, and performing mathematical calculations to check if a condition is met.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6789503693580627,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(states: List[str], start='424', combo='778', target_len=12) -> bool:\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '424', combo = '778', target_len = 12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, conditional logic, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(states: List[str], start='424', combo='778', target_len=12) -> bool:\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len",
        "solution_func": "def g(start = '424', combo = '778', target_len = 12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that takes a list of strings representing states, a start state, a combo state, and a target length. The function checks if the list of states can reach the combo state from the start state by changing one digit at a time. The solution function g generates a sequence of states to reach the combo state from the start state."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, string operations, and conditional logic in Python. It also requires understanding of loops and mathematical operations to generate the sequence of states.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.445791631937027,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(states: List[str], start='4', combo='3', target_len=0) -> bool:\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '4', combo = '3', target_len = 0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and mathematical operations to solve the algorithmic challenge.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(states: List[str], start='4', combo='3', target_len=0) -> bool:\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))",
        "solution_func": "def g(start = '4', combo = '3', target_len = 0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that checks if a certain condition is met based on a list of states, a start value, a combo value, and a target length. The solution function g generates a list of values based on the start and combo values until a certain condition is met."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves manipulating lists of integers and checking conditions based on the differences between elements. It requires understanding of list comprehension, zip function, and modulo operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4518648386001587,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and permutations and combinations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target",
        "solution_func": "def g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that takes a string and checks if the string can be transformed into a target string using a specific permutation. The solution function g generates a string that can be transformed into the target string using the inverse permutation. The assertion at the end checks if applying g to f results in True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and understanding of permutations in Python. It requires the student to implement the inverse permutation function to solve the challenge.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5756535530090332,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4) -> bool:\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True\ndef g(items = [5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length = 4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking conditions based on the elements in the lists.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4) -> bool:\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
        "solution_func": "def g(items = [5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length = 4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a given list of lists meets certain conditions based on the input parameters and constraints provided in the functions f and g."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding list manipulation, set operations, list comprehensions, and assertions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.41607606410980225,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(seq: List[int], n=10000, length=5017) -> bool:\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 10000, length = 5017):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, conditional logic, and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(seq: List[int], n=10000, length=5017) -> bool:\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)",
        "solution_func": "def g(n = 10000, length = 5017):\n    return [2] * (n - length) + [1] * (2 * length - n)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to create a function g that generates a list of integers based on the input parameters n and length, such that the function f returns True when applied to the generated list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given list meets certain conditions based on the input parameters and the elements in the list. The solution function g generates a list that satisfies the conditions specified in the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6006773114204407,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves finding a subsequence in a list that satisfies certain conditions.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
        "solution_func": "def g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand the f and g functions, and how to use them to find the correct start index in a sequence to satisfy the given conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given start index in a sequence satisfies certain conditions based on the sum of elements in a subsequence. The solution function g uses a lambda function to find the start index that minimizes the sum of elements in the subsequence.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4158683717250824,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 3, lower = 150, seq = [3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
        "solution_func": "def g(k = 3, lower = 150, seq = [3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the starting index of a subsequence in a given sequence such that the sum of the subsequence is greater than or equal to a specified lower bound."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list slicing, summing elements of a subsequence, and using the max function with a lambda function to find the starting index of the subsequence.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4770612120628357,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
        "solution_func": "def g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining two functions, f and g, where f checks if the product of a subsequence of a given sequence is greater than a specified lower bound, and g finds the starting index of the subsequence that maximizes the product."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how to define functions, use loops, calculate products of subsequences, and find the index that maximizes a function. It also requires understanding how to use default arguments and assert statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.44366079568862915,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list operations, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))",
        "solution_func": "def g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of integers and checks if the list meets certain conditions. The student also needs to implement a function g that generates a list of integers based on the given total and number of elements. The solution function g should return a list that satisfies the conditions of function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, conditions, and arithmetic calculations in Python. It tests the student's ability to generate a list based on a given total and number of elements, and then check if the generated list meets specific conditions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6036869883537292,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(rotations: List[int], target='wonderful', upper=69) -> bool:\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'wonderful', upper = 69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(rotations: List[int], target='wonderful', upper=69) -> bool:\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper",
        "solution_func": "def g(target = 'wonderful', upper = 69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that takes a list of rotations and a target string as input, and checks if applying the rotations to the alphabet string results in the target string. The function g generates a list of rotations to transform the alphabet string into the target string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves manipulating strings and lists in Python to achieve a specific transformation. It tests the student's understanding of string manipulation and list operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4651159346103668,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming and list manipulation.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)",
        "solution_func": "def g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a list of bills satisfies certain conditions and then finding a solution using dynamic programming to meet those conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation, condition checking, and dynamic programming in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.31731489300727844,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, set operations, list manipulation, and algorithm optimization.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)",
        "solution_func": "def g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks if a list of numbers satisfies certain conditions, and a function g that generates a list of numbers based on given options. The solution g generates a list of numbers that meets the conditions specified in function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, set operations, and algorithmic thinking to generate a list of numbers that satisfies the conditions specified in function f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3175235986709595,
        "judgeLM-7b-abs_finetuning": 2.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and functions.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06",
        "solution_func": "def g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f(x) that checks if a quadratic equation with given coefficients has a root within a small tolerance. The solution function g() calculates the root of the quadratic equation using the quadratic formula and returns it."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding quadratic equations, roots, and the quadratic formula in Python. It tests the student's ability to define functions, work with coefficients, and solve equations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5896389484405518,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]) -> bool:\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to solve a quadratic equation and check the roots satisfy a condition.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]) -> bool:\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06",
        "solution_func": "def g(coeffs = [9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of roots and coefficients as input and checks if a certain condition is met. The solution function g calculates the roots of a quadratic equation using the coefficients provided and returns them in a list. The assertion checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding quadratic equations, roots, and coefficients. It tests the student's ability to implement a function to check a condition based on the roots and coefficients, as well as calculate the roots of a quadratic equation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6466795206069946,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: str, s=86120) -> bool:\n    return s == sum([int(d) for d in x])\ndef g(s = 86120):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: str, s=86120) -> bool:\n    return s == sum([int(d) for d in x])",
        "solution_func": "def g(s = 86120):\n    return int(s / 9) * '9' + str(s % 9)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that checks if the sum of the digits in a given number is equal to a specific value. The solution function then calculates a specific number based on the given value."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves working with string manipulation, integer conversion, and arithmetic operations in Python. It tests the student's understanding of list comprehension, summing elements in a list, and string concatenation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6296668648719788,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(z: float, v=9, d=0.0001) -> bool:\n    return int(z * 1 / d % 10) == v\ndef g(v = 9, d = 0.0001):\n    return v * d\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations and Conditional Logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(z: float, v=9, d=0.0001) -> bool:\n    return int(z * 1 / d % 10) == v",
        "solution_func": "def g(v = 9, d = 0.0001):\n    return v * d",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks if a certain condition is met based on the input parameters, and a function g that returns a value based on the input parameters. The goal is to ensure that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle tests the understanding of function composition and parameter passing in Python. Students need to understand how the functions f and g interact to satisfy the condition in the assert statement.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.731305718421936,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int], a=43536, s=3795, e=417606) -> bool:\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = 43536, s = 3795, e = 417606):\n    return list(range(a, e + 1, s))\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, conditional logic, and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int], a=43536, s=3795, e=417606) -> bool:\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
        "solution_func": "def g(a = 43536, s = 3795, e = 417606):\n    return list(range(a, e + 1, s))",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function that generates a list of numbers based on given parameters, and then check if the generated list satisfies certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list generation using range() function in Python and checking conditions on the generated list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5628100037574768,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(e: List[int], a=2, b=-1, c=1, d=2021) -> bool:\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = 2, b = -1, c = 1, d = 2021):\n    return [d - b, a - c]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(e: List[int], a=2, b=-1, c=1, d=2021) -> bool:\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)",
        "solution_func": "def g(a = 2, b = -1, c = 1, d = 2021):\n    return [d - b, a - c]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand a given function f that takes a list of integers as input and returns a boolean value based on a mathematical condition. The solution function g takes no input and returns a list of integers. The challenge is to find the correct values for a, b, c, and d in function g such that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding mathematical operations, list indexing, and function calls in Python. Students need to manipulate the values of a, b, c, and d in function g to satisfy the condition in function f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5904750227928162,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=22, b=-84904666) -> bool:\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 22, b = -84904666):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=22, b=-84904666) -> bool:\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
        "solution_func": "def g(a = 22, b = -84904666):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the given functions f and g, and determine if the assertion f(g()) == True holds true based on the conditions specified in the functions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding the conditions in the functions f and g, and applying them to check if the assertion is true.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6021465063095093,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and function definition.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
        "solution_func": "def g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves two functions, f(x) and g(a, b), where f checks if a given integer x satisfies a specific condition based on the values of a and b, and g calculates a value for x based on the values of a and b. The puzzle requires finding the correct value of x that satisfies the condition in f when passed through g."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves a simple algorithmic challenge where the solution function g calculates a value for x based on the input parameters a and b, and the function f checks if the calculated value of x satisfies a specific condition. The puzzle is suitable for teaching Python programming concepts such as function definition, parameter passing, and conditional statements.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6402627229690552,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int], n=9909, s=88140438) -> bool:\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list operations, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int], n=9909, s=88140438) -> bool:\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
        "solution_func": "def g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to write a function f(x) that takes a list of integers and checks if the length of the list is equal to a given value, the sum of the list is equal to a given value, and all elements in the list are greater than 0. The solution function g() generates a list of integers based on the given values of n and s that satisfy the conditions for function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, condition checking, and function implementation in Python. It also requires the student to understand how to generate a list based on given conditions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5844608545303345,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int], n=225, s=38417364) -> bool:\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 225, s = 38417364):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as List Manipulation, Conditional Logic, Set Operations, and Brute Force Search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int], n=225, s=38417364) -> bool:\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)",
        "solution_func": "def g(n = 225, s = 38417364):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function g that generates a list of integers based on certain conditions, and the function f checks if the generated list meets specific criteria."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves generating a list of integers with specific properties and then checking if the generated list satisfies certain conditions. The student needs to understand list manipulation, arithmetic operations, and conditional statements to solve this puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4835692346096039,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16) -> bool:\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n = 16):\n    return ''.join([s[i] for i in range(n)])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, List operations",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16) -> bool:\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
        "solution_func": "def g(s = ['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n = 16):\n    return ''.join([s[i] for i in range(n)])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f(x) that checks if a given string x is equal to a predefined list of characters s up to a certain length n. The solution function g() generates a string by joining characters from the predefined list s up to length n and returns it."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle is focused on string manipulation and list comprehension in Python. It tests the student's understanding of string comparison and list iteration.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5042182207107544,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int], t=44475424, a=93, e=8496, s=6) -> bool:\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 44475424, a = 93, e = 8496, s = 6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, conditional logic, and set operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int], t=44475424, a=93, e=8496, s=6) -> bool:\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])",
        "solution_func": "def g(t = 44475424, a = 93, e = 8496, s = 6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks certain conditions on a list of integers, and a function g that generates a list of integers based on certain calculations. The goal is to ensure that function f returns True when applied to the output of function g."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves list manipulation, condition checking, and arithmetic calculations in Python. It tests the student's understanding of list comprehension, set operations, and loop logic.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5419524908065796,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int], t=364928431, n=1088) -> bool:\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 364928431, n = 1088):\n    return [1] * n + [t]\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of integers and checking a condition based on the sorted sum. The solution generates a list of integers and a target value to satisfy the condition in the puzzle.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int], t=364928431, n=1088) -> bool:\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
        "solution_func": "def g(t = 364928431, n = 1088):\n    return [1] * n + [t]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f(x: List[int], t=364928431, n=1088) that checks if the sum of the elements in the input list x exceeds a threshold t before reaching a certain index n. The solution function g(t, n) generates a list of n+1 elements with all values as 1 except the last element which is set to t. The puzzle is to ensure that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, sorting, and conditional statements in Python. It also tests the student's ability to write functions with default arguments and use of assert statements for testing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5731114149093628,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, s1='t', s2='qu', count1=86, count2=83) -> bool:\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 't', s2 = 'qu', count1 = 86, count2 = 83):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, s1='t', s2='qu', count1=86, count2=83) -> bool:\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])",
        "solution_func": "def g(s1 = 't', s2 = 'qu', count1 = 86, count2 = 83):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks if a given string meets certain conditions, and a function g that generates a string based on input parameters. The goal is to ensure that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle tests the students' understanding of string manipulation, function parameters, and condition checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5260406732559204,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, substrings=['te', 'wusyc']) -> bool:\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['te', 'wusyc']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, List Comprehension",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, substrings=['te', 'wusyc']) -> bool:\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))",
        "solution_func": "def g(substrings = ['te', 'wusyc']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand how to check if a list of substrings can be found in a given string in a specific order, and then generate a new string based on the substrings provided."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves using list comprehension, string manipulation, and understanding of how to check for substrings in a given string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.4637726843357086,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, substrings=['foo', 'bar', 'baz']) -> bool:\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['foo', 'bar', 'baz']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, substrings=['foo', 'bar', 'baz']) -> bool:\n    return all((sub in s and sub[::-1] in s for sub in substrings))",
        "solution_func": "def g(substrings = ['foo', 'bar', 'baz']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires defining a function f(s: str, substrings=['foo', 'bar', 'baz']) that checks if all substrings and their reverse are present in the input string s. The solution function g(substrings=['foo', 'bar', 'baz']) constructs a string by concatenating the substrings and their reverse. The assertion checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, list comprehension, and checking conditions. It can be used to teach students about string operations, list manipulation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5645685195922852,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']) -> bool:\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[-2]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']) -> bool:\n    return s in strings and sum((t > s for t in strings)) == 1",
        "solution_func": "def g(strings = ['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[-2]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the second largest string in a list of strings and checking if it exists in the list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, sorting, and comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6084762811660767,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering topics.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1",
        "solution_func": "def g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding a string in a list of strings that is the second smallest when sorted in ascending order, and then checking if the reverse of that string is present in the list."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, list sorting, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.42868170142173767,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, target='foobarbazwow', length=6) -> bool:\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'foobarbazwow', length = 6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, target='foobarbazwow', length=6) -> bool:\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
        "solution_func": "def g(target = 'foobarbazwow', length = 6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand string slicing in Python and how to compare two strings."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if a given string matches a specific substring of a target string. The solution function g returns a substring of the target string based on the provided length. The assertion at the end checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5863271951675415,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(substring: str, string='cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count=3) -> bool:\n    return string.count(substring) == count\ndef g(string = 'cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count = 3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Brute Force Search",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(substring: str, string='cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count=3) -> bool:\n    return string.count(substring) == count",
        "solution_func": "def g(string = 'cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count = 3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks if a given substring appears a certain number of times in a given string, and a function g that iterates through all possible substrings of the string to find one that meets the count criteria."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, iteration, and understanding of function interactions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4288703501224518,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(t: str, s='))())l') -> bool:\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = '))())l'):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(t: str, s='))())l') -> bool:\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t",
        "solution_func": "def g(s = '))())l'):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that checks if a given string has balanced parentheses and contains a specific substring. The solution function g generates a string with balanced parentheses based on the input string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, counting characters, and checking for balanced parentheses. The solution function g demonstrates how to generate a string with balanced parentheses based on the input string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5259858965873718,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Brute Force Search, Set Operations, Permutations and Combinations, and Importing Modules (Itertools).",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
        "solution_func": "def g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of squares and dimensions m and n, and checks if certain conditions are met. The solution function g generates permutations of indices and checks if the conditions are satisfied."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, set operations, assertions, and permutations in Python. It also requires knowledge of indexing and tuple unpacking.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.44337400794029236,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves backtracking and algorithm optimization to solve the Knight's Tour problem using Warnsdorff's heuristic. It also includes sorting and ordering to check if the tour is valid.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]",
        "solution_func": "def g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that checks if a given tour is valid based on certain conditions, and a function g that generates a tour using Warnsdorff's heuristic algorithm. The puzzle requires students to understand the tour validation criteria and implement the tour generation algorithm."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves a combination of algorithmic understanding and Python programming skills. It can be used to teach students about tour validation and heuristic algorithms in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4154888093471527,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Backtracking, Recursion, Brute Force Search, and Algorithm Optimization.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()",
        "solution_func": "def g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a game where the player and a bot take turns removing objects from heaps. The goal is for the player to make a move that leads to a winning state, while the bot tries to prevent this by making optimal moves. The player wins if all heaps are empty at the end of their turn."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves implementing a game strategy where the player needs to make moves to reach a winning state while the bot tries to prevent this. The solution function g() implements the player's strategy to win the game by making optimal moves.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5439552664756775,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(probs: List[float]) -> bool:\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06\ndef g():\n    return [1 / 3] * 3\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a list of probabilities sums up to 1 and if the maximum difference between any two probabilities is less than a threshold.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(probs: List[float]) -> bool:\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06",
        "solution_func": "def g():\n    return [1 / 3] * 3",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f(probs: List[float]) that checks if the sum of probabilities in a list is approximately equal to 1 and if the maximum difference between any two probabilities in the list is less than a small threshold. The solution function g() returns a list of three equal probabilities that sum up to 1."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, mathematical calculations, and assertions in Python. It also tests the student's ability to implement a function that checks conditions on a list of probabilities.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5707430839538574,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)",
        "solution_func": "def g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a given list of edges forms a triangle in a graph based on certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of graph theory concepts and list manipulation in Python to check if a given set of edges forms a triangle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45393985509872437,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves graph theory (paths, edges, vertices) and backtracking.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True",
        "solution_func": "def g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a given path is valid based on a list of edges, and finding a path that covers all nodes in the graph represented by the edges."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of graph traversal and path validation in Python. It also involves using dictionaries to store paths in a graph.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.47607266902923584,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0",
        "solution_func": "def g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a given path in a graph is valid based on a set of edges. The goal is to determine if the path is of even length."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given path in a graph is valid based on a set of edges, and the function g generates paths in the graph. The solution g generates paths in the graph and ensures that the path is of even length. The assert statement at the end checks if the solution g is correct for the puzzle f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.35796573758125305,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves graph theory, backtracking, and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])",
        "solution_func": "def g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves checking if a given path in a graph is valid based on a set of edges. The function f checks if the path is valid, and the function g generates the path based on the edges provided."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves graph traversal and checking if a path is valid in the graph. It requires understanding of lists, dictionaries, loops, and conditional statements in Python. This puzzle can be used to teach Python programming concepts related to graph traversal and validation of paths in a graph.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43992888927459717,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(cut_position: int, ring='ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower=1) -> bool:\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= 1 if matches[c] > 0 else len(line)\n        else:\n            matches[c.lower()] += 1\n    return sum((i == 0 for i in matches.values())) >= lower\ndef g(ring = 'ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower = 1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to solve a challenge related to matching characters in a ring structure.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(cut_position: int, ring='ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower=1) -> bool:\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= 1 if matches[c] > 0 else len(line)\n        else:\n            matches[c.lower()] += 1\n    return sum((i == 0 for i in matches.values())) >= lower",
        "solution_func": "def g(ring = 'ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower = 1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves two functions, f and g, where f defines an algorithmic challenge related to manipulating a given ring string, and g provides a solution to the challenge by finding a specific position in the ring string. The solution is validated by asserting that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of string manipulation, dictionaries, loops, and conditional statements in Python. It challenges students to analyze and manipulate the given ring string to find the correct position based on certain conditions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4568031430244446,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as recursion, number theory (gcd), set operations, and backtracking.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True",
        "solution_func": "def g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining two functions in Python, f and g, where f defines an algorithmic challenge related to number theory and list manipulation, and g provides a solution to the challenge. The goal is to ensure that the solution g satisfies the conditions specified in the challenge function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves concepts of number theory, list comprehension, recursion, and algorithmic thinking. It requires understanding of functions, loops, sets, and assertions in Python. The challenge function f checks for certain conditions in a list of numbers, while the solution function g generates a list of numbers that satisfy those conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45767736434936523,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, recursion, and set operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)",
        "solution_func": "def g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of indices and a starting value a0, and checks if certain conditions are met. The solution function g generates a list of indices based on a starting value, ensuring that the conditions in f are satisfied."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding the algorithmic challenge of generating a list of indices based on a starting value and checking if specific conditions are met. It requires knowledge of loops, conditionals, and set operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5103334784507751,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int], n=9) -> bool:\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 9):\n    return [-1, -1, 2] * (n // 3)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, conditional logic, and mathematical operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int], n=9) -> bool:\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))",
        "solution_func": "def g(n = 9):\n    return [-1, -1, 2] * (n // 3)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that takes a list of integers and a number n as input. The function checks if the length of the list is equal to n and if a specific condition is met for each element in the list. The student also needs to implement a function g that generates a list based on the input n. The puzzle is to ensure that the function f returns True when applied to the output of function g."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, indexing, and list comprehension in Python. It also requires the student to grasp the concept of function composition and assertion testing.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6381617188453674,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Binary Operations (bitwise shifting, AND, OR) and Algorithm Optimization.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))",
        "solution_func": "def g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves implementing a function f that checks if a specific condition is met for a list of integers, and then implementing a solution function g that uses Gaussian elimination to decode vectors and solve the condition."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves bitwise operations, Gaussian elimination, and checking if a condition is met for a list of integers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3353322446346283,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves bitwise operations, brute force search, randomization, and probability and statistics.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4",
        "solution_func": "def g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f that checks if a certain condition is met based on a list of integers and a set of vectors. The solution function g uses a brute force approach to find a solution that satisfies the condition set by f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves bitwise operations, list comprehension, random number generation, and a brute force approach to find a solution. It requires understanding of bitwise manipulation and algorithmic thinking.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4379899501800537,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537) -> bool:\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 247586288427023352, b = 372021520735824432, lower_bound = 1709054537):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory (finding the greatest common divisor).",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537) -> bool:\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)",
        "solution_func": "def g(a = 247586288427023352, b = 372021520735824432, lower_bound = 1709054537):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the greatest common divisor (GCD) of two numbers and checking if it satisfies certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate the GCD of two numbers using the Euclidean algorithm and checking if the result meets specific criteria.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6111814975738525,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and recursion.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound",
        "solution_func": "def g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the greatest common divisor (GCD) of a list of numbers and checking if the GCD is greater than or equal to a specified lower bound."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate the greatest common divisor (GCD) of a list of numbers using a specific algorithm and checking if the result meets a certain condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5816926956176758,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)",
        "solution_func": "def g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the greatest common divisor (GCD) of two numbers and checking if a given number satisfies certain conditions based on the GCD."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate the greatest common divisor (GCD) of two numbers and using it to check if a given number meets specific criteria.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6564439535140991,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, recursion, and number theory.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound",
        "solution_func": "def g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f(n) that checks if a given number n satisfies certain conditions based on a list of numbers and an upper bound. The solution function g() calculates a value based on the list of numbers and an upper bound, and the puzzle is solved if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number satisfies certain conditions based on a list of numbers and an upper bound. The solution function calculates a value based on the list of numbers and an upper bound, and the puzzle is solved if the conditions are met.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5972784757614136,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, set operations, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n",
        "solution_func": "def g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining two functions, f and g, where f checks if the sum of squares of numbers in a list is equal to a given number, and g generates a list of numbers whose sum of squares equals the given number."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves concepts of list comprehension, dictionary comprehension, and iteration. It also requires understanding of mathematical operations like squaring numbers and checking for sums of squares.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5660016536712646,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int], k=6) -> bool:\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 6):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int], k=6) -> bool:\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))",
        "solution_func": "def g(k = 6):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to implement a function f that takes a list of integers and a parameter k, and checks if certain conditions are met based on the elements of the list. The solution function g generates a list of integers that satisfies the conditions of function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves working with lists, loops, and conditions in Python. It also requires understanding of list manipulation and mathematical operations. The solution function g generates a list that satisfies the conditions of function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5211905241012573,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and number theory, specifically the use of the pow function and checking if a certain condition holds true. It also involves understanding modular arithmetic and the Fermat's little theorem. The solution involves finding a specific number that satisfies the condition in the puzzle.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int) -> bool:\n    return pow(2, n, n) == 3",
        "solution_func": "def g():\n    return 4700063497",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves a function f(n) that checks if 2^n modulo n is equal to 3. The solution function g() returns a specific number, and the assertion checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding the pow() function in Python, modulo operation, and how to write a solution function that satisfies the condition of f(g()) == True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.7416648268699646,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Probability and Statistics, Importing Modules (Itertools, etc.)",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len",
        "solution_func": "def g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves generating random numbers and calculating probabilities to determine if a certain condition is met. The solution iterates through different values to find the best one that satisfies the condition."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding probability calculations and iterating through values to find the best solution. It requires knowledge of random number generation and probability concepts in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.47187575697898865,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics concepts along with mathematical operations. It also includes iterative calculations and comparison operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06",
        "solution_func": "def g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves calculating probabilities and checking if the calculated probability matches a target probability within a certain threshold."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle requires understanding of probability calculations and loops in Python. It involves calculating probabilities based on given conditions and checking for a specific target probability.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44113990664482117,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(st: str, a='zine', b='cerofilimybazine') -> bool:\n    return st + a == b\ndef g(a = 'zine', b = 'cerofilimybazine'):\n    return b[:len(b) - len(a)]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(st: str, a='zine', b='cerofilimybazine') -> bool:\n    return st + a == b",
        "solution_func": "def g(a = 'zine', b = 'cerofilimybazine'):\n    return b[:len(b) - len(a)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand string manipulation in Python. They need to determine if adding a specific string to another string results in a given target string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if adding a specific string to another string results in a target string. The solution function g extracts a substring from the target string based on the lengths of the input strings provided. The assert statement checks if the solution function g satisfies the condition of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6164986491203308,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, n=1000) -> bool:\n    return len(s) == n\ndef g(n = 1000):\n    return 'a' * n\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves String Manipulation and Conditional Logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, n=1000) -> bool:\n    return len(s) == n",
        "solution_func": "def g(n = 1000):\n    return 'a' * n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function that generates a string of 'a' characters of a specified length, and another function that checks if the length of the generated string is equal to a given number."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of function definitions, string manipulation, and function invocation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.7203083634376526,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(inds: List[int], s='kibozekiboze', target='') -> bool:\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'kibozekiboze', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and exception handling.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(inds: List[int], s='kibozekiboze', target='') -> bool:\n    (i, j, k) = inds\n    return s[i:j:k] == target",
        "solution_func": "def g(s = 'kibozekiboze', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of integers and two strings as input, and checks if a specific slicing operation on one of the strings matches the target string. The solution function g uses itertools.product to generate all possible combinations of indices for slicing the string and returns the indices that satisfy the condition in function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding slicing operations in Python strings and using itertools.product to generate combinations of indices. It also requires handling exceptions for invalid index values. This puzzle can be used to teach Python to master's students in CS as it covers string manipulation, list operations, and exception handling.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5669687986373901,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, big_str='fatextemedyrotichipicecojon', index=24) -> bool:\n    return big_str.index(s) == index\ndef g(big_str = 'fatextemedyrotichipicecojon', index = 24):\n    return big_str[index:]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and indexing operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, big_str='fatextemedyrotichipicecojon', index=24) -> bool:\n    return big_str.index(s) == index",
        "solution_func": "def g(big_str = 'fatextemedyrotichipicecojon', index = 24):\n    return big_str[index:]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand how to use the index method on strings in Python and how to compare the result to a given index value."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves using the index method to find the position of a substring within a larger string and comparing it to a specified index value. The solution function g returns a substring starting from a given index in the big_str. The assert statement checks if the puzzle function f returns True when applied to the solution function g.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5972418785095215,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(big_str: str, sub_str='nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index=185) -> bool:\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index = 185):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(big_str: str, sub_str='nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index=185) -> bool:\n    return big_str.index(sub_str) == index",
        "solution_func": "def g(sub_str = 'nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index = 185):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand how the index method works in Python and how to manipulate strings using ord and chr functions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves finding the index of a substring in a given string and then generating a new string based on certain conditions. The solution uses a while loop to find a character not present in the substring and then creates a new string using that character and the given substring.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44742879271507263,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str, a='bafywihequyjicivicharyquynikixuhinyqu', b='syrapetagecvicharyquynirorazecheth', length=12) -> bool:\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'bafywihequyjicivicharyquynikixuhinyqu', b = 'syrapetagecvicharyquynirorazecheth', length = 12):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str, a='bafywihequyjicivicharyquynikixuhinyqu', b='syrapetagecvicharyquynirorazecheth', length=12) -> bool:\n    return len(s) == length and s in a and (s in b)",
        "solution_func": "def g(a = 'bafywihequyjicivicharyquynikixuhinyqu', b = 'syrapetagecvicharyquynirorazecheth', length = 12):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function g that iterates over a string 'a' and checks if a substring of length 'length' is present in string 'b'. The function f checks if the output of function g satisfies certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and conditional checks, which are fundamental concepts in Python programming. It also requires understanding of function parameters and return values.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4761132597923279,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(substrings: List[str], s='hello', count=15) -> bool:\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'hello', count = 15):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations, Permutations and Combinations",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(substrings: List[str], s='hello', count=15) -> bool:\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))",
        "solution_func": "def g(s = 'hello', count = 15):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function that generates all possible substrings of a given string and checks if a list of substrings satisfies certain conditions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves working with string manipulation, sets, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4135587811470032,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(string: str, substring='moz', count=70, length=210) -> bool:\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'moz', count = 70, length = 210):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(string: str, substring='moz', count=70, length=210) -> bool:\n    return string.count(substring) == count and len(string) == length",
        "solution_func": "def g(substring = 'moz', count = 70, length = 210):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the functions f and g, and use them to check if the assertion f(g()) == True holds true."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string meets certain conditions based on the count of a substring and the length of the string. The solution function g generates a string based on the provided parameters, and the puzzle function f checks if the conditions are satisfied.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5466994643211365,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: str, parts=[], string='') -> bool:\n    return x.join(parts) == string\ndef g(parts = [], string = ''):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, List Operations",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: str, parts=[], string='') -> bool:\n    return x.join(parts) == string",
        "solution_func": "def g(parts = [], string = ''):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to implement a function that splits a string into parts and then joins them back together to form the original string."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, slicing, and joining operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5366653203964233,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(parts: List[str], sep='xusoquyvamathila', string='bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji') -> bool:\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'xusoquyvamathila', string = 'bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji'):\n    return string.split(sep)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(parts: List[str], sep='xusoquyvamathila', string='bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji') -> bool:\n    return sep.join(parts) == string and all((sep not in p for p in parts))",
        "solution_func": "def g(sep = 'xusoquyvamathila', string = 'bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji'):\n    return string.split(sep)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to implement a function f that checks if a list of strings can be joined using a separator to form a specific string, and that none of the strings in the list contain the separator. The solution function g splits a given string using a specified separator and returns a list of strings."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, list operations, and understanding of the join and split methods in Python. It also tests the student's ability to write functions that meet specific criteria.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4282095432281494,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to List Operations, Set Operations, and Mathematical Operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups",
        "solution_func": "def g(dups = 23476):\n    return [1] * (dups + 1)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function that checks for duplicates in a list of integers. The solution function creates a list with a specified number of duplicates and returns it."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, set operations, and function arguments in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6271820068359375,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves list manipulation and searching for a specific element in a list. It also includes the concept of indexing and comparison.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target",
        "solution_func": "def g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to implement a function that finds the index of a target element in a list and then checks if the element at that index is equal to the target."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list indexing and the index method in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6758484244346619,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42) -> bool:\n    return li[i] == target and i < 0\ndef g(li = [-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target = -42):\n    return li.index(target) - len(li)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, indexing, and comparison operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42) -> bool:\n    return li[i] == target and i < 0",
        "solution_func": "def g(li = [-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target = -42):\n    return li.index(target) - len(li)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the index of a target value in a list and checking if the value at that index is equal to the target value and the index is less than 0."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding list indexing, comparison, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5729015469551086,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]) -> bool:\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [-72, 70, 50, -41, 94, -82, -74, 8, -23], target = [-82]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, iteration, exception handling, and assertion testing.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]) -> bool:\n    (i, j, k) = inds\n    return li[i:j:k] == target",
        "solution_func": "def g(li = [-72, 70, 50, -41, 94, -82, -74, 8, -23], target = [-82]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f that takes a list of integers and checks if a specific sublist matches a target sublist. The solution function g iterates through all possible combinations of indices to find the sublist that matches the target sublist."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves list slicing and iteration through all possible combinations of indices. It tests the student's understanding of list operations and iteration in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4813356101512909,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=93252338) -> bool:\n    return -x == a\ndef g(a = 93252338):\n    return - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=93252338) -> bool:\n    return -x == a",
        "solution_func": "def g(a = 93252338):\n    return - a",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand function calls and parameter passing in Python. The student needs to determine the value of 'x' that makes the assertion true."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves a function f that checks if the negative of the input parameter is equal to a given value. The function g returns the negative of a given value. The student needs to understand how to pass parameters and call functions to make the assertion true.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.655870795249939,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=1073258, b=72352549) -> bool:\n    return a + x == b\ndef g(a = 1073258, b = 72352549):\n    return b - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=1073258, b=72352549) -> bool:\n    return a + x == b",
        "solution_func": "def g(a = 1073258, b = 72352549):\n    return b - a",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the concept of function parameters and return values in Python. The student needs to determine the correct value to return from function g in order to satisfy the condition in function f."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves defining two functions, f and g, where f checks if the sum of a parameter and a default value equals another default value. The student needs to find the correct value to return from function g to make the assertion in the puzzle pass.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6679275631904602,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    return x - a == b\ndef g(a = 9688203125538303, b = -293093369321912):\n    return a + b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    return x - a == b",
        "solution_func": "def g(a = 9688203125538303, b = -293093369321912):\n    return a + b",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand function parameters and return values in Python. The student needs to determine if the function g() correctly solves the challenge defined in function f()."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding function parameters, return values, and how to check if a solution function correctly solves a challenge function in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6478047966957092,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=-8783800228130606, b=-508993556991975) -> bool:\n    return a - x == b\ndef g(a = -8783800228130606, b = -508993556991975):\n    return a - b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=-8783800228130606, b=-508993556991975) -> bool:\n    return a - x == b",
        "solution_func": "def g(a = -8783800228130606, b = -508993556991975):\n    return a - b",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires students to understand default function arguments and function composition in Python."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves defining a function f with default arguments and checking if the function g, which returns the difference between the default arguments, satisfies the condition in f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6407425999641418,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=-141336, b=72) -> bool:\n    return b * n + a % b == a\ndef g(a = -141336, b = 72):\n    return a // b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=-141336, b=72) -> bool:\n    return b * n + a % b == a",
        "solution_func": "def g(a = -141336, b = 72):\n    return a // b",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to determine if a given mathematical expression is true based on the values of a and b provided in the functions."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how the mathematical expression in function f is evaluated based on the values of a and b. The solution function g should return the result of a divided by b.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.7563750743865967,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=12, b=-9988218457242775) -> bool:\n    return b // n == a\ndef g(a = 12, b = -9988218457242775):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=12, b=-9988218457242775) -> bool:\n    return b // n == a",
        "solution_func": "def g(a = 12, b = -9988218457242775):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle involves defining a function f(n) that checks if a specific mathematical condition is met, and a function g() that iterates through a range of values to find a solution that satisfies the condition in f(n). The assert statement at the end verifies if the solution returned by g() satisfies the condition in f(n)."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves basic arithmetic operations and iteration to find a solution that satisfies a given condition. It can be used to teach students about function definitions, mathematical operations, and iteration in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.7292263507843018,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    return n // b == a\ndef g(a = -3411193412414137, b = -9070455318026063):\n    return a * b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    return n // b == a",
        "solution_func": "def g(a = -3411193412414137, b = -9070455318026063):\n    return a * b",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to understand the concept of function composition and parameter passing in Python. The student needs to determine the correct values of 'a' and 'b' such that the function 'g' returns the correct result for function 'f'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how function composition works in Python and how default parameter values are used. The student needs to find the correct values of 'a' and 'b' such that the function 'g' returns the correct result for function 'f'.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6540253758430481,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: int, a=2617350631613713636) -> bool:\n    return x ** 2 == a\ndef g(a = 2617350631613713636):\n    return int(a ** 0.5)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: int, a=2617350631613713636) -> bool:\n    return x ** 2 == a",
        "solution_func": "def g(a = 2617350631613713636):\n    return int(a ** 0.5)",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding the square root of a given number and checking if the square of the result is equal to the given number."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate square roots in Python and using them to verify a condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6942624449729919,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: float, a=2732656229) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 2732656229):\n    return a ** 0.5\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: float, a=2732656229) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3)",
        "solution_func": "def g(a = 2732656229):\n    return a ** 0.5",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "Given a function f(x) that checks if the absolute difference between x squared and a is less than 10^(-3), and a function g() that returns the square root of a, the puzzle requires finding the value of a such that f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding function composition and mathematical operations in Python, specifically squaring and square rooting. It also tests the understanding of function parameters and return values.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6955752968788147,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0",
        "solution_func": "def g(a = 1363713245):\n    return -a ** 0.5",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires finding a value of x that satisfies a specific condition involving a given constant 'a'. The solution function g returns the negative square root of the constant 'a'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves understanding mathematical operations in Python, specifically exponentiation and comparison. It also requires knowledge of function definitions and function calls in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.7044484615325928,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return 'Hello ' + s == 'Hello world'\ndef g():\n    return \"world\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return 'Hello ' + s == 'Hello world'",
        "solution_func": "def g():\n    return \"world\"",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires defining a function f(s: str) that checks if the input string concatenated with 'Hello ' is equal to 'Hello world'. The solution function g() returns the string 'world' and the assertion checks if f(g()) returns True."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle is a simple string manipulation and comparison task that tests the student's understanding of string concatenation and equality comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.7062780857086182,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "def f(s: str) -> bool:\n    return 'Hello ' + s[::-1] == 'Hello world'\ndef g():\n    return \"world\"[::-1]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "def f(s: str) -> bool:\n    return 'Hello ' + s[::-1] == 'Hello world'",
        "solution_func": "def g():\n    return \"world\"[::-1]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to reverse the string 'world' and concatenate it with 'Hello' to check if it equals 'Hello world'."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and understanding of string slicing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6398754119873047,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(x: List[int]) -> bool:\n    return len(x) == 2 and sum(x) == 3\ndef g():\n    return [1, 2]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations and Conditional Logic.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(x: List[int]) -> bool:\n    return len(x) == 2 and sum(x) == 3",
        "solution_func": "def g():\n    return [1, 2]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to define a function g() that returns a list of two integers, and the function f(x) checks if the list has exactly two elements and their sum is equal to 3."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle is a simple one that tests the student's understanding of list manipulation and function definition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6946121454238892,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import List \ndef f(s: List[str]) -> bool:\n    return len(set(s)) == 1000 and all((x.count('a') > x.count('b') and 'b' in x for x in s))\ndef g():\n    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "idx_generation": -1,
        "target_skills": [],
        "puzzle_history": [],
        "problem_func": "from typing import List \ndef f(s: List[str]) -> bool:\n    return len(set(s)) == 1000 and all((x.count('a') > x.count('b') and 'b' in x for x in s))",
        "solution_func": "def g():\n    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]",
        "quality": [
            [
                null
            ]
        ],
        "description": [
            [
                "The puzzle requires the student to generate a list of 1000 strings where each string contains 'a' repeated (i+2) times followed by a single 'b'. The puzzle function f checks if the list meets two conditions: all strings are unique and each string has more 'a's than 'b's."
            ]
        ],
        "is_valid": [
            [
                true
            ]
        ],
        "is_valid_explanation": "The puzzle involves list comprehension, string manipulation, and understanding of set operations and all() function in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.507071316242218,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Brute Force Search, Importing Modules (Itertools, etc.)",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum",
        "solution_func": "def g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a subset of numbers from a given list that adds up to a target sum using a brute force approach."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of list manipulation, iteration, and the itertools module in Python to find the subset sum.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3805912435054779,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves recursion, conditional logic, and backtracking.",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)",
        "solution_func": "def g(nums = [1, 5, 11, 5]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that checks if a given list of integers can be partitioned into two subsets with equal sum."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves recursion and backtracking to check all possible partition combinations of the input list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3982929587364197,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, x=5, y=2) -> bool:\n    return (x + y) * (x - y) == result\ndef g(x=5, y=2):\n    if x > y:\n        return x ** 2 - y ** 2\n    else:\n        return x * y\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Conditional Logic, and Function Definition.",
        "idx_generation": 0,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    return n // b == a\ndef g(a = -3411193412414137, b = -9070455318026063):\n    return a * b\nassert f(g()) == True",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: int, x=5, y=2) -> bool:\n    return (x + y) * (x - y) == result",
        "solution_func": "def g(x=5, y=2):\n    if x > y:\n        return x ** 2 - y ** 2\n    else:\n        return x * y",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to determine the value of a mathematical expression based on given conditions and check if it matches the expected result."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating a mathematical expression based on the values of x and y, and then checking if the result matches the expected value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6413793563842773,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list in descending order and checking if it is sorted correctly. It also uses random number generation. The topics used in this puzzle are: Sorting and Ordering, Importing Modules (Itertools, etc.)",
        "idx_generation": 0,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)",
        "solution_func": "def g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list is sorted in descending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand sorting lists in Python and comparing lists for equality.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5538753271102905,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves backtracking to solve a Sudoku puzzle, which falls under the topic of Backtracking. It also involves conditional logic to check for valid moves, which falls under the topic of Conditional Logic. Additionally, it involves recursion in the `solve_sudoku` function. Therefore, the relevant topics are Backtracking, Conditional Logic, and Recursion.",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li.count(i) == i for i in range(10)])\ndef g():\n    return [i for i in range(10) for j in range(i)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver using a backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of backtracking and recursion to solve a Sudoku puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.43036046624183655,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li.count(i) == i for i in range(10)])\ndef g():\n    return [i for i in range(10) for j in range(i)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the intersection of two sets is equal to a given intersection, and a function g that returns the intersection of two sets. The goal is to ensure that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to work with sets in Python, specifically the intersection method. Students need to implement the functions correctly to ensure that the intersection check is done accurately.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6097150444984436,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve the maximum sum subsequence problem.",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True"
        ],
        "problem_func": "def f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum",
        "solution_func": "def g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the maximum sum of a subset of numbers in a list equals a given value, and g calculates the maximum sum of a subset of numbers in a list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle provides a challenge of finding the maximum sum of a subset of numbers in a list and checking if it matches a given value. The solution function g calculates the maximum sum of a subset of numbers in a list. The puzzle is suitable for teaching Python programming concepts related to algorithms and list manipulation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4858973026275635,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n\ndef g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a number is prime using a function and then generating a prime number using a library function. The solution then checks if the generated prime number satisfies the prime number check function.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))",
        "solution_func": "def g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num: int, prime_check=True) that checks if a given number is prime, and a function g(length=4) that generates a prime number of a specified length using the sympy library. The puzzle requires g to generate a prime number and f to check if the generated number is prime."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime number generation and prime number checking in Python using the sympy library. The student needs to generate a prime number using g and then check if it is prime using f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6626193523406982,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, num=5) -> bool:\n    import math\n    return math.factorial(num) == result\n\ndef g(num=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(num)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and recursion.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: int, num=5) -> bool:\n    import math\n    return math.factorial(num) == result",
        "solution_func": "def g(num=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(num)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the factorial of a given number matches a provided result, and a function g that calculates the factorial of a number recursively. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding factorial calculation and recursive functions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.655737042427063,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g():\n    return \"deified\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for palindrome, which falls under the topic of String Manipulation.",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True"
        ],
        "problem_func": "def f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]",
        "solution_func": "def g():\n    return \"deified\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to understand how to check for palindromes in Python using string slicing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6446406245231628,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sequence: list) -> bool:\n    return all(sequence[i] - sequence[i-1] == sequence[1] - sequence[0] for i in range(2, len(sequence)))\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to check if a given sequence follows a specific pattern.",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True"
        ],
        "problem_func": "def f(sequence: list) -> bool:\n    return all(sequence[i] - sequence[i-1] == sequence[1] - sequence[0] for i in range(2, len(sequence)))",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(sequence) that checks if the given sequence is an arithmetic progression. The solution function g() returns a specific arithmetic progression sequence and asserts that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and arithmetic progression. It is a good exercise for practicing list manipulation and comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5645962357521057,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, List Operations, and Conditional Logic.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))",
        "solution_func": "def g(common_diff=5):\n    return [i * common_diff for i in range(10)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list of integers has a common difference between consecutive elements, and a function g that generates a list of integers with a specified common difference. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and the all() function in Python. It also tests the student's ability to define functions with default arguments and use them in assertions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5501776933670044,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(input_str: str) -> bool:\n    return input_str == input_str[::-1]\n\ndef g(input_str=\"radar\"):\n    return input_str + input_str[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(input_str: str) -> bool:\n    return input_str == input_str[::-1]",
        "solution_func": "def g(input_str=\"radar\"):\n    return input_str + input_str[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given string is a palindrome and g generates a palindrome string based on the input string. The assertion checks if the generated palindrome string satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python and checking for palindromes. It is a suitable puzzle for teaching Python programming concepts related to strings and functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.565116822719574,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and permutations and combinations.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)",
        "solution_func": "def g():\n    return [3, 4, 5]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if there exists a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires finding a list of integers that forms a Pythagorean triplet, where the square of the first element plus the square of the second element equals the square of the third element.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5464882850646973,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Number Theory (primes), Mathematical Operations, Conditional Logic, and List Operations.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    return x - a == b\ndef g(a = 9688203125538303, b = -293093369321912):\n    return a + b\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True",
        "solution_func": "def g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n: int, prime=19) that checks if a number is prime, and a function g(n=5) that generates the nth prime number. The puzzle requires finding the nth prime number and checking if it is prime using the f function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, function definitions, loops, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6780585050582886,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, palindrome=\"radar\") -> bool:\n    return s == s[::-1]\ndef g(palindrome=\"radar\"):\n    return palindrome\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    return x - a == b\ndef g(a = 9688203125538303, b = -293093369321912):\n    return a + b\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, palindrome=\"radar\") -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(palindrome=\"radar\"):\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome and then providing a solution function that returns a predefined palindrome string. The assertion checks if the solution function correctly identifies the predefined palindrome as a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6673288941383362,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, palindrome=\"racecar\") -> bool:\n    return s == s[::-1]\ndef g(palindrome=\"racecar\"):\n    return palindrome\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, palindrome=\"racecar\") -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(palindrome=\"racecar\"):\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome using a default palindrome string 'racecar'. The solution function returns the default palindrome string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is a simple exercise in checking for palindromes and understanding default arguments in Python functions. It can be used to introduce the concept of palindromes and function arguments to master's students in CS.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6764281988143921,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \ndef f(nums: List[int], has_prime=True) -> bool:\n    return any(num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) for num in nums) == has_prime\ndef g(range_end=20):\n    return [num for num in range(2, range_end + 1) if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))]\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking for prime numbers in a list of integers using list comprehension and a primality test function.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List \ndef f(nums: List[int], has_prime=True) -> bool:\n    return any(num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) for num in nums) == has_prime",
        "solution_func": "def g(range_end=20):\n    return [num for num in range(2, range_end + 1) if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of numbers contains prime numbers or not. The function f takes a list of numbers and a boolean flag to indicate if the list should contain prime numbers. The function g generates a list of prime numbers up to a specified range and returns it. The assertion checks if the function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, prime number generation, and boolean flag usage in function arguments. It tests the student's knowledge of list comprehensions, prime number checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.586004376411438,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \nfrom itertools import permutations\ndef f(words: List[str], has_anagram=True) -> bool:\n    return any(sorted(word) == sorted(words[0]) for word in words) == has_anagram\ndef g(word=\"listen\"):\n    return [''.join(p) for p in permutations(word)]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, permutations and combinations, and importing modules (Itertools).",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List \nfrom itertools import permutations\ndef f(words: List[str], has_anagram=True) -> bool:\n    return any(sorted(word) == sorted(words[0]) for word in words) == has_anagram",
        "solution_func": "def g(word=\"listen\"):\n    return [''.join(p) for p in permutations(word)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a list of words contains an anagram of a specific word. The solution function generates all permutations of a given word and checks if any of them match the anagram condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of list comprehension, string manipulation, and itertools in Python. It also requires understanding of how to check for anagrams using sorted strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3799389600753784,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "Geometry and Coordinate Manipulation",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6",
        "solution_func": "def g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the area of a polygon defined by its vertices and checking if it matches a given area within a small tolerance."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of calculating the area of a polygon using the shoelace formula and comparing it with a given area value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5226368308067322,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int, arr=[3, 2, 7, 10, 5]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(arr=[3, 2, 7, 10, 5]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve the maximum sum subsequence problem.",
        "idx_generation": 1,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(max_sum: int, arr=[3, 2, 7, 10, 5]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum",
        "solution_func": "def g(arr=[3, 2, 7, 10, 5]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the maximum sum of a subsequence in an array matches a given value, and g calculates the maximum sum of a subsequence in an array."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle provides a challenge related to calculating the maximum sum of a subsequence in an array and checking if it matches a given value. The solution function g calculates the maximum sum of a subsequence in the array. The puzzle is suitable for teaching algorithmic challenges and array manipulation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.49128931760787964,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(result: int, num=5) -> bool:\n    import math\n    return math.factorial(num) == result\n\ndef g(num=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(num)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, write a function g(input_str) that appends the reverse of the input string to itself and returns the result. The puzzle requires g to be implemented in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically reversing a string and checking for palindromes. The solution function g(input_str) concatenates the input string with its reverse and the puzzle tests if the result satisfies the palindrome condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5278458595275879,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    return [3, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(result: int, num=5) -> bool:\n    import math\n    return math.factorial(num) == result\n\ndef g(num=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(num)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False",
        "solution_func": "def g() -> List[int]:\n    return [3, 4, 5, 6, 8, 10]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if there exists a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires finding a set of three integers in the list such that they form a Pythagorean triplet (a^2 + b^2 = c^2). The solution function g() returns a list of integers, and the puzzle function f() checks if there exists a Pythagorean triplet in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46151497960090637,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom collections import Counter\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    word_count = [Counter(word) for word in words]\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if word_count[i] == word_count[j]:\n                return True\n    return False\n\ndef g() -> List[str]:\n    return [\"listen\", \"silent\", \"hello\", \"world\", \"act\", \"cat\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and importing modules (collections). It also involves iteration and comparison of elements in a list.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(result: int, num=5) -> bool:\n    import math\n    return math.factorial(num) == result\n\ndef g(num=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(num)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from collections import Counter\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    word_count = [Counter(word) for word in words]\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if word_count[i] == word_count[j]:\n                return True\n    return False",
        "solution_func": "def g() -> List[str]:\n    return [\"listen\", \"silent\", \"hello\", \"world\", \"act\", \"cat\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding if there are any two words in a list that have the same character count."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves comparing the character counts of words in a list to find duplicates.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3340613842010498,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(input_str: str) -> bool:\n    clean_str = ''.join(char.lower() for char in input_str if char.isalnum())\n    return clean_str == clean_str[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(input_str: str) -> bool:\n    clean_str = ''.join(char.lower() for char in input_str if char.isalnum())\n    return clean_str == clean_str[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and list comprehension in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44479745626449585,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return len(set(int_list)) != len(int_list)\n\ndef g():\n    return [1, 2, 3, 4, 5, 5, 6]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for duplicate elements in a list of integers.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return len(set(int_list)) != len(int_list)",
        "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 5, 6]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to write a function that checks if a list of integers contains any duplicates."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation and set operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5791820287704468,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, threshold=30) -> bool:\n    return num * 2 > threshold and num % 2 == 0\ndef g(threshold=30):\n    return threshold // 2 + 1\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and Function Composition.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, a=14, b=50, c=47) -> bool:\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])\nassert f(g()) == True",
            "def f(s: str, n=2) -> bool:\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int, threshold=30) -> bool:\n    return num * 2 > threshold and num % 2 == 0",
        "solution_func": "def g(threshold=30):\n    return threshold // 2 + 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f(num: int, threshold=30) -> bool and g(threshold=30), where f checks if a given number multiplied by 2 is greater than a threshold and the number is even, and g calculates a value based on the threshold. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding function definitions, parameter passing, arithmetic operations, and logical conditions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.7198897004127502,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list, target=True) -> bool:\n    if target:\n        return all(numbers[i] - numbers[i-1] == numbers[1] - numbers[0] for i in range(2, len(numbers)))\n    else:\n        return False\n\ndef g(size=4):\n    return [2*i + 1 for i in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to check if a list of numbers follows a specific pattern.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]) -> bool:\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g()) == True",
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list, target=True) -> bool:\n    if target:\n        return all(numbers[i] - numbers[i-1] == numbers[1] - numbers[0] for i in range(2, len(numbers)))\n    else:\n        return False",
        "solution_func": "def g(size=4):\n    return [2*i + 1 for i in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of numbers forms an arithmetic sequence, and another function g that generates a list of numbers based on a given size. The assertion tests if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, arithmetic sequences, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6256310343742371,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence: str, s1=\"abcdfg\", s2=\"bcdfgh\") -> bool:\n    def longest_common_subsequence(s1, s2):\n        dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[-1][-1]\n\n    return longest_common_subsequence(s1, s2) == len(longest_subsequence)\n\ndef g(s1=\"abcdfg\", s2=\"bcdfgh\"):\n    return \"\".join([s1[i] for i in range(len(s1)) if s1[i] in s2])\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Dynamic Programming",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence: str, s1=\"abcdfg\", s2=\"bcdfgh\") -> bool:\n    def longest_common_subsequence(s1, s2):\n        dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[-1][-1]\n\n    return longest_common_subsequence(s1, s2) == len(longest_subsequence)",
        "solution_func": "def g(s1=\"abcdfg\", s2=\"bcdfgh\"):\n    return \"\".join([s1[i] for i in range(len(s1)) if s1[i] in s2])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest common subsequence between two strings and checking if it matches a given longest subsequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming to find the longest common subsequence between two strings and then checking if it matches a given longest subsequence.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3688461184501648,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return False\n            num = board[i][j]\n            board[i][j] = 0\n            if not is_valid(i, j, num):\n                return False\n            board[i][j] = num\n    return True\n\ndef g():\n    def solve_sudoku(board):\n        def is_valid(row, col, num):\n            for i in range(9):\n                if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n\n        def backtrack():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == 0:\n                        for num in range(1, 10):\n                            if is_valid(i, j, num):\n                                board[i][j] = num\n                                if backtrack():\n                                    return True\n                                board[i][j] = 0\n                        return False\n            return True\n\n        if backtrack():\n            return board\n        return None\n\n    empty_board = [[0 for _ in range(9)] for _ in range(9)]\n    return solve_sudoku(empty_board)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return False\n            num = board[i][j]\n            board[i][j] = 0\n            if not is_valid(i, j, num):\n                return False\n            board[i][j] = num\n    return True",
        "solution_func": "def g():\n    def solve_sudoku(board):\n        def is_valid(row, col, num):\n            for i in range(9):\n                if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n\n        def backtrack():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == 0:\n                        for num in range(1, 10):\n                            if is_valid(i, j, num):\n                                board[i][j] = num\n                                if backtrack():\n                                    return True\n                                board[i][j] = 0\n                        return False\n            return True\n\n        if backtrack():\n            return board\n        return None\n\n    empty_board = [[0 for _ in range(9)] for _ in range(9)]\n    return solve_sudoku(empty_board)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function to check if a given Sudoku board is valid, and providing a solution function to solve the Sudoku board."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Sudoku rules and backtracking algorithm to solve the puzzle. The solution function uses backtracking to fill in the empty cells of the Sudoku board.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4383945167064667,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves pattern recognition and list manipulation.",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False",
        "solution_func": "def g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given list of integers follows a specific pattern. The solution function g generates a list of integers following a unique pattern and checks if it satisfies the condition of function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle provides a good exercise in understanding list manipulation, pattern matching, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4495704472064972,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(path: str) -> bool:\n    return path.count('D') == 3 and path.count('R') == 2\n\ndef g():\n    return 'RDDDR'\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to count occurrences of specific characters ('D' and 'R').",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(path: str) -> bool:\n    return path.count('D') == 3 and path.count('R') == 2",
        "solution_func": "def g():\n    return 'RDDDR'",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the function g() to return a string that contains 3 'D's and 2 'R's in a specific order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves counting the occurrences of 'D' and 'R' in the string returned by g() and checking if they match the specified counts.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6806536316871643,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given number is a prime number or not.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num: int) -> bool and g() -> int. Function f checks if a given number is a prime number, and function g returns the number 17. The puzzle asserts that calling f with the result of g should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6389383673667908,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int) -> bool:\n    return factorial == 120\n\ndef g():\n    num = 5\n    result = 1\n    for i in range(1, num + 1):\n        result *= i\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and factorial calculation.",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int) -> bool:\n    return factorial == 120",
        "solution_func": "def g():\n    num = 5\n    result = 1\n    for i in range(1, num + 1):\n        result *= i\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function to calculate the factorial of a given number and check if the factorial is equal to 120."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of functions, loops, and mathematical operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6869157552719116,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if numbers[i]**2 + numbers[j]**2 == numbers[k]**2:\n                    return True\n    return False\n\ndef g():\n    import random\n    numbers = [random.randint(1, 20) for _ in range(7)]\n    # Generate a list where a Pythagorean triplet exists\n    numbers.append((numbers[-1]**2 + numbers[-2]**2)**0.5)\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if numbers[i]**2 + numbers[j]**2 == numbers[k]**2:\n                    return True\n    return False",
        "solution_func": "def g():\n    import random\n    numbers = [random.randint(1, 20) for _ in range(7)]\n    # Generate a list where a Pythagorean triplet exists\n    numbers.append((numbers[-1]**2 + numbers[-2]**2)**0.5)\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers contains a Pythagorean triplet (three numbers that satisfy the Pythagorean theorem a^2 + b^2 = c^2)."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating a list of random numbers and adding a Pythagorean triplet to it. The function f() then checks if the list contains a Pythagorean triplet by iterating through all possible combinations of three numbers in the list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.38950660824775696,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import string\n    import random\n\n    chars = string.ascii_lowercase\n    palindrome = ''.join(random.choice(chars) for _ in range(5))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import string\n    import random\n\n    chars = string.ascii_lowercase\n    palindrome = ''.join(random.choice(chars) for _ in range(5))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string of length 10 using lowercase letters and checking if it is a palindrome. The solution function generates a palindrome by concatenating a randomly generated string with its reverse.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.474843829870224,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of numbers using the Bubble Sort algorithm and checking if the list is sorted in ascending order. The topics used in this puzzle are sorting and ordering, algorithm optimization, and list operations.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function f(numbers: List[int]) that checks if a list of numbers is sorted in non-decreasing order. The solution function g() generates a list of random numbers and sorts them using the Bubble Sort algorithm, then returns the sorted list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding the concept of sorting algorithms, specifically Bubble Sort, and implementing a function to check if a list is sorted. It provides a practical application of sorting algorithms in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.39702314138412476,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.), Conditional Logic",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))",
        "solution_func": "def g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given list of integers forms a sequence of consecutive numbers, and a function g that generates permutations of a given list and returns the permutation that forms a consecutive sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list permutations, checking for consecutive numbers in a list, and using itertools in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4126378297805786,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves backtracking to solve the N-Queens problem, which is a classic problem in computer science. It also involves recursion and conditional logic. Additionally, it requires knowledge of list manipulation and iteration.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True",
        "solution_func": "def g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given arrangement of queens on a chessboard is valid, where no two queens can attack each other diagonally or in the same row/column."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of backtracking and recursion to find a valid arrangement of queens on a chessboard without them attacking each other.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3560638129711151,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves validating a Sudoku board, which requires knowledge of set operations, conditional logic, and possibly recursion (although not explicitly used in this puzzle).",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True",
        "solution_func": "def g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not. The function f(board) checks if the board is a valid Sudoku board by ensuring that each row, column, and 3x3 square contains unique numbers from 1 to 9. The function g() generates a valid Sudoku board as an example."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to validate a Sudoku board using Python functions and loops. It also requires knowledge of sets and list comprehensions. This puzzle can be used to teach Python programming concepts related to nested functions, loops, and list manipulation.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3691806197166443,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(li: List[int]) -> bool:\n    if len(li) < 2:\n        return True\n    diff = li[1] - li[0]\n    for i in range(2, len(li)):\n        if li[i] - li[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    n = random.randint(5, 10)\n    return [start + i * diff for i in range(n)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves the topics of List Manipulation, Mathematical Operations, and Randomization.",
        "idx_generation": 3,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
            "def f(n: int) -> bool:\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True\ndef g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(li: List[int]) -> bool:\n    if len(li) < 2:\n        return True\n    diff = li[1] - li[0]\n    for i in range(2, len(li)):\n        if li[i] - li[i-1] != diff:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    n = random.randint(5, 10)\n    return [start + i * diff for i in range(n)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of integers forms an arithmetic sequence, and a function g that generates a random arithmetic sequence to test function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation and arithmetic sequences in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5416200160980225,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(strings: List[str], pattern=\"abc\") -> bool:\n    return any(pattern in s for s in strings)\n\ndef g(length=5, pattern=\"abc\"):\n    import random\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    strings = []\n    for _ in range(length):\n        rand_str = \"\".join(random.choices(alphabet, k=10))\n        strings.append(rand_str + pattern + \"\".join(random.choices(alphabet, k=5)))\n    return strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Randomization, List operations",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(strings: List[str], pattern=\"abc\") -> bool:\n    return any(pattern in s for s in strings)",
        "solution_func": "def g(length=5, pattern=\"abc\"):\n    import random\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    strings = []\n    for _ in range(length):\n        rand_str = \"\".join(random.choices(alphabet, k=10))\n        strings.append(rand_str + pattern + \"\".join(random.choices(alphabet, k=5)))\n    return strings",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given pattern is present in any of the strings in a list of strings. The function g generates a list of random strings with the specified pattern included. The assertion checks if f returns True when applied to the output of g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for a specific pattern in a list of strings and generating random strings with the pattern included. It also tests the understanding of function calls and assertions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.447757750749588,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, recursion, and list manipulation.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))",
        "solution_func": "def g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of numbers follows a specific pattern, and a function g that generates a list of numbers following the same pattern. The assertion at the end checks if the generated list satisfies the pattern defined by f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, iteration, and pattern checking in Python. It also requires knowledge of list comprehension and the all() function. The solution function g generates a list of numbers following the Fibonacci sequence pattern.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5329678058624268,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(binary_nums: List[str], pattern=\"1010\") -> bool:\n    return any(pattern in bin_num for bin_num in binary_nums)\n\ndef g(length=6, pattern=\"1010\"):\n    import random\n    binary_nums = []\n    for _ in range(length):\n        rand_num = bin(random.randint(0, 15))[2:].zfill(4)  # Generate random 4-bit binary numbers\n        binary_nums.append(rand_num[:2] + pattern + rand_num[2:])\n    return binary_nums\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, conditional logic, importing modules (random), and probability and statistics.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(binary_nums: List[str], pattern=\"1010\") -> bool:\n    return any(pattern in bin_num for bin_num in binary_nums)",
        "solution_func": "def g(length=6, pattern=\"1010\"):\n    import random\n    binary_nums = []\n    for _ in range(length):\n        rand_num = bin(random.randint(0, 15))[2:].zfill(4)  # Generate random 4-bit binary numbers\n        binary_nums.append(rand_num[:2] + pattern + rand_num[2:])\n    return binary_nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given pattern is present in a list of binary numbers, and a function g that generates a list of random 6-bit binary numbers with the pattern inserted in the middle. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with binary numbers, generating random binary numbers, and checking for a specific pattern within them. It tests the understanding of list comprehension, string manipulation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5032344460487366,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True",
            "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)",
        "solution_func": "def g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given set of line segments form a closed loop or not by constructing an adjacency list and performing a depth-first search traversal."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of sets, lists, tuples, dictionaries, loops, and graph traversal algorithms in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3105635344982147,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(strings: List[str]) -> bool:\n    pattern = 'abc'\n    idx = 0\n    for s in strings:\n        for char in s:\n            if char != pattern[idx]:\n                return False\n            idx = (idx + 1) % len(pattern)\n    return True\n\ndef g():\n    pattern = 'abc'\n    strings = [pattern * 3, pattern * 2]\n    return strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Pattern Recognition",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(strings: List[str]) -> bool:\n    pattern = 'abc'\n    idx = 0\n    for s in strings:\n        for char in s:\n            if char != pattern[idx]:\n                return False\n            idx = (idx + 1) % len(pattern)\n    return True",
        "solution_func": "def g():\n    pattern = 'abc'\n    strings = [pattern * 3, pattern * 2]\n    return strings",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function f that takes a list of strings as input and checks if each character in the strings follows a specific pattern. The function g generates a list of strings that follow the pattern 'abc' and the assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if characters in a list of strings follow a specific pattern. The solution function g generates strings that follow the pattern 'abc' and the puzzle function f checks if the input strings follow the same pattern.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5473031997680664,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves pattern recognition and list manipulation.",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False",
        "solution_func": "def g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given list of integers follows a specific pattern, and a function g that generates a list of integers based on a specific pattern. The goal is to determine if the generated list satisfies the pattern checking function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate a specific pattern of integers using a generator function and then checking if a list of integers follows that pattern using a comparison function. It requires knowledge of list manipulation, generators, and conditional statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4432905614376068,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    if solve():\n        return True\n    return False\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    if solve():\n        return True\n    return False",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that solves a Sudoku puzzle using backtracking algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of backtracking algorithm and recursion to solve a Sudoku puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45765239000320435,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    for a in range(1, 50):\n        for b in range(a, 50):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 4,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True",
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False",
        "solution_func": "def g() -> List[int]:\n    for a in range(1, 50):\n        for b in range(a, 50):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exists a Pythagorean triplet (three integers that satisfy the Pythagorean theorem) in a given list of integers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5022273063659668,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, set operations, and permutations and combinations.",
        "idx_generation": 4,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False",
        "solution_func": "def g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a set of three numbers from a given set where the sum of the squares of two numbers is equal to the square of the third number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of sets, combinations, and basic mathematical concepts like Pythagorean theorem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4556485414505005,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    if len(nums) < 3:\n        return False\n    return all(nums[i] == nums[i-1] + nums[i-2] for i in range(2, len(nums)))\n    \ndef g(length=5):\n    if length < 3:\n        return []\n    fibonacci = [0, 1]\n    while len(fibonacci) < length:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic. It checks if a list of numbers follows the Fibonacci sequence pattern.",
        "idx_generation": 4,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List \ndef f(nums: List[int], has_prime=True) -> bool:\n    return any(num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) for num in nums) == has_prime\ndef g(range_end=20):\n    return [num for num in range(2, range_end + 1) if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    if len(nums) < 3:\n        return False\n    return all(nums[i] == nums[i-1] + nums[i-2] for i in range(2, len(nums)))",
        "solution_func": "def g(length=5):\n    if length < 3:\n        return []\n    fibonacci = [0, 1]\n    while len(fibonacci) < length:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers follows the Fibonacci sequence pattern."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that checks if a list of numbers follows the Fibonacci sequence pattern, and then provide a solution function that generates a list of Fibonacci numbers based on a given length. The assertion at the end checks if the solution function produces a list that satisfies the Fibonacci sequence pattern according to the checking function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5265190005302429,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list) -> bool:\n    return all(arr[i] - arr[i-1] == arr[1] - arr[0] for i in range(2, len(arr)))\n\ndef g(start=1, diff=3, length=5):\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Mathematical Operations, Conditional Logic, and List Operations.",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g()) == True",
            "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g():\n    return \"deified\"\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(arr: list) -> bool:\n    return all(arr[i] - arr[i-1] == arr[1] - arr[0] for i in range(2, len(arr)))",
        "solution_func": "def g(start=1, diff=3, length=5):\n    return [start + diff*i for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given list of numbers forms an arithmetic sequence, and a function g that generates an arithmetic sequence based on the provided start, difference, and length parameters. The assertion at the end confirms that the generated sequence satisfies the condition of function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding arithmetic sequences and how to check if a list of numbers forms an arithmetic sequence. It also requires implementing a function to generate arithmetic sequences based on given parameters.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5393578410148621,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return len(set(s)) == len(s)\n\ndef g(length=6):\n    import string\n    import random\n    unique_chars = random.sample(string.ascii_lowercase, length)\n    return ''.join(unique_chars)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and set operations.",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g()) == True",
            "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g():\n    return \"deified\"\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return len(set(s)) == len(s)",
        "solution_func": "def g(length=6):\n    import string\n    import random\n    unique_chars = random.sample(string.ascii_lowercase, length)\n    return ''.join(unique_chars)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a random string of a specified length and check if all characters in the string are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using random sampling and string manipulation in Python to create a string with unique characters and then checking if all characters in the string are unique.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.4172828495502472,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g() -> str:\n    # Generate a palindrome string\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a given text is a palindrome. The solution generates a palindrome string and checks if it satisfies the palindrome condition.",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(ans: List[List[int]], target=17) -> bool:\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 17):\n    return [[0, 2]] * target\nassert f(g()) == True"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g() -> str:\n    # Generate a palindrome string\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that checks if a given string is a palindrome, and then generate a palindrome string using a predefined function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The student needs to write a function that checks if a given string is a palindrome by comparing it with its reverse. The solution function generates a predefined palindrome string 'level' and the puzzle is solved if the function correctly identifies it as a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6021428108215332,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choices(letters, k=random.randint(3, 10)))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choices(letters, k=random.randint(3, 10)))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation in Python, specifically checking for palindromes and generating random strings. It also requires knowledge of slicing and concatenation in strings.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4506663680076599,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that checks for duplicates in a list of integers, and then generate a list of integers with a duplicate element. The solution function generates a list of integers with one duplicate element, and the puzzle is to implement a function that can detect this duplicate element."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets, lists, loops, and random number generation in Python. It tests the student's ability to detect duplicates in a list of integers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4167989492416382,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 5,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number or not, and a function g() that returns the number 17. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6697810888290405,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, n=5) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return result == factorial(n)\n\ndef g(n=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and recursion to calculate the factorial of a number.",
        "idx_generation": 5,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int, n=5) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return result == factorial(n)",
        "solution_func": "def g(n=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the result of a given function g is equal to the factorial of a specified number n. The function g calculates the factorial of a given number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of functions, recursion, and equality comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6360939145088196,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"racecar\"):\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 5,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "\ndef f(arr: list) -> bool:\n    return all(arr[i] - arr[i-1] == arr[1] - arr[0] for i in range(2, len(arr)))\n\ndef g(start=1, diff=3, length=5):\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"racecar\"):\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, and a function g(s) that returns the reverse of a string, the puzzle requires g to be a solution to f by checking if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically reversing a string and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6034215092658997,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(start=1, end=10, length=5):\n    return random.sample(range(start, end+1), length)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves generating a random list of numbers and checking if all numbers in the list are unique.",
        "idx_generation": 5,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "\ndef f(arr: list) -> bool:\n    return all(arr[i] - arr[i-1] == arr[1] - arr[0] for i in range(2, len(arr)))\n\ndef g(start=1, diff=3, length=5):\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))",
        "solution_func": "def g(start=1, end=10, length=5):\n    return random.sample(range(start, end+1), length)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random list of numbers within a specified range and length, and checking if all the numbers in the list are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of generating random samples and checking for uniqueness in a list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.466179221868515,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={2, 3, 4, 5, 6}) -> bool:\n    return intersection == set1.intersection(set2)\ndef g(set1={1, 2, 3, 4, 5}, set2={2, 3, 4, 5, 6}):\n    return set1.intersection(set2)\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations and conditional logic.",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(intersection: set, set1={1, 2, 3, 4, 5}, set2={2, 3, 4, 5, 6}) -> bool:\n    return intersection == set1.intersection(set2)",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={2, 3, 4, 5, 6}):\n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the intersection of two sets is equal to a given intersection set, and a function g that returns the intersection of two sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of sets and set operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6292049884796143,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves backtracking to find if a given list can be partitioned into two subsets with equal sum.",
        "idx_generation": 6,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9, 11]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list can be partitioned into two sublists with equal sums."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to check if a given list can be partitioned into two sublists with equal sums. The solution function generates a list of numbers and checks if the partition function returns True for it.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.36361706256866455,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 6,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)",
        "solution_func": "def g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing the N-Queens problem using a recursive backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement the N-Queens problem using a recursive backtracking algorithm to find a solution where no two queens can attack each other on a chessboard.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3674739599227905,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(filter(str.isalpha, s)).lower()\n    return s == s[::-1]\n\ndef g(input_str='A man, a plan, a canal, Panama!'):\n    input_str = ''.join(filter(str.isalpha, input_str)).lower()\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(filter(str.isalpha, s)).lower()\n    return s == s[::-1]",
        "solution_func": "def g(input_str='A man, a plan, a canal, Panama!'):\n    input_str = ''.join(filter(str.isalpha, input_str)).lower()\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphabetic characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, filtering non-alphabetic characters, converting characters to lowercase, and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.38231533765792847,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Set Operations and Brute Force Search.",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g():\n    return [1, -1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function f that takes a list of integers and a target integer, and checks if there are two numbers in the list that sum up to the target. The solution function g returns a list containing two integers [1, -1]."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to use a set to efficiently check for the presence of a specific number in a list. The solution function g returns a list that satisfies the condition of the puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5315686464309692,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Set Operations and Brute Force Search as it uses a set to keep track of seen numbers and iterates through the input list to find a pair of numbers that sum up to the target value.",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g(arr=[10, 20, 30, 40]):\n    return arr",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding if there are two numbers in a given list that add up to a target value of 50."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there are two numbers in a list that add up to a specific target value. The solution function returns the input list as is.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.627755880355835,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, k=3) -> bool:\n    return n % k == 0\n\ndef g(n=42):\n    return n\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int, k=3) -> bool:\n    return n % k == 0",
        "solution_func": "def g(n=42):\n    return n",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given number is divisible by a specified value k, and g returns a default number. The puzzle requires g to be called within f to check if the default number satisfies the condition in f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is about understanding function definitions, default arguments, and function calls in Python. It tests the student's ability to use functions and parameters effectively.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6420075297355652,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.)",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g()) == True"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False",
        "solution_func": "def g(arr=[10, 20, 30, 40, 50]):\n    return arr",
        "quality": [
            null
        ],
        "description": [
            "Given a list of integers, the puzzle function f checks if there exists a subset of the list that sums up to a target value of 100. The solution function g returns a list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using combinations to find all possible subsets of the input list and checking if any subset sums up to the target value. The solution function simply returns the input list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5115569829940796,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str, vowels=\"aeiou\") -> bool:\n    vowels_in_order = ''.join(sorted(set(word) & set(vowels)))\n    return vowels_in_order == vowels\ndef g(vowels=\"aeiou\"):\n    import random\n    shuffled_vowels = list(vowels)\n    random.shuffle(shuffled_vowels)\n    return ''.join(shuffled_vowels)\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations, Importing Modules (Itertools, etc.)",
        "idx_generation": 6,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(word: str, vowels=\"aeiou\") -> bool:\n    vowels_in_order = ''.join(sorted(set(word) & set(vowels)))\n    return vowels_in_order == vowels",
        "solution_func": "def g(vowels=\"aeiou\"):\n    import random\n    shuffled_vowels = list(vowels)\n    random.shuffle(shuffled_vowels)\n    return ''.join(shuffled_vowels)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if the vowels in a given word are in a specific order, and a function g that shuffles the vowels and returns the shuffled string. The puzzle tests whether the shuffled vowels in the output of g are in the correct order as defined by f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, set operations, sorting, and shuffling in Python. It also tests the concept of function composition and validation of the solution.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.50886470079422,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(s: str, n=3) -> bool:\n    if n < len(s):\n        return s[n].isalpha()\n    return False\n\ndef g(n=5):\n    chars = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n))\n    return chars\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and random generation of characters. The function f checks if a character at a specific index in a string is an alphabet character. The solution function g generates a random string of characters and passes it to function f to check if the character at index n is an alphabet character.",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True"
        ],
        "problem_func": "import random\n\ndef f(s: str, n=3) -> bool:\n    if n < len(s):\n        return s[n].isalpha()\n    return False",
        "solution_func": "def g(n=5):\n    chars = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n))\n    return chars",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that takes a string and an optional integer parameter, and checks if a specific character in the string is an alphabet character. The function g generates a random string of lowercase alphabets of a specified length, and the assert statement checks if f applied to the output of g returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, random generation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5191813707351685,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal by comparing it with its transpose.",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True"
        ],
        "problem_func": "import numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)",
        "solution_func": "def g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random symmetric matrix and checking if it is symmetric by comparing it with its transpose."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of numpy arrays, matrix operations, and symmetry checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3861333429813385,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    # Check if the input string is a palindrome\n    return s == s[::-1]\n\ndef g(s=\"madam\"):\n    # Generate the reverse of the input string\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List \nfrom itertools import permutations\ndef f(words: List[str], has_anagram=True) -> bool:\n    return any(sorted(word) == sorted(words[0]) for word in words) == has_anagram\ndef g(word=\"listen\"):\n    return [''.join(p) for p in permutations(word)]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    # Check if the input string is a palindrome\n    return s == s[::-1]",
        "solution_func": "def g(s=\"madam\"):\n    # Generate the reverse of the input string\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given string is a palindrome and g generates the reverse of a string. The assertion tests if the reverse of a default string is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic string manipulation and palindrome checking in Python, which can be a good exercise for students to practice their understanding of functions and string operations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5666126012802124,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver algorithm in Python using a recursive backtracking approach."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a recursive backtracking algorithm. The function should check for valid moves and recursively fill in the empty cells until a solution is found.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.42192235589027405,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Dynamic Programming to solve the unique paths problem for a grid. The solution uses a 2D array to store intermediate results and calculates the total unique paths for a 3x7 grid.",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid",
        "solution_func": "def g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the total unique paths for a 3x7 grid using dynamic programming and checking if the result is equal to 28."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to calculate unique paths in a grid and then checking if the result matches the expected value of 28.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5178913474082947,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return len(permutations) == 6  # Total unique permutations for 'abc'\n\ndef g():\n    def permute(s):\n        if len(s) == 0:\n            return ['']\n        prev_list = permute(s[1:])\n        next_list = []\n        for i in range(len(prev_list)):\n            for j in range(len(prev_list[i]) + 1):\n                next_list.append(prev_list[i][:j] + s[0] + prev_list[i][j:])\n        return next_list\n\n    return permute('abc')\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return len(permutations) == 6  # Total unique permutations for 'abc'",
        "solution_func": "def g():\n    def permute(s):\n        if len(s) == 0:\n            return ['']\n        prev_list = permute(s[1:])\n        next_list = []\n        for i in range(len(prev_list)):\n            for j in range(len(prev_list[i]) + 1):\n                next_list.append(prev_list[i][:j] + s[0] + prev_list[i][j:])\n        return next_list\n\n    return permute('abc')",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all unique permutations of the string 'abc' and checking if the total number of permutations is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that generates permutations of a given string and then check if the number of unique permutations is equal to 6 for the string 'abc'. The solution function should correctly generate all permutations and return True if there are 6 unique permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.34300681948661804,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list, diff=3) -> bool:\n    return all(arr[i] - arr[i - 1] == diff for i in range(1, len(arr)))\ndef g(start=10, length=5):\n    return [start + i * 3 for i in range(length)]\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and List Operations.",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(arr: list, diff=3) -> bool:\n    return all(arr[i] - arr[i - 1] == diff for i in range(1, len(arr)))",
        "solution_func": "def g(start=10, length=5):\n    return [start + i * 3 for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if the elements in a list have a constant difference of 3 between them, and a function g that generates a list with a starting value and a specified length where each element has a difference of 3 from the previous one. The assertion checks if function f returns True when applied to the list generated by function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and checking for a specific pattern in a list. It can be used to teach students about list operations and algorithmic thinking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5669152140617371,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\ndef g(s=\"A man a plan a canal Panama\"):\n    return \"\".join(char for char in s if char.isalpha())[::-1]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man a plan a canal Panama\"):\n    return \"\".join(char for char in s if char.isalpha())[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing spaces and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4834948778152466,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Backtracking, Graph Theory (paths, edges, vertices)",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))",
        "solution_func": "def g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a path through a graph where each node is visited exactly once. The function f checks if a given path satisfies the conditions, and the function g finds a valid path through the graph."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves graph traversal and backtracking to find a valid path through the graph. The functions f and g work together to define and solve the path-finding challenge.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.33047449588775635,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(words: List[str]) -> bool:\n    return sum(len(word) % 2 for word in words) <= 1\n\ndef g(words=['madam', 'racecar', 'hello', 'level']):\n    from itertools import permutations\n    for perm in permutations(words):\n        if all(perm[i] == perm[-i - 1] for i in range(len(perm) // 2)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and permutations and combinations.",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\ndef f(words: List[str]) -> bool:\n    return sum(len(word) % 2 for word in words) <= 1",
        "solution_func": "def g(words=['madam', 'racecar', 'hello', 'level']):\n    from itertools import permutations\n    for perm in permutations(words):\n        if all(perm[i] == perm[-i - 1] for i in range(len(perm) // 2)):\n            return list(perm)\n    return []",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of words can be rearranged to form a palindrome. The function f checks if the words can be rearranged to form a palindrome by checking the length of each word. The function g generates permutations of the input words and checks if any permutation forms a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of list manipulation, permutations, and palindrome checking in Python. It provides a practical application of these concepts in a programming challenge.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3930743336677551,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)\n\ndef g(numbers=[3, 6, 2, 8, 1, 9]):\n    from itertools import combinations\n    longest_subsequence = []\n    for r in range(1, len(numbers) + 1):\n        for subseq in combinations(numbers, r):\n            if list(subseq) == sorted(subseq) and len(subseq) > len(longest_subsequence):\n                longest_subsequence = list(subseq)\n    return longest_subsequence\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a subsequence of numbers and finding the longest sorted subsequence. It also uses itertools for generating combinations of numbers.",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)",
        "solution_func": "def g(numbers=[3, 6, 2, 8, 1, 9]):\n    from itertools import combinations\n    longest_subsequence = []\n    for r in range(1, len(numbers) + 1):\n        for subseq in combinations(numbers, r):\n            if list(subseq) == sorted(subseq) and len(subseq) > len(longest_subsequence):\n                longest_subsequence = list(subseq)\n    return longest_subsequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers contains a subsequence that is sorted. The solution function finds the longest sorted subsequence in the list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of sorting algorithms and subsequence manipulation in Python. It requires students to implement a function to find the longest sorted subsequence in a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3922078013420105,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.), Set Operations",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)",
        "solution_func": "def g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of permutations of a given string is equal to the set of valid permutations of the same string. The solution function g generates all permutations of a given string and returns them as a list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of generating permutations in Python using itertools and comparing sets. The solution function correctly generates all permutations and the puzzle function checks if the generated permutations match the valid permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.44264665246009827,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))",
        "solution_func": "def g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of tuples based on a specific key and in a specific order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of sorting lists of tuples using the sorted() function with a custom key function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5074175596237183,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom collections import Counter\n\ndef f(char: str, text=\"abracadabra\") -> bool:\n    char_count = Counter(text)\n    most_common_char, count = char_count.most_common(1)[0]\n    return most_common_char == char and count % 2 != 0\n\ndef g(text=\"abracadabra\"):\n    char_count = Counter(text)\n    return char_count.most_common(1)[0][0]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and importing modules (collections). It also involves conditional logic and assertion testing.",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from collections import Counter\n\ndef f(char: str, text=\"abracadabra\") -> bool:\n    char_count = Counter(text)\n    most_common_char, count = char_count.most_common(1)[0]\n    return most_common_char == char and count % 2 != 0",
        "solution_func": "def g(text=\"abracadabra\"):\n    char_count = Counter(text)\n    return char_count.most_common(1)[0][0]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the most common character in a given text is a specific character and if its count is odd. The solution function g returns the most common character in the text. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with the Counter class from the collections module in Python to find the most common character in a text and checking its count. The solution function g simply returns the most common character. The assertion ensures that the solution function g satisfies the conditions of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5166151523590088,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(permutation: list) -> bool:\n    return sum(permutation) % 2 == 0\n\ndef g(nums=[1, 2, 3]):\n    for perm in itertools.permutations(nums):\n        if sum(perm) % 2 == 0:\n            return list(perm)\n    return []\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves permutations and combinations to find a solution that satisfies a specific condition.",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(permutation: list) -> bool:\n    return sum(permutation) % 2 == 0",
        "solution_func": "def g(nums=[1, 2, 3]):\n    for perm in itertools.permutations(nums):\n        if sum(perm) % 2 == 0:\n            return list(perm)\n    return []",
        "quality": [
            null
        ],
        "description": [
            "Given a list of numbers, find a permutation of the list such that the sum of the permutation is even."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires finding a permutation of a given list of numbers such that the sum of the permutation is even.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4525902271270752,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking, Recursion",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver using a backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of backtracking algorithm and recursion to solve a Sudoku puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4514707922935486,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return str(n) == str(n)[::-1] and is_prime(n)\n\ndef g() -> int:\n    def generate_next_prime_palindrome(num):\n        def is_palindrome(s):\n            return str(s) == str(s)[::-1]\n\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        num += 1\n        while True:\n            if is_palindrome(num) and is_prime(num):\n                return num\n            num += 1\n\n    return generate_next_prime_palindrome(10)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, palindrome checking, and nested functions.",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return str(n) == str(n)[::-1] and is_prime(n)",
        "solution_func": "def g() -> int:\n    def generate_next_prime_palindrome(num):\n        def is_palindrome(s):\n            return str(s) == str(s)[::-1]\n\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        num += 1\n        while True:\n            if is_palindrome(num) and is_prime(num):\n                return num\n            num += 1\n\n    return generate_next_prime_palindrome(10)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given number is a palindrome and a prime number, and a function g() that generates the next prime palindrome number after a given number. The puzzle requires g() to return the next prime palindrome number after 10, and f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of palindrome numbers, prime numbers, and function composition in Python. It challenges students to implement and combine these concepts to solve the given problem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.503225564956665,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 8,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False",
        "solution_func": "def g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exists a Pythagorean triplet (three integers a, b, and c) in the given list of integers such that a^2 + b^2 = c^2.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5170228481292725,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(words: List[str]) -> bool:\n    return len(set(''.join(sorted(word)) for word in words)) == 1\n\ndef g():\n    import random\n    words = ['listen', 'silent', 'triangle', 'integral', 'debit card', 'bad credit']\n    anagram = random.choice(words)\n    return [anagram] * len(words)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations to check if a list of words are anagrams of each other.",
        "idx_generation": 8,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(words: List[str]) -> bool:\n    return len(set(''.join(sorted(word)) for word in words)) == 1",
        "solution_func": "def g():\n    import random\n    words = ['listen', 'silent', 'triangle', 'integral', 'debit card', 'bad credit']\n    anagram = random.choice(words)\n    return [anagram] * len(words)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of words contains an anagram of a randomly chosen word, and returning True if all words in the list are anagrams of the chosen word."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of string manipulation, list operations, and the concept of anagrams in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4527536928653717,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves importing the itertools module and using combinations. It also involves set operations and checking for certain conditions within the given tuples. The solution function simply returns the given tuples.",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True",
            "\nimport random\n\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(start=1, end=10, length=5):\n    return random.sample(range(start, end+1), length)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))",
        "solution_func": "def g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given set of tuples forms a complete graph by checking if all possible edges between nodes are present in the tuples."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of sets, tuples, combinations, and boolean logic in Python to determine if the given tuples represent a complete graph.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.41430768370628357,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6713947653770447,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as prime numbers, random number generation, and function definition.",
        "idx_generation": 9,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True",
            "def f(x: int, a=-8783800228130606, b=-508993556991975) -> bool:\n    return a - x == b\ndef g(a = -8783800228130606, b = -508993556991975):\n    return a - b\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold",
        "solution_func": "def g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num: int, threshold=10) that checks if a given number is a prime number and if the sum of its digits is greater than a specified threshold. The solution function g(threshold) generates a random prime number between 2 and 100, ensuring that the generated number satisfies the conditions of function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, functions, loops, and conditionals in Python. It provides a good exercise for students to practice implementing and testing functions that involve number manipulation and prime number checking.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4655214846134186,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [x for x in arr if x != 0]\n        return len(set(arr)) == len(arr)\n\n    def is_valid_sudoku(board):\n        for row in board:\n            if not is_valid(row):\n                return False\n        \n        for col in zip(*board):\n            if not is_valid(col):\n                return False\n        \n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        \n        return True\n\n    return is_valid_sudoku(board)\n\ndef g():\n    def solve_sudoku(board):\n        def is_valid_move(row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[start_row + i][start_col + j] == num:\n                        return False\n            return True\n\n        def solve():\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == 0:\n                        for num in range(1, 10):\n                            if is_valid_move(row, col, num):\n                                board[row][col] = num\n                                if solve():\n                                    return True\n                                board[row][col] = 0\n                        return False\n            return True\n\n        solve()\n        return board\n\n    return solve_sudoku([[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                         [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                         [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                         [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                         [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                         [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                         [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                         [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                         [0, 0, 0, 0, 8, 0, 0, 7, 9]])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [x for x in arr if x != 0]\n        return len(set(arr)) == len(arr)\n\n    def is_valid_sudoku(board):\n        for row in board:\n            if not is_valid(row):\n                return False\n        \n        for col in zip(*board):\n            if not is_valid(col):\n                return False\n        \n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        \n        return True\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g():\n    def solve_sudoku(board):\n        def is_valid_move(row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[start_row + i][start_col + j] == num:\n                        return False\n            return True\n\n        def solve():\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == 0:\n                        for num in range(1, 10):\n                            if is_valid_move(row, col, num):\n                                board[row][col] = num\n                                if solve():\n                                    return True\n                                board[row][col] = 0\n                        return False\n            return True\n\n        solve()\n        return board\n\n    return solve_sudoku([[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                         [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                         [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                         [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                         [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                         [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                         [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                         [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                         [0, 0, 0, 0, 8, 0, 0, 7, 9]])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid or not. The 'f' function checks if the given board is a valid Sudoku board, and the 'g' function solves a Sudoku board by filling in the missing numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing functions to check the validity of a Sudoku board and solve a Sudoku puzzle. It requires understanding of nested loops, recursion, and basic Sudoku rules. This puzzle can be used to teach Python programming to master's students in CS as it covers algorithmic challenges and problem-solving skills.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.40384161472320557,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(word=\"radar\"):\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(word=\"radar\"):\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome by comparing it with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome. The function g(word) concatenates a word with its reverse. The assert statement checks if the output of g() satisfies the condition of being a palindrome according to f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5761874914169312,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, importing modules (Itertools), and algorithm optimization.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False",
        "solution_func": "def g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet from a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that checks for the presence of a Pythagorean triplet in a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5366626977920532,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(points: list) -> bool:\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) != 0\n\ndef g():\n    points = [(random.randint(1, 10), random.randint(1, 10)) for _ in range(3)]\n    return points\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to check if three points are collinear using the cross product formula. Random points are generated and checked for collinearity.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(points: list) -> bool:\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) != 0",
        "solution_func": "def g():\n    points = [(random.randint(1, 10), random.randint(1, 10)) for _ in range(3)]\n    return points",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating random points and checking if the points form a triangle with non-zero area."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate random points and calculate the area of a triangle using the determinant formula.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4995707869529724,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(min_coins: int, target_sum=11, coins=[1, 3, 5]) -> bool:\n    dp = [float('inf')] * (target_sum + 1)\n    dp[0] = 0\n\n    for i in range(1, target_sum + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target_sum] == min_coins\n\ndef g(target_sum=11, coins=[1, 3, 5]):\n    dp = [float('inf')] * (target_sum + 1)\n    dp[0] = 0\n\n    for i in range(1, target_sum + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target_sum]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 9,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(min_coins: int, target_sum=11, coins=[1, 3, 5]) -> bool:\n    dp = [float('inf')] * (target_sum + 1)\n    dp[0] = 0\n\n    for i in range(1, target_sum + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target_sum] == min_coins",
        "solution_func": "def g(target_sum=11, coins=[1, 3, 5]):\n    dp = [float('inf')] * (target_sum + 1)\n    dp[0] = 0\n\n    for i in range(1, target_sum + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target_sum]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function f that calculates the minimum number of coins needed to reach a target sum using dynamic programming, and a function g that calculates the minimum number of coins without checking if it matches a specific value."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of how to calculate the minimum number of coins needed to reach a target sum. The solution function g calculates the minimum number of coins without checking if it matches a specific value, which may not be suitable for teaching purposes as it does not directly solve the challenge posed by function f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45667001605033875,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(result: str) -> bool:\n    return result == 'Heads'\n\ndef g(probability: float = 0.7) -> str:\n    result = 'Heads' if random.random() < probability else 'Tails'\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and conditional logic. The solution uses the random module for generating a result based on a given probability and then checks if the result is 'Heads'.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(result: str) -> bool:\n    return result == 'Heads'",
        "solution_func": "def g(probability: float = 0.7) -> str:\n    result = 'Heads' if random.random() < probability else 'Tails'\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given result is 'Heads', and a function g that generates a result of either 'Heads' or 'Tails' based on a given probability. The puzzle requires g to generate 'Heads' with a probability of 0.7 for f to return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate a result based on a probability and checking if the generated result satisfies a condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5764000415802002,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, importing modules (NumPy), and probability and statistics.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)",
        "solution_func": "def g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a numpy array of random numbers, calculating the mean and standard deviation of the array, and checking if the mean is close to 0 and the standard deviation is close to 1 within a tolerance of 0.1."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of numpy arrays, mean, standard deviation, and the np.isclose function in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4044305086135864,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum == 4\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a list of numbers satisfies a specific condition.",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum == 4",
        "solution_func": "def g():\n    return [1, 2, 3, 5, 6, 7, 8]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a list of numbers that is missing a specific element to satisfy a mathematical condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the sum of a list of numbers and comparing it to the expected sum of a consecutive sequence of numbers. The solution should provide a list of numbers missing a specific element to make the condition true.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5543793439865112,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_palindrome(num) and is_prime(num)\n\ndef g():\n    import random\n\n    def generate_palindrome_prime():\n        def is_palindrome(n):\n            return str(n) == str(n)[::-1]\n        \n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(10, 1000)\n        while not is_palindrome(num) or not is_prime(num):\n            num = random.randint(10, 1000)\n        return num\n\n    return generate_palindrome_prime()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to string manipulation, mathematical operations, conditional logic, and number theory (primes).",
        "idx_generation": 10,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_palindrome(num) and is_prime(num)",
        "solution_func": "def g():\n    import random\n\n    def generate_palindrome_prime():\n        def is_palindrome(n):\n            return str(n) == str(n)[::-1]\n        \n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(10, 1000)\n        while not is_palindrome(num) or not is_prime(num):\n            num = random.randint(10, 1000)\n        return num\n\n    return generate_palindrome_prime()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a random number between 10 and 1000, checking if it is both a palindrome and a prime number, and returning it. The solution function generates random numbers until it finds one that satisfies both conditions."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of palindrome checking, prime number checking, random number generation, and function composition in Python. It provides a practical exercise in combining multiple functions to solve a specific problem.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44384726881980896,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, input_string=\"radar\") -> bool:\n    return s == s[::-1]\ndef g(input_string=\"radar\"):\n    return input_string[::-1]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, input_string=\"radar\") -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_string=\"radar\"):\n    return input_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given string is a palindrome, and a function g that returns the reverse of a predefined string. The assertion checks if the reverse of the predefined string is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically reversing a string and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6445732116699219,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as Set Operations, Brute Force Search, and Conditional Logic.",
        "idx_generation": 10,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "def f(x: float, a=2732656229) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 2732656229):\n    return a ** 0.5\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g(num_list=[2, 4, 6, 8]):\n    return num_list",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding if there are two numbers in a list that add up to a target sum of 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there are two numbers in a list that add up to a specific target sum. The function f() checks for this condition, and function g() returns a list of numbers. The assertion at the end checks if the function f() returns True when applied to the output of function g().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5369109511375427,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, k=3) -> bool:\n    return num % k == 0\n\ndef g(k=3):\n    return 7 * k\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 10,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "def f(x: float, a=2732656229) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 2732656229):\n    return a ** 0.5\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int, k=3) -> bool:\n    return num % k == 0",
        "solution_func": "def g(k=3):\n    return 7 * k",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given number is divisible by a specified value k, and a function g that returns a value based on k. The puzzle requires g to be defined in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of function definitions, parameter passing, and function invocation in Python. It also requires understanding of how to ensure that the output of one function satisfies the condition of another function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.698714017868042,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic, recursion, and binary operations.",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)",
        "solution_func": "def g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a TreeNode class and two functions f and g. Function f checks if a binary search tree is valid, and function g creates a sample binary search tree to test the validity using function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding binary search trees and recursion in Python. Students need to implement the TreeNode class, the validation function, and the creation of a sample binary search tree to test the validation function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4906241297721863,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    board = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)",
        "solution_func": "def g():\n    board = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver algorithm in Python using a recursive backtracking approach."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a recursive backtracking algorithm. The solution function initializes a Sudoku board and returns it for testing the implemented solver function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.434200644493103,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    length = random.randint(5, 10)\n    random_string = ''.join(random.choice(letters) for _ in range(length))\n    palindrome_string = random_string + random_string[::-1]\n\n    return palindrome_string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    length = random.randint(5, 10)\n    random_string = ''.join(random.choice(letters) for _ in range(length))\n    palindrome_string = random_string + random_string[::-1]\n\n    return palindrome_string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string concatenated with its reverse is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string, creating a palindrome by concatenating the string with its reverse, and checking if the resulting string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4023153483867645,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s='radar'):\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s='radar'):\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not. The function f(s) returns True if the input string is a palindrome, and the function g(s) returns the reverse of the default string 'radar'. The assert statement checks if the function g(s) correctly identifies 'radar' as a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes in strings using Python functions. It is a simple and straightforward puzzle that can be used to teach string manipulation and condition checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5626005530357361,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    target_sequence = [1, 2, 3, 4]  # Sequence to find in the matrix\n    \n    def find_sequence_in_row(row):\n        for i in range(len(row) - len(target_sequence) + 1):\n            if row[i:i+len(target_sequence)] == target_sequence:\n                return True\n        return False\n\n    for row in matrix:\n        if find_sequence_in_row(row):\n            return True\n    return False\n\ndef g(matrix=[[1, 2, 3, 4, 5],\n             [6, 7, 8, 9, 10],\n             [11, 12, 1, 2, 3],\n             [4, 5, 6, 7, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Pattern Recognition, Brute Force Search",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    target_sequence = [1, 2, 3, 4]  # Sequence to find in the matrix\n    \n    def find_sequence_in_row(row):\n        for i in range(len(row) - len(target_sequence) + 1):\n            if row[i:i+len(target_sequence)] == target_sequence:\n                return True\n        return False\n\n    for row in matrix:\n        if find_sequence_in_row(row):\n            return True\n    return False",
        "solution_func": "def g(matrix=[[1, 2, 3, 4, 5],\n             [6, 7, 8, 9, 10],\n             [11, 12, 1, 2, 3],\n             [4, 5, 6, 7, 8]]):\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a specific sequence of numbers in a matrix and returning True if the sequence is found in any row of the matrix."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves searching for a target sequence in each row of a matrix and returning True if the sequence is found in any row. The solution function g simply returns a predefined matrix. The puzzle is focused on matrix manipulation and sequence searching in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44779571890830994,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(phrase: str, target='python') -> bool:\n    return target in phrase\n\ndef g(target='python') -> str:\n    return f'{target} {target} {target}'\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(phrase: str, target='python') -> bool:\n    return target in phrase",
        "solution_func": "def g(target='python') -> str:\n    return f'{target} {target} {target}'",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a target string is present in a given phrase, and g generates a string with the target repeated three times. The puzzle tests whether the target string 'python' is present in the output of g when called without arguments."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is a simple exercise that involves understanding function definitions, string manipulation, and function invocation in Python. It can be used to reinforce basic concepts in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5974083542823792,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\nimport string\n\ndef f(password: str) -> bool:\n    return len(password) == 10 and any(char.isdigit() for char in password) and any(char.islower() for char in password) and any(char.isupper() for char in password)\n\ndef g(length=10):\n    letters = string.ascii_letters + string.digits\n    password = ''.join(random.choice(letters) for _ in range(length))\n    \n    return password\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\nimport string\n\ndef f(password: str) -> bool:\n    return len(password) == 10 and any(char.isdigit() for char in password) and any(char.islower() for char in password) and any(char.isupper() for char in password)",
        "solution_func": "def g(length=10):\n    letters = string.ascii_letters + string.digits\n    password = ''.join(random.choice(letters) for _ in range(length))\n    \n    return password",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a random password of length 10 containing at least one digit, one lowercase letter, and one uppercase letter. The solution function generates a random password meeting these criteria and the puzzle function checks if the generated password meets the requirements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random password and checking if it meets specific criteria. It can be used to teach students about string manipulation, random generation, and boolean conditions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3758624792098999,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves solving a problem related to array manipulation and determining if a sequence of jumps can reach the end. It requires understanding of array traversal and conditional logic.",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)",
        "solution_func": "def g(nums = [2, 3, 1, 1, 4]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that checks if it is possible to reach the last index in a list of integers by jumping based on the values in the list. The solution function returns the input list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding and implementing a function to determine if it is possible to reach the end of the list by jumping based on the values in the list. The solution function simply returns the input list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5037704110145569,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to find the maximum subarray sum, which falls under the topics of Dynamic Programming and Algorithm Optimization.",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0",
        "solution_func": "def g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of a subarray within a given list of integers and checking if the maximum sum is greater than 0."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of subarrays, dynamic programming, and comparison operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4316086769104004,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Permutations and Combinations as it uses the itertools module to find permutations of a list of numbers.",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))",
        "solution_func": "def g(nums = [1, 2, 3]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that checks if the number of unique permutations of a list of integers is equal to the total number of permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding permutations, sets, and function implementation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.46534794569015503,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.)",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations",
        "solution_func": "def g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a target permutation is present in a list of permutations generated from a given string using itertools.permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate permutations of a string using itertools.permutations and check if a specific permutation is present in the list of generated permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4736841022968292,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    def generate_next_fibonacci():\n        a, b = 0, 1\n        while True:\n            yield str(a)\n            a, b = b, a + b\n\n    fib_gen = generate_next_fibonacci()\n    for _ in range(3):  # Skip the first 3 Fibonacci numbers\n        next(fib_gen)\n    return next(fib_gen)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and recursion.",
        "idx_generation": 12,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True",
            "\ndef f(n: int) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return str(n) == str(n)[::-1] and is_prime(n)\n\ndef g() -> int:\n    def generate_next_prime_palindrome(num):\n        def is_palindrome(s):\n            return str(s) == str(s)[::-1]\n\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        num += 1\n        while True:\n            if is_palindrome(num) and is_prime(num):\n                return num\n            num += 1\n\n    return generate_next_prime_palindrome(10)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    def generate_next_fibonacci():\n        a, b = 0, 1\n        while True:\n            yield str(a)\n            a, b = b, a + b\n\n    fib_gen = generate_next_fibonacci()\n    for _ in range(3):  # Skip the first 3 Fibonacci numbers\n        next(fib_gen)\n    return next(fib_gen)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if the string returned by the function g is a palindrome or not. Function f checks if a given string is a palindrome, and function g generates the fourth Fibonacci number as a string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if the fourth Fibonacci number is a palindrome. The student needs to understand how to generate Fibonacci numbers and check for palindromes in strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.5186527967453003,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(strings: List[str], target='python') -> bool:\n    return any(target in s for s in strings)\n\ndef g(target='python'):\n    import random\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 10))) for _ in range(5)]\n    strings[random.randint(0, 4)] += target  # ensure at least one string contains the target\n    return strings\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(strings: List[str], target='python') -> bool:\n    return any(target in s for s in strings)",
        "solution_func": "def g(target='python'):\n    import random\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 10))) for _ in range(5)]\n    strings[random.randint(0, 4)] += target  # ensure at least one string contains the target\n    return strings",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that checks if a target string is present in a list of randomly generated strings. The solution function generates a list of random strings and ensures that at least one string contains the target string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with lists, strings, random module, and boolean operations in Python. It tests the students' understanding of list comprehension, string manipulation, and boolean expressions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.37150779366493225,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\nimport string\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(length=5):\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    palindrome = ''.join(random.choices(letters, k=half_length))\n    if length % 2 == 1:\n        palindrome += random.choice(letters)\n    palindrome += palindrome[::-1]\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to create a palindrome and then check if it is indeed a palindrome.",
        "idx_generation": 12,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\ndef f(result: int, n=5) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return result == factorial(n)\n\ndef g(n=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\nimport string\n\ndef f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(length=5):\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    palindrome = ''.join(random.choices(letters, k=half_length))\n    if length % 2 == 1:\n        palindrome += random.choice(letters)\n    palindrome += palindrome[::-1]\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g(length) that generates a random palindrome string of a specified length. The assertion at the end checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in strings and generating random strings in Python. It also tests the understanding of slicing and concatenation in strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.39372795820236206,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, importing modules (Itertools), and pattern recognition.",
        "idx_generation": 12,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\ndef f(result: int, n=5) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return result == factorial(n)\n\ndef g(n=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False",
        "solution_func": "def g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exists a Pythagorean triplet (a, b, c) in the list of numbers such that a^2 + b^2 = c^2.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5014070868492126,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sentence: str) -> bool:\n    clean_sentence = ''.join(char.lower() for char in sentence if char.isalnum())\n    return clean_sentence == clean_sentence[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    def generate_palindrome():\n        letters = string.ascii_lowercase\n        palindrome = random.choice(letters)\n        for _ in range(random.randint(2, 5)):\n            char = random.choice(letters)\n            palindrome = char + palindrome + char\n        return palindrome\n\n    return generate_palindrome()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization, Importing Modules",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sentence: str) -> bool:\n    clean_sentence = ''.join(char.lower() for char in sentence if char.isalnum())\n    return clean_sentence == clean_sentence[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    def generate_palindrome():\n        letters = string.ascii_lowercase\n        palindrome = random.choice(letters)\n        for _ in range(random.randint(2, 5)):\n            char = random.choice(letters)\n            palindrome = char + palindrome + char\n        return palindrome\n\n    return generate_palindrome()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing non-alphanumeric characters, and a function g that generates a random palindrome string with a length between 2 and 5 characters."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and random generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3638371527194977,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, div=5) -> bool:\n    return result % div == 0\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and recursion.",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: int, div=5) -> bool:\n    return result % div == 0",
        "solution_func": "def g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the result of g is divisible by a given number. The assert statement checks if the result of g satisfies the condition in f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves recursion and checking divisibility in Python. It can be used to teach students about recursion, function calls, and conditional statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6791156530380249,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 12,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\ndef f(numbers: list, target=True) -> bool:\n    if target:\n        return all(numbers[i] - numbers[i-1] == numbers[1] - numbers[0] for i in range(2, len(numbers)))\n    else:\n        return False\n\ndef g(size=4):\n    return [2*i + 1 for i in range(size)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(number) that checks if a number is prime, write a function g() that returns 17 and assert that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to understand prime numbers and write a function that returns a specific number (17) to satisfy the condition of being prime.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.7172479033470154,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Set Operations and Randomization.",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)",
        "solution_func": "def g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a list of 7 unique random numbers between 1 and 20, and then check if all the numbers in the list are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a list of random numbers, checking for uniqueness, and comparing the length of the list with the length of unique numbers to determine if all numbers are unique.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4042283892631531,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g():\n    import random\n    import string\n\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given text is a palindrome, and a function g that generates a random string and appends its reverse to create a palindrome. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of palindromes and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.501563310623169,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sequence: list) -> bool:\n    return sequence == sequence[::-1]\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given sequence is a palindrome or not.",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sequence: list) -> bool:\n    return sequence == sequence[::-1]",
        "solution_func": "def g():\n    return [1, 2, 3, 2, 1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given list is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(sequence) that returns True if the input list is a palindrome (reads the same forwards and backwards). The solution function g() returns a list that is a palindrome, and the assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6441729068756104,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n    s = ''.join(random.choice(string.ascii_lowercase) for _ in range(10))\n    s += s[::-1]  # Make a palindrome string\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if numbers[i]**2 + numbers[j]**2 == numbers[k]**2:\n                    return True\n    return False\n\ndef g():\n    import random\n    numbers = [random.randint(1, 20) for _ in range(7)]\n    # Generate a list where a Pythagorean triplet exists\n    numbers.append((numbers[-1]**2 + numbers[-2]**2)**0.5)\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n    s = ''.join(random.choice(string.ascii_lowercase) for _ in range(10))\n    s += s[::-1]  # Make a palindrome string\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome after removing non-alphanumeric characters, and a function g() that generates a random palindrome string for testing f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and random string generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45725539326667786,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int], threshold=100) -> bool:\n    return sum(numbers) > threshold\n\ndef g(threshold=10):\n    return [i**2 for i in range(1, threshold+1)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int], threshold=100) -> bool:\n    return sum(numbers) > threshold",
        "solution_func": "def g(threshold=10):\n    return [i**2 for i in range(1, threshold+1)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the sum of a list of squared numbers is greater than a given threshold. The solution function g generates a list of squared numbers up to a specified threshold, and the assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic list comprehension and summing elements in a list. It also tests the understanding of function parameters and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5499503016471863,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion, backtracking, and list manipulation.",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)",
        "solution_func": "def g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a subset of numbers from a given list can sum up to a target sum. The function f(numbers, target_sum) checks if such a subset exists, and the function g(target_sum) generates a list of numbers to test against f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves recursion and backtracking to find a subset of numbers that sum up to a target sum. The solution function g generates a list of numbers that should sum up to the target sum. The assert statement at the end checks if the solution function g satisfies the condition of the puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3894389867782593,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and probability and statistics.",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2",
        "solution_func": "def g():\n    return 3.5",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random sample of dice rolls, calculating the average value, and checking if the average value is within a certain range of an expected value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of random number generation, averaging, and comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.508740246295929,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str=\"racecar\"):\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List \ndef f(nums: List[int], has_prime=True) -> bool:\n    return any(num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) for num in nums) == has_prime\ndef g(range_end=20):\n    return [num for num in range(2, range_end + 1) if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))]\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"racecar\"):\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f(s: str) -> bool and g(input_str='racecar'), where f checks if a string is a palindrome and g generates a palindrome by concatenating a string with its reverse. The assert statement checks if the solution function g() satisfies the condition of the puzzle."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome and generating a palindrome by concatenating a string with its reverse. The solution function g() correctly generates a palindrome, satisfying the condition of the puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6237350106239319,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n    \n    for row in board:\n        if not is_valid(row):\n            return False\n        \n    for col in range(9):\n        if not is_valid([board[i][col] for i in range(9)]):\n            return False\n        \n    for i in range(3):\n        for j in range(3):\n            subgrid = [board[x][y] for x in range(3*i, 3*i+3) for y in range(3*j, 3*j+3)]\n            if not is_valid(subgrid):\n                return False\n    return True\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires knowledge of set operations and conditional logic.",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n    \n    for row in board:\n        if not is_valid(row):\n            return False\n        \n    for col in range(9):\n        if not is_valid([board[i][col] for i in range(9)]):\n            return False\n        \n    for i in range(3):\n        for j in range(3):\n            subgrid = [board[x][y] for x in range(3*i, 3*i+3) for y in range(3*j, 3*j+3)]\n            if not is_valid(subgrid):\n                return False\n    return True",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid or not by ensuring that each row, column, and 3x3 subgrid contains unique numbers from 1 to 9."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of nested loops, list comprehensions, and basic logic in Python. It also reinforces the concept of checking for uniqueness in rows, columns, and subgrids in a Sudoku board.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.40228548645973206,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(combos: List[List[int]], target_sum=10) -> bool:\n    return any(sum(c) == target_sum for c in combos)\n\ndef g(numbers=[2, 3, 4, 5]):\n    def backtrack(curr_combo, remaining_nums, target):\n        if sum(curr_combo) == target:\n            combos.append(curr_combo)\n            return\n        for i, num in enumerate(remaining_nums):\n            if sum(curr_combo) + num <= target:\n                backtrack(curr_combo + [num], remaining_nums[i+1:], target)\n    \n    combos = []\n    backtrack([], numbers, 10)\n    return combos\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves backtracking to find combinations that sum up to a target value.",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(combos: List[List[int]], target_sum=10) -> bool:\n    return any(sum(c) == target_sum for c in combos)",
        "solution_func": "def g(numbers=[2, 3, 4, 5]):\n    def backtrack(curr_combo, remaining_nums, target):\n        if sum(curr_combo) == target:\n            combos.append(curr_combo)\n            return\n        for i, num in enumerate(remaining_nums):\n            if sum(curr_combo) + num <= target:\n                backtrack(curr_combo + [num], remaining_nums[i+1:], target)\n    \n    combos = []\n    backtrack([], numbers, 10)\n    return combos",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if any combination of numbers in a list adds up to a target sum. The solution function g generates all possible combinations of numbers from a given list that add up to the target sum."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves backtracking to generate all possible combinations of numbers that add up to a target sum. The solution function g uses backtracking to find these combinations and returns them. The puzzle can be used to teach students about backtracking and solving combinatorial problems in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.359587162733078,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import permutations\n\ndef f(permutation: str) -> bool:\n    return 'abc' in permutation\n\ndef g():\n    string = 'abcd'\n    for perm in permutations(string):\n        if 'abc' in ''.join(perm):\n            return ''.join(perm)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and importing modules (Itertools). It uses permutations to generate all possible permutations of a given string and checks if a specific substring 'abc' is present in any of the permutations.",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import permutations\n\ndef f(permutation: str) -> bool:\n    return 'abc' in permutation",
        "solution_func": "def g():\n    string = 'abcd'\n    for perm in permutations(string):\n        if 'abc' in ''.join(perm):\n            return ''.join(perm)",
        "quality": [
            null
        ],
        "description": [
            "Given a string 'abcd', the puzzle requires finding a permutation of the string where the substring 'abc' exists."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating permutations of a string and checking if a specific substring exists in any of the permutations.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5168377161026001,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sequence: List[int]) -> bool:\n    pattern = [2, 4, 6, 8]  # Example pattern to check\n    if len(sequence) < len(pattern):\n        return False\n    for i in range(len(sequence) - len(pattern) + 1):\n        if all(sequence[i+j] == pattern[j] for j in range(len(pattern))):\n            return True\n    return False\n\ndef g():\n    pattern = [2, 4, 6, 8]\n    sequence = []\n    for i in range(1, 11):\n        sequence.extend(pattern if i % 2 == 0 else [1, 3, 5, 7])\n    return sequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Pattern recognition, Brute Force Search",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sequence: List[int]) -> bool:\n    pattern = [2, 4, 6, 8]  # Example pattern to check\n    if len(sequence) < len(pattern):\n        return False\n    for i in range(len(sequence) - len(pattern) + 1):\n        if all(sequence[i+j] == pattern[j] for j in range(len(pattern))):\n            return True\n    return False",
        "solution_func": "def g():\n    pattern = [2, 4, 6, 8]\n    sequence = []\n    for i in range(1, 11):\n        sequence.extend(pattern if i % 2 == 0 else [1, 3, 5, 7])\n    return sequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given sequence contains a specific pattern of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand list manipulation, iteration, and pattern matching in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4936753809452057,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(diff: int, numbers=[5, 10, 2, 8, 3]) -> bool:\n    return diff == max(numbers) - min(numbers)\n\ndef g(numbers=[5, 10, 2, 8, 3]):\n    return max(numbers) - min(numbers)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, List Operations, and Conditional Logic.",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(diff: int, numbers=[5, 10, 2, 8, 3]) -> bool:\n    return diff == max(numbers) - min(numbers)",
        "solution_func": "def g(numbers=[5, 10, 2, 8, 3]):\n    return max(numbers) - min(numbers)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f and g, where f checks if the difference between the maximum and minimum numbers in a list is equal to a given value, and g calculates the difference between the maximum and minimum numbers in a list. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to define functions, work with lists, calculate the maximum and minimum values, and compare values in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6451207995414734,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (primality testing) and Conditional Logic.",
        "idx_generation": 14,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given number is prime, and a function g() that finds the next prime number. The assertion at the end checks if the next prime number found by g() satisfies the prime check in f()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, loops, conditionals, and function definitions in Python. It provides a practical application of prime number checking and generation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.624608039855957,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_even: int, target=44) -> bool:\n    return sum_even == target\n\ndef g(target=44):\n    fibonacci = [1, 2]\n    while fibonacci[-1] + fibonacci[-2] <= target:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    sum_even = sum(num for num in fibonacci if num % 2 == 0)\n    return sum_even\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, loops, conditionals, and list comprehension.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_even: int, target=44) -> bool:\n    return sum_even == target",
        "solution_func": "def g(target=44):\n    fibonacci = [1, 2]\n    while fibonacci[-1] + fibonacci[-2] <= target:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    sum_even = sum(num for num in fibonacci if num % 2 == 0)\n    return sum_even",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that calculates the sum of even Fibonacci numbers up to a given target, and another function that checks if the sum of even Fibonacci numbers is equal to the target."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with Fibonacci numbers, loops, conditionals, and list comprehensions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5254313349723816,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g(word=\"level\"):\n    return word\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation to check if a word is a palindrome. The solution simply returns a word 'level' which is a palindrome. The assertion checks if the solution function returns the correct result for the given puzzle function.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    target_sequence = [1, 2, 3, 4]  # Sequence to find in the matrix\n    \n    def find_sequence_in_row(row):\n        for i in range(len(row) - len(target_sequence) + 1):\n            if row[i:i+len(target_sequence)] == target_sequence:\n                return True\n        return False\n\n    for row in matrix:\n        if find_sequence_in_row(row):\n            return True\n    return False\n\ndef g(matrix=[[1, 2, 3, 4, 5],\n             [6, 7, 8, 9, 10],\n             [11, 12, 1, 2, 3],\n             [4, 5, 6, 7, 8]]):\n    return matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g(word=\"level\"):\n    return word",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given word is a palindrome by comparing it with its reverse. The solution function g returns a default word 'level'. The assertion checks if the solution function g returns a palindrome word.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6195998787879944,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join([c.lower() for c in s if c.isalnum()])\n    return s == s[::-1]\n\ndef g(s=\"A man a plan a canal Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Conditional Logic are used in the problem f and solution g.",
        "idx_generation": 14,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join([c.lower() for c in s if c.isalnum()])\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man a plan a canal Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function to check if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after certain modifications.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.47010698914527893,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int, n=5) -> bool:\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    return factorial == recursive_factorial(n)\ndef g(n = 5):\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    return recursive_factorial(n)\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Mathematical Operations",
        "idx_generation": 14,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "def f(n: int, a=14, b=50, c=47) -> bool:\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])\nassert f(g()) == True"
        ],
        "problem_func": "def f(factorial: int, n=5) -> bool:\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    return factorial == recursive_factorial(n)",
        "solution_func": "def g(n = 5):\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    return recursive_factorial(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the factorial of a given number matches a recursive factorial calculation, and g calculates the factorial of a given number using recursion. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of recursion and function calls in Python by comparing a factorial calculation using recursion in two different functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6555072069168091,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves backtracking to solve the Knight's Tour problem, which is a classic algorithmic challenge in graph theory. It also involves recursion to explore all possible moves of the knight on the chessboard. Additionally, it requires conditional logic to check for valid moves and to backtrack when necessary. The puzzle does not directly involve other topics such as string manipulation, mathematical operations, dynamic programming, etc.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)",
        "solution_func": "def g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function to solve the Knight's Tour problem using recursion and backtracking in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion, backtracking, and the Knight's Tour problem. The function f() checks if a Knight's Tour is possible on a given chessboard, while function g() initializes the chessboard for the Knight's Tour problem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.38429582118988037,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums=[1, 3, 5, 7, 9, 11, 13]) -> bool:\n    differences = [nums[i] - nums[i - 1] for i in range(1, len(nums))]\n    return all(d == 2 for d in differences)\n\ndef g(start=1, diff=2, length=7):\n    return [start + diff * i for i in range(length)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to check if a list of numbers follows a specific pattern.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums=[1, 3, 5, 7, 9, 11, 13]) -> bool:\n    differences = [nums[i] - nums[i - 1] for i in range(1, len(nums))]\n    return all(d == 2 for d in differences)",
        "solution_func": "def g(start=1, diff=2, length=7):\n    return [start + diff * i for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of numbers has a constant difference of 2 between consecutive elements. The solution function g generates a list of numbers with a specified starting point, difference, and length to satisfy the condition in f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and the all() function in Python. It also requires applying arithmetic operations to generate a list of numbers with a specific pattern.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5364913940429688,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \ndef f(words: List[str], target_word='listen') -> bool:\n    def is_anagram(w1, w2):\n        return sorted(w1) == sorted(w2)\n\n    return any(is_anagram(word, target_word) for word in words)\n\ndef g(target_word='listen'):\n    from itertools import permutations\n    return [''.join(p) for p in permutations(target_word)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Permutations and Combinations",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List \ndef f(words: List[str], target_word='listen') -> bool:\n    def is_anagram(w1, w2):\n        return sorted(w1) == sorted(w2)\n\n    return any(is_anagram(word, target_word) for word in words)",
        "solution_func": "def g(target_word='listen'):\n    from itertools import permutations\n    return [''.join(p) for p in permutations(target_word)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to determine if any words in a given list are anagrams of a target word. The solution generates all permutations of the target word and checks if any of them are present in the list of words."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding anagrams, list comprehension, and itertools permutations in Python. It provides a practical application of these concepts.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3089539706707001,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Backtracking, Recursion, Algorithm Optimization",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True",
        "solution_func": "def g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid or not. The function f(board) checks if the Sudoku board is valid by ensuring that each row, column, and subgrid contains unique numbers from 1 to 9. The function g() generates a solved Sudoku board using a backtracking algorithm and returns it. The puzzle is considered solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a classic Sudoku validation problem and a backtracking algorithm to solve Sudoku boards. It provides a good exercise for students to understand validation logic and backtracking algorithms in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45548662543296814,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to remove duplicates from a list of numbers.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))",
        "solution_func": "def g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a list of random numbers, ensuring there are no duplicates, and then checking if the length of the list is equal to the length of the set of numbers in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, set operations, and random number generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.39495614171028137,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n    import string\n\n    words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 5))) for _ in range(5)]\n    return sorted(words)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering topics.",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)",
        "solution_func": "def g():\n    import random\n    import string\n\n    words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 5))) for _ in range(5)]\n    return sorted(words)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a list of random strings and checking if the list is sorted alphabetically."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a list of random strings, sorting them alphabetically, and then checking if the sorted list is equal to the original list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4095595180988312,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sudoku: list) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku(sudoku)\n    return all(all(cell != 0 for cell in row) for row in sudoku)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sudoku: list) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku(sudoku)\n    return all(all(cell != 0 for cell in row) for row in sudoku)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a given Sudoku board is valid and solvable, and a solution function that provides a partially filled Sudoku board. The goal is to fill in the missing cells of the Sudoku board such that it satisfies the Sudoku rules."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a Sudoku solver using a recursive backtracking algorithm. The solution function provides a partially filled Sudoku board, and the challenge is to complete the board in a way that satisfies the Sudoku rules. The puzzle requires understanding of nested loops, recursion, and logical conditions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4222576320171356,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"racecar\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g(s) that returns a default string 'racecar'. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6722137331962585,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not using a simple algorithm. It covers topics such as number theory (primes) and mathematical operations.",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=17):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num) which checks if a given number is a prime number, and g(num) which returns a specific number (default is 17). The puzzle requires g to return a prime number for the assertion to pass."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6493780612945557,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))\n\ndef g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + diff*i for i in range(5)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and list manipulation.",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))",
        "solution_func": "def g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + diff*i for i in range(5)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of numbers forms an arithmetic sequence with a common difference, and a function g that generates a random arithmetic sequence of length 5. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list manipulation, arithmetic sequences, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.567319929599762,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(volume: float, vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]) -> bool:\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6 - volume) < 1e-6\n\ndef g(vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]):\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to calculate the volume of a tetrahedron using determinants. It also includes floating-point arithmetic for precision comparison.",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(volume: float, vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]) -> bool:\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6 - volume) < 1e-6",
        "solution_func": "def g(vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]):\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the volume of a tetrahedron defined by given vertices is within a small margin of error compared to a specified volume."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of determinants and geometric calculations to check if the volume of a tetrahedron matches a given volume within a tolerance level.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48875701427459717,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sequence: List[int]) -> bool:\n    pattern = [0, 1, 0, 1]  # Pattern to find in the sequence\n\n    for i in range(len(sequence) - len(pattern) + 1):\n        if sequence[i:i+len(pattern)] == pattern:\n            return True\n    return False\n\ndef g(sequence=[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]):\n    return sequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Pattern Recognition, Brute Force Search",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    target_sequence = [1, 2, 3, 4]  # Sequence to find in the matrix\n    \n    def find_sequence_in_row(row):\n        for i in range(len(row) - len(target_sequence) + 1):\n            if row[i:i+len(target_sequence)] == target_sequence:\n                return True\n        return False\n\n    for row in matrix:\n        if find_sequence_in_row(row):\n            return True\n    return False\n\ndef g(matrix=[[1, 2, 3, 4, 5],\n             [6, 7, 8, 9, 10],\n             [11, 12, 1, 2, 3],\n             [4, 5, 6, 7, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(sequence: List[int]) -> bool:\n    pattern = [0, 1, 0, 1]  # Pattern to find in the sequence\n\n    for i in range(len(sequence) - len(pattern) + 1):\n        if sequence[i:i+len(pattern)] == pattern:\n            return True\n    return False",
        "solution_func": "def g(sequence=[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]):\n    return sequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a specific pattern [0, 1, 0, 1] in a given sequence of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if the pattern [0, 1, 0, 1] exists in the given sequence by iterating through the sequence and comparing subarrays.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.49754494428634644,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(numbers: list, threshold=10) -> bool:\n    max_num = max(numbers)\n    min_num = min(numbers)\n    return (max_num - min_num) > threshold\n\ndef g(size: int = 100, min_val=1, max_val=1000) -> list:\n    return [random.randint(min_val, max_val) for _ in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "import random\n\ndef f(numbers: list, threshold=10) -> bool:\n    max_num = max(numbers)\n    min_num = min(numbers)\n    return (max_num - min_num) > threshold",
        "solution_func": "def g(size: int = 100, min_val=1, max_val=1000) -> list:\n    return [random.randint(min_val, max_val) for _ in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the difference between the maximum and minimum numbers in a list is greater than a given threshold. Another function g generates a list of random numbers within a specified range. The assertion checks if f returns True when applied to the list generated by g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic concepts of list manipulation, random number generation, and function definition in Python. It can be used to teach students how to work with lists and functions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.491639107465744,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(numbers: list) -> bool:\n    sorted_nums = sorted(numbers, reverse=True)\n    return sum(sorted_nums[:3]) > sum(sorted_nums[-2:])\n\ndef g(size: int = 5, min_val=1, max_val=100) -> list:\n    return [random.randint(min_val, max_val) for _ in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of numbers, selecting specific elements from the sorted list, and comparing their sums. It also uses random number generation. The topics that are relevant to this puzzle are: Sorting and Ordering, Random Number Generation, List Manipulation, and Conditional Logic.",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "import random\n\ndef f(numbers: list) -> bool:\n    sorted_nums = sorted(numbers, reverse=True)\n    return sum(sorted_nums[:3]) > sum(sorted_nums[-2:])",
        "solution_func": "def g(size: int = 5, min_val=1, max_val=100) -> list:\n    return [random.randint(min_val, max_val) for _ in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "Given a list of numbers, the puzzle function f checks if the sum of the three largest numbers in the list is greater than the sum of the two smallest numbers. The solution function g generates a list of random numbers within a specified range and size."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of numbers and comparing the sums of specific subsets of the list. The solution function generates random numbers to test the puzzle function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.44348016381263733,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lcs_length: int) -> bool:\n    return lcs_length == 3  # Length of the Longest Common Subsequence (LCS) between \"abcdef\" and \"azced\"\n\ndef g():\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return dp[m][n]\n\n    return longest_common_subsequence(\"abcdef\", \"azced\")\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and dynamic programming to find the Longest Common Subsequence (LCS) between two strings.",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return len(permutations) == 6  # Total unique permutations for 'abc'\n\ndef g():\n    def permute(s):\n        if len(s) == 0:\n            return ['']\n        prev_list = permute(s[1:])\n        next_list = []\n        for i in range(len(prev_list)):\n            for j in range(len(prev_list[i]) + 1):\n                next_list.append(prev_list[i][:j] + s[0] + prev_list[i][j:])\n        return next_list\n\n    return permute('abc')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lcs_length: int) -> bool:\n    return lcs_length == 3  # Length of the Longest Common Subsequence (LCS) between \"abcdef\" and \"azced\"",
        "solution_func": "def g():\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return dp[m][n]\n\n    return longest_common_subsequence(\"abcdef\", \"azced\")",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the Longest Common Subsequence (LCS) between two strings and checking if it equals 3."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to find the LCS length between two strings and then checking if it equals a specific value. The provided solution calculates the LCS length between 'abcdef' and 'azced' and checks if it equals 3.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44375720620155334,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to Dynamic Programming and Recursion.",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return len(permutations) == 6  # Total unique permutations for 'abc'\n\ndef g():\n    def permute(s):\n        if len(s) == 0:\n            return ['']\n        prev_list = permute(s[1:])\n        next_list = []\n        for i in range(len(prev_list)):\n            for j in range(len(prev_list[i]) + 1):\n                next_list.append(prev_list[i][:j] + s[0] + prev_list[i][j:])\n        return next_list\n\n    return permute('abc')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time",
        "solution_func": "def g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves determining if the total number of ways to climb 4 steps with 1 or 2 steps at a time is equal to 5."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that calculates the number of ways to climb a certain number of steps using 1 or 2 steps at a time, and then check if the total ways equal 5.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5063319206237793,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, pattern='aba') -> bool:\n    return s == s[::-1]\ndef g(pattern='aba'):\n    return pattern + pattern[-2::-1]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, pattern='aba') -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(pattern='aba'):\n    return pattern + pattern[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f and g, where f checks if a given string is a palindrome and g generates a specific pattern based on the input pattern. The assertion checks if the output of g satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and checking for palindromes, which are common concepts in Python programming. It also tests the understanding of function definitions and assertions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6818457245826721,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        seen = set()\n        for num in arr:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    def check_rows_and_columns(board):\n        for row in board:\n            if not is_valid(row):\n                return False\n        for col in zip(*board):\n            if not is_valid(col):\n                return False\n        return True\n    \n    def check_subgrids(board):\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        return True\n    \n    return check_rows_and_columns(board) and check_subgrids(board)\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires understanding of list manipulation, loops, and sets. It also involves checking rows, columns, and subgrids, which can be considered as pattern recognition and algorithm optimization.",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        seen = set()\n        for num in arr:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    def check_rows_and_columns(board):\n        for row in board:\n            if not is_valid(row):\n                return False\n        for col in zip(*board):\n            if not is_valid(col):\n                return False\n        return True\n    \n    def check_subgrids(board):\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        return True\n    \n    return check_rows_and_columns(board) and check_subgrids(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid by ensuring that each row, column, and subgrid contains unique numbers from 1 to 9."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of nested loops, list comprehensions, and set operations in Python to validate a Sudoku board.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.35124218463897705,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def subset_sum(nums, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(nums):\n            return False\n\n        include = subset_sum(nums, target_sum, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target_sum, index + 1, current_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target_sum, 0, 0)\n\ndef g():\n    return [2, 4, 5, 6, 7, 8]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion, conditional logic, and backtracking to solve a subset sum problem.",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def subset_sum(nums, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(nums):\n            return False\n\n        include = subset_sum(nums, target_sum, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target_sum, index + 1, current_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target_sum, 0, 0)",
        "solution_func": "def g():\n    return [2, 4, 5, 6, 7, 8]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of integers can be divided into two subsets with equal sum."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and backtracking to solve the subset sum problem.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.33557260036468506,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sentence: List[str]) -> bool:\n    target_sentence = \"the quick brown fox jumps over the lazy dog\"\n    target_chars = {char for char in target_sentence if char != ' '}\n\n    sentence_chars = {char for word in sentence for char in word}\n\n    return sentence_chars == target_chars\n\ndef g():\n    return [\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Set Operations",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(sentence: List[str]) -> bool:\n    target_sentence = \"the quick brown fox jumps over the lazy dog\"\n    target_chars = {char for char in target_sentence if char != ' '}\n\n    sentence_chars = {char for word in sentence for char in word}\n\n    return sentence_chars == target_chars",
        "solution_func": "def g():\n    return [\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function f that checks if all the unique characters in a given list of words match the unique characters in a target sentence. The solution function g returns a list of words that match the target sentence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves comparing sets of unique characters in the input list of words with the unique characters in a target sentence. The solution function returns a list of words that exactly match the target sentence.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.37585121393203735,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sorted_list: List[int], target_sum=30) -> bool:\n    return sum(sorted_list[:3]) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30]):\n    sorted_list = sorted(numbers)\n    return sorted_list\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves sorting a list of numbers and finding the sum of the first three elements to match a target sum. It also includes a function call with default arguments and an assertion for testing the solution. The topics used in this puzzle are sorting and ordering, list manipulation, and conditional logic.",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(sorted_list: List[int], target_sum=30) -> bool:\n    return sum(sorted_list[:3]) == target_sum",
        "solution_func": "def g(numbers=[10, 20, 15, 5, 25, 30]):\n    sorted_list = sorted(numbers)\n    return sorted_list",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that takes a list of numbers, sorts them, and returns the first three elements of the sorted list. The function f checks if the sum of the first three elements of the sorted list is equal to a target sum of 30."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of numbers and checking if the sum of the first three elements equals a target sum. The solution function g sorts the input list and returns the sorted list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5292609333992004,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17) -> int:\n    if num < 2:\n        return 2\n    for i in range(num+1, num*2):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            return i\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (factors, primes, etc.) and Mathematical Operations topics.",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
            "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=17) -> int:\n    if num < 2:\n        return 2\n    for i in range(num+1, num*2):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            return i",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num) and g(num=17), where f checks if a number is prime and g finds the next prime number after a given number. The assertion checks if g returns a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers and iteration in Python. It requires understanding of how to check for prime numbers and find the next prime number after a given number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.616690456867218,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Conditional Logic",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
            "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')",
        "solution_func": "def g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the second largest element in a list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a function to find the second largest element in a list of integers. The solution function should return a list of integers and the puzzle function should check if the second largest element exists in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5259827971458435,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return True\n    return False\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            c = (a**2 + b**2) ** 0.5\n            if c == int(c):\n                return [a, b, int(c)]\n\nassert f(g()) == True\n",
            "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g()) == True"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that returns True if the word is a palindrome (reads the same forwards and backwards), and a function g() that returns the word 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6371090412139893,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(len(word) >= 3 and word.islower() and word[0] == 'a' for word in words) and len(set(words)) == len(words)\n\ndef g():\n    import string\n    import random\n    return ['a' + ''.join(random.choice(string.ascii_lowercase) for _ in range(3, 8)) for _ in range(5)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(l: List[int]) -> bool:\n    return all((i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j)) and len(set(l)) > 995\ndef g():\n    return [0, 4] + list(range(6, 1000))\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(len(word) >= 3 and word.islower() and word[0] == 'a' for word in words) and len(set(words)) == len(words)",
        "solution_func": "def g():\n    import string\n    import random\n    return ['a' + ''.join(random.choice(string.ascii_lowercase) for _ in range(3, 8)) for _ in range(5)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a list of 5 random words starting with 'a' and checking if each word has a length of at least 3, is in lowercase, and is unique within the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating random words and checking specific conditions on each word in the list. The solution function generates the list of random words and the puzzle function checks if the conditions are met for each word in the list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.37660109996795654,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization, Palindromes",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome, and a function g that generates a random palindrome string. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.45763665437698364,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "This puzzle involves backtracking to find combinations that sum up to a target value.",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3) + i//3][3*(col//3) + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result",
        "solution_func": "def g():\n    return [[2, 2, 3], [7]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if the output of a function g matches a specific result based on a combination sum algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion, backtracking, and list manipulation in Python to solve the combination sum problem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4952034652233124,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a string is a palindrome.",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    return [3, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6734470129013062,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)\n\ndef g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, importing modules (math), and algorithm optimization (finding the closest distance efficiently).",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)",
        "solution_func": "def g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the closest distance between a set of points and checking if it is approximately equal to a specific value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function to calculate the closest distance between points and then check if it matches a predefined value with a tolerance.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4509781301021576,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    clean_string = ''.join(char.lower() for char in string if char.isalnum())\n    return clean_string == clean_string[::-1]\n\ndef g(string=\"A man, a plan, a canal, Panama\"):\n    return string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    clean_string = ''.join(char.lower() for char in string if char.isalnum())\n    return clean_string == clean_string[::-1]",
        "solution_func": "def g(string=\"A man, a plan, a canal, Panama\"):\n    return string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function to check if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase. The solution function returns the input string without any modifications.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4767611026763916,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, write a function g(input_str) that appends the reverse of the input string to itself and returns the result. The puzzle requires g to be implemented in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a function can correctly generate a palindrome by appending the reverse of a given input string to itself.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5278455018997192,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom sympy import isprime\n\ndef f(numbers: list) -> bool:\n    return any(isprime(num) for num in numbers)\n\ndef g(size=5):\n    primes = [2, 3, 5, 7, 11]  # First few prime numbers\n    return primes[:size]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if numbers are prime and generating a list of prime numbers.",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "from sympy import isprime\n\ndef f(numbers: list) -> bool:\n    return any(isprime(num) for num in numbers)",
        "solution_func": "def g(size=5):\n    primes = [2, 3, 5, 7, 11]  # First few prime numbers\n    return primes[:size]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if any number in a given list is a prime number. The solution function generates a list of prime numbers based on a specified size and checks if any of them are prime using the first few prime numbers as a reference."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for prime numbers in a list and generating a list of prime numbers. The solution function returns a list of prime numbers based on a specified size and checks if any of them are prime using the first few prime numbers as a reference.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5853356122970581,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(number=17):\n    return number\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory (primes).",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(number=17):\n    return number",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(num) that checks if a number is prime, write a function g(number) that returns a specific number and satisfies the condition f(g()) == True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to write a function g(number) that returns a specific number which is prime according to the function f(num). In this case, the specific number is 17.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6316853165626526,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, threshold=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    \n    return is_prime(n) and digit_sum(n) > threshold\n\ndef g(nums=[101, 257, 349], threshold=10):\n    import itertools\n    \n    for num in itertools.count(start=2):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            if sum(int(digit) for digit in str(num)) > threshold:\n                return num\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as prime numbers, digit manipulation, iteration, and assertion testing.",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int, threshold=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    \n    return is_prime(n) and digit_sum(n) > threshold",
        "solution_func": "def g(nums=[101, 257, 349], threshold=10):\n    import itertools\n    \n    for num in itertools.count(start=2):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            if sum(int(digit) for digit in str(num)) > threshold:\n                return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given number is prime and if the sum of its digits is greater than a threshold. The solution function g generates numbers iteratively, checks if they are prime and have a digit sum greater than the threshold, and returns the first number that satisfies these conditions."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, digit manipulation, and iteration in Python. The solution function g uses itertools to generate numbers and checks for prime and digit sum conditions. The assert statement at the end ensures that the solution function g satisfies the conditions of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4829494059085846,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    return is_palindrome(n) and n % sum_of_digits(n) == 0\n\ndef g(nums=[12321, 45654, 78987]):\n    for num in nums:\n        if str(num) == str(num)[::-1] and num % sum(int(digit) for digit in str(num)) == 0:\n            return num\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Mathematical Operations",
        "idx_generation": 17,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
            "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int) -> bool:\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    return is_palindrome(n) and n % sum_of_digits(n) == 0",
        "solution_func": "def g(nums=[12321, 45654, 78987]):\n    for num in nums:\n        if str(num) == str(num)[::-1] and num % sum(int(digit) for digit in str(num)) == 0:\n            return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a number is a palindrome and if it is divisible by the sum of its digits."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of palindrome checking, sum of digits calculation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5289664268493652,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(distance: float, point1=(0, 0), point2=(3, 4)) -> bool:\n    return math.isclose(distance, math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2))\n\ndef g(point1=(0, 0), point2=(3, 4)) -> float:\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Geometry and Coordinate Manipulation as it deals with calculating the distance between two points in a 2D plane using the distance formula.",
        "idx_generation": 18,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(factorial: int) -> bool:\n    return factorial == 120\n\ndef g():\n    num = 5\n    result = 1\n    for i in range(1, num + 1):\n        result *= i\n    return result\n\nassert f(g()) == True\n",
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(distance: float, point1=(0, 0), point2=(3, 4)) -> bool:\n    return math.isclose(distance, math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2))",
        "solution_func": "def g(point1=(0, 0), point2=(3, 4)) -> float:\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the distance between two points and checking if it matches a given distance value within a tolerance."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to calculate the distance between two points using the Euclidean distance formula and compare it with a given distance value using a tolerance check.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5271910429000854,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Importing Modules (Itertools, etc.), and Exception Handling.",
        "idx_generation": 18,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(factorial: int) -> bool:\n    return factorial == 120\n\ndef g():\n    num = 5\n    result = 1\n    for i in range(1, num + 1):\n        result *= i\n    return result\n\nassert f(g()) == True\n",
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)",
        "solution_func": "def g(radius=5) -> float:\n    return math.pi * radius**2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given area is equal to the area of a circle with a given radius, and a function g that calculates the area of a circle with a default radius. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of functions, mathematical calculations, and assertion testing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6785974502563477,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
            "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3",
        "solution_func": "def g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing two functions in Python. The first function f checks if a given minimum spanning tree weight is equal to 3. The second function g calculates the minimum spanning tree weight of a given graph using Prim's algorithm. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding Prim's algorithm for finding the minimum spanning tree weight of a graph. It tests the student's knowledge of graph algorithms and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.400980144739151,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    def bfs(start, end):\n        queue = [start]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            visited.add(node)\n            for neighbor in [(node[0] + 1, node[1]), (node[0] - 1, node[1]), (node[0], node[1] + 1), (node[0], node[1] - 1)]:\n                if neighbor[0] >= 0 and neighbor[0] < len(grid) and neighbor[1] >= 0 and neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0 and neighbor not in visited:\n                    queue.append(neighbor)\n        return False\n\n    start, end = (0, 0), (len(grid) - 1, len(grid[0]) - 1)\n    return bfs(start, end)\n\ndef g():\n    return [[0, 0, 0], [1, 1, 0], [0, 0, 0]]\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    def bfs(start, end):\n        queue = [start]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            visited.add(node)\n            for neighbor in [(node[0] + 1, node[1]), (node[0] - 1, node[1]), (node[0], node[1] + 1), (node[0], node[1] - 1)]:\n                if neighbor[0] >= 0 and neighbor[0] < len(grid) and neighbor[1] >= 0 and neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0 and neighbor not in visited:\n                    queue.append(neighbor)\n        return False\n\n    start, end = (0, 0), (len(grid) - 1, len(grid[0]) - 1)\n    return bfs(start, end)",
        "solution_func": "def g():\n    return [[0, 0, 0], [1, 1, 0], [0, 0, 0]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(grid) that implements a breadth-first search algorithm to find a path from the top-left corner of a grid to the bottom-right corner, avoiding obstacles represented by non-zero values. The solution function g() returns a grid with obstacles and asserts that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a basic pathfinding algorithm using breadth-first search in a grid. The solution function g() provides a grid with obstacles to test the pathfinding algorithm implemented in function f().",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44049811363220215,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    clean_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return clean_s == clean_s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation using regular expressions to clean the input string and check if it is a palindrome.",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    clean_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return clean_s == clean_s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing all non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, regular expressions, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4434986710548401,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums_set = set(nums)\n    for a in nums_set:\n        for b in nums_set:\n            if a != b:\n                c = (a**2 + b**2) ** 0.5\n                if c in nums_set:\n                    return True\n    return False\n\ndef g(nums=[3, 5, 12, 13, 8]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, set operations, and conditional logic.",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums_set = set(nums)\n    for a in nums_set:\n        for b in nums_set:\n            if a != b:\n                c = (a**2 + b**2) ** 0.5\n                if c in nums_set:\n                    return True\n    return False",
        "solution_func": "def g(nums=[3, 5, 12, 13, 8]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding three numbers in a list such that they form a Pythagorean triplet (a^2 + b^2 = c^2)."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there exist three distinct numbers in a list that form a Pythagorean triplet. The function f checks for this condition by iterating through all possible combinations of numbers in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5129984617233276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"radar\"):\n    if len(s) <= 1:\n        return s\n    return s[0] + g(s[1:-1]) + s[-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and recursion.",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int, div=5) -> bool:\n    return result % div == 0\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"radar\"):\n    if len(s) <= 1:\n        return s\n    return s[0] + g(s[1:-1]) + s[-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f(s: str) -> bool which checks if a given string is a palindrome, and g(s='radar') which recursively constructs the mirror image of the input string. The assert statement checks if the output of g() satisfies the condition of being a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, recursion, and checking for palindromes in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5327705144882202,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(n=3):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"()\"]\n    \n    result = set()\n    for i in range(n):\n        for inside in g(i):\n            for outside in g(n - 1 - i):\n                result.add(\"(\" + inside + \")\" + outside)\n    \n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as Recursion, String Manipulation, Set Operations, and Conditional Logic.",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int, div=5) -> bool:\n    return result % div == 0\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0",
        "solution_func": "def g(n=3):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"()\"]\n    \n    result = set()\n    for i in range(n):\n        for inside in g(i):\n            for outside in g(n - 1 - i):\n                result.add(\"(\" + inside + \")\" + outside)\n    \n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(s) checks if a given string of parentheses is balanced, and g(n) generates all possible combinations of balanced parentheses for a given number n. The solution g(n) recursively generates all possible combinations of balanced parentheses."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and checking for balanced parentheses. It is a good exercise for students to practice recursion and understand how to check for balanced parentheses in a string.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3704322874546051,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 18,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome (reads the same forwards and backwards) by comparing the string with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if a given string is a palindrome, and a function g that returns a specific string 'radar'. The assertion tests if the function f applied to the output of function g returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6013628244400024,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g(base='racecar') -> str:\n    return base + base[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 18,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(result: int, div=5) -> bool:\n    return result % div == 0\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g(base='racecar') -> str:\n    return base + base[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given text is a palindrome by comparing it with its reverse. The solution generates a palindrome by appending the reverse of a given base string to itself."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python and checking for palindromes. The solution demonstrates how to create a palindrome by appending the reverse of a string to itself.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5674538016319275,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    palindrome = \"racecar\"\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation to check if a given string is a palindrome.",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n    \n    for row in board:\n        if not is_valid(row):\n            return False\n        \n    for col in range(9):\n        if not is_valid([board[i][col] for i in range(9)]):\n            return False\n        \n    for i in range(3):\n        for j in range(3):\n            subgrid = [board[x][y] for x in range(3*i, 3*i+3) for y in range(3*j, 3*j+3)]\n            if not is_valid(subgrid):\n                return False\n    return True\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    palindrome = \"racecar\"\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns a predefined palindrome string. The assertion checks if the function f(g()) returns True for the predefined palindrome string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6601732969284058,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int) -> bool:\n    return max_sum == 13\n\ndef g(numbers=[2, 4, 6, 2, 5]):\n    def max_non_adjacent_sum(nums):\n        if not nums:\n            return 0\n        inclusive, exclusive = 0, 0\n        for num in nums:\n            new_exclusive = max(inclusive, exclusive)\n            inclusive = exclusive + num\n            exclusive = new_exclusive\n        return max(inclusive, exclusive)\n\n    return max_non_adjacent_sum(numbers)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to determine if the maximum non-adjacent sum of a list of numbers is equal to 13.",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(max_sum: int) -> bool:\n    return max_sum == 13",
        "solution_func": "def g(numbers=[2, 4, 6, 2, 5]):\n    def max_non_adjacent_sum(nums):\n        if not nums:\n            return 0\n        inclusive, exclusive = 0, 0\n        for num in nums:\n            new_exclusive = max(inclusive, exclusive)\n            inclusive = exclusive + num\n            exclusive = new_exclusive\n        return max(inclusive, exclusive)\n\n    return max_non_adjacent_sum(numbers)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum sum of non-adjacent numbers in a list and checking if it equals 13."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the maximum sum of non-adjacent numbers in a list using dynamic programming and checking if the result is equal to a specific value (13 in this case).",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5200628042221069,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index]) or can_partition(nums, index + 1, current_sum)\n\n    return can_partition(nums, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to solve the subset sum problem, which requires recursion and conditional logic. It also involves backtracking to explore all possible subsets. Additionally, it touches on mathematical operations and list manipulation.",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index]) or can_partition(nums, index + 1, current_sum)\n\n    return can_partition(nums, 0, 0)",
        "solution_func": "def g(nums = [1, 5, 11, 5]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of integers can be partitioned into two subsets with equal sum using recursion."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and conditional statements to check for equal sum partitioning.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.40387001633644104,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, is_palindrome=True) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man a plan a canal Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str, is_palindrome=True) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"A man a plan a canal Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a given string is a palindrome after removing spaces and converting all characters to lowercase. The solution function returns a specific string that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is suitable for teaching Python programming concepts such as string manipulation, function definition, and palindrome checking.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.547398567199707,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g():\n    return [1, 2, 3, 4, 5, 5]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations to check for duplicates in a list of numbers.",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))",
        "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 5]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that takes a list of integers and returns True if there are duplicate elements in the list, and a function g that returns a list with duplicate elements. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list manipulation and the use of set to identify duplicate elements in a list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5370466709136963,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'level'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.66396564245224,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False",
        "solution_func": "def g():\n    return [3, 4, 5]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there exists a Pythagorean triplet (three integers that satisfy the Pythagorean theorem) in a given list of integers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4588920772075653,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Sorting and Ordering, Backtracking",
        "idx_generation": 19,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "solution_func": "def g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of permutations of [1, 2, 3] matches a specific set of permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating all permutations of [1, 2, 3] and checking if they match a predefined set of permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3414599895477295,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    def factorial_recursive(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial_recursive(n - 1)\n    \n    return result == factorial_recursive(5)\n\ndef g():\n    return 120\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Mathematical Operations",
        "idx_generation": 19,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
            "def f(n: int) -> bool:\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True\ndef g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: int) -> bool:\n    def factorial_recursive(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial_recursive(n - 1)\n    \n    return result == factorial_recursive(5)",
        "solution_func": "def g():\n    return 120",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function that checks if the result of a given function call matches the factorial of 5."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and factorial calculation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.640814483165741,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lcs: str, s1=\"ABCDGH\", s2=\"AEDFHR\") -> bool:\n    return lcs == \"ADH\"\n\ndef g(s1=\"ABCDGH\", s2=\"AEDFHR\"):\n    # dynamic programming approach to find longest common subsequence\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        lcs = \"\"\n        i, j = m, n\n        while i > 0 and j > 0:\n            if s1[i - 1] == s2[j - 1]:\n                lcs = s1[i - 1] + lcs\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n        return lcs\n\n    return longest_common_subsequence(s1, s2)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, String Manipulation",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lcs: str, s1=\"ABCDGH\", s2=\"AEDFHR\") -> bool:\n    return lcs == \"ADH\"",
        "solution_func": "def g(s1=\"ABCDGH\", s2=\"AEDFHR\"):\n    # dynamic programming approach to find longest common subsequence\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        lcs = \"\"\n        i, j = m, n\n        while i > 0 and j > 0:\n            if s1[i - 1] == s2[j - 1]:\n                lcs = s1[i - 1] + lcs\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n        return lcs\n\n    return longest_common_subsequence(s1, s2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest common subsequence between two given strings and checking if it matches a specific expected subsequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a dynamic programming approach to find the longest common subsequence between two strings and compare it to a predefined subsequence.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3028131127357483,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[str], characters=['a', 'b', 'c']) -> bool:\n    return len(permutations) == 6\n\ndef g(characters=['a', 'b', 'c']):\n    # generate all possible permutations of characters\n    import itertools\n    return [''.join(p) for p in itertools.permutations(characters)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves permutations and combinations as it requires generating all possible permutations of characters using itertools.permutations.",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[str], characters=['a', 'b', 'c']) -> bool:\n    return len(permutations) == 6",
        "solution_func": "def g(characters=['a', 'b', 'c']):\n    # generate all possible permutations of characters\n    import itertools\n    return [''.join(p) for p in itertools.permutations(characters)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all possible permutations of a given list of characters and checking if the number of permutations is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate permutations using itertools.permutations() and compare the length of the generated permutations list to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.40330445766448975,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        def is_valid_row(board, row):\n            seen = set()\n            for num in board[row]:\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        def is_valid_column(board, col):\n            seen = set()\n            for row in range(9):\n                num = board[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        def is_valid_box(board, start_row, start_col):\n            seen = set()\n            for row in range(3):\n                for col in range(3):\n                    num = board[start_row + row][start_col + col]\n                    if num != 0:\n                        if num in seen:\n                            return False\n                        seen.add(num)\n            return True\n\n        for i in range(9):\n            if not is_valid_row(board, i) or not is_valid_column(board, i):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if not is_valid_box(board, i, j):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires knowledge of conditional logic, nested loops, and set operations.",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        def is_valid_row(board, row):\n            seen = set()\n            for num in board[row]:\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        def is_valid_column(board, col):\n            seen = set()\n            for row in range(9):\n                num = board[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        def is_valid_box(board, start_row, start_col):\n            seen = set()\n            for row in range(3):\n                for col in range(3):\n                    num = board[start_row + row][start_col + col]\n                    if num != 0:\n                        if num in seen:\n                            return False\n                        seen.add(num)\n            return True\n\n        for i in range(9):\n            if not is_valid_row(board, i) or not is_valid_column(board, i):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if not is_valid_box(board, i, j):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to check the validity of a Sudoku board by ensuring that each row, column, and 3x3 subgrid contains unique numbers from 1 to 9.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45868974924087524,
        "judgeLM-7b-abs_finetuning": 7.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given string is a palindrome, and a function g that returns the string 'radar'. The assertion checks if the function f applied to the output of function g returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6734456419944763,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, target=10) -> bool:\n    return n % target == 0\n\ndef g(n=5, target=10) -> int:\n    return n * target\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations and Conditional Logic.",
        "idx_generation": 20,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17) -> int:\n    if num < 2:\n        return 2\n    for i in range(num+1, num*2):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            return i\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int, target=10) -> bool:\n    return n % target == 0",
        "solution_func": "def g(n=5, target=10) -> int:\n    return n * target",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given number is divisible by a target number, and g multiplies a number by a target number. The assertion checks if the output of g satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic arithmetic operations and function calls in Python. It can be used to teach students about function definitions, function calls, and assertions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6381373405456543,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, divisor=5) -> bool:\n    return n % divisor == 0\n\ndef g(n=3, divisor=5) -> int:\n    return n * divisor\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 20,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17) -> int:\n    if num < 2:\n        return 2\n    for i in range(num+1, num*2):\n        if all(i % j != 0 for j in range(2, int(i**0.5) + 1)):\n            return i\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int, divisor=5) -> bool:\n    return n % divisor == 0",
        "solution_func": "def g(n=3, divisor=5) -> int:\n    return n * divisor",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(n: int, divisor=5) that checks if n is divisible by a given divisor, and a function g(n=3, divisor=5) that multiplies n by the divisor, the puzzle requires finding a value of n such that f(g(n)) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how the functions f and g interact to satisfy the condition f(g()) == True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6126171946525574,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]\n\ndef g(s = \"A man, a plan, a canal, Panama!\"):\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str + cleaned_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]",
        "solution_func": "def g(s = \"A man, a plan, a canal, Panama!\"):\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str + cleaned_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given string is a palindrome after removing non-alphanumeric characters, and g generates a modified string by concatenating the cleaned string with its reverse. The assertion checks if the solution function g satisfies the condition of the puzzle function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4459346532821655,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\n\ndef f(intervals: List[Tuple[int, int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True\n\ndef g(intervals = [(1, 3), (2, 5), (6, 8), (9, 10), (8, 11)]):\n    intervals.sort(key=lambda x: x[0])\n    non_overlapping = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= non_overlapping[-1][1]:\n            non_overlapping.append(intervals[i])\n    return non_overlapping\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of intervals and checking for overlapping intervals. It also includes list manipulation and conditional logic.",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Tuple\n\ndef f(intervals: List[Tuple[int, int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True",
        "solution_func": "def g(intervals = [(1, 3), (2, 5), (6, 8), (9, 10), (8, 11)]):\n    intervals.sort(key=lambda x: x[0])\n    non_overlapping = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= non_overlapping[-1][1]:\n            non_overlapping.append(intervals[i])\n    return non_overlapping",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of intervals are non-overlapping or not. The function f checks if the intervals are non-overlapping, and the function g generates a list of non-overlapping intervals from a given list of intervals."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting and comparing intervals to determine if they are non-overlapping. The solution function g generates a list of non-overlapping intervals by iterating through the sorted intervals list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3562667965888977,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(decoded_message: str, key=42) -> bool:\n    encoded_message = ''.join(chr(ord(char) ^ key) for char in decoded_message)\n    return decoded_message == ''.join(chr(ord(char) ^ key) for char in encoded_message)\n\ndef g(key=42) -> str:\n    decoded_message = \"Hello, World!\"\n    return ''.join(chr(ord(char) ^ key) for char in decoded_message)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves String Manipulation, Binary Operations, and Conditional Logic.",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(decoded_message: str, key=42) -> bool:\n    encoded_message = ''.join(chr(ord(char) ^ key) for char in decoded_message)\n    return decoded_message == ''.join(chr(ord(char) ^ key) for char in encoded_message)",
        "solution_func": "def g(key=42) -> str:\n    decoded_message = \"Hello, World!\"\n    return ''.join(chr(ord(char) ^ key) for char in decoded_message)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves decoding and encoding a message using a key, and the challenge is to determine if the decoded message matches the original message after encoding and decoding."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of bitwise XOR operation and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4759672284126282,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(rotated_point: tuple, center=(0, 0), angle=45, region_radius=5) -> bool:\n    x, y = rotated_point\n    rotated_x = (x - center[0]) * math.cos(math.radians(angle)) - (y - center[1]) * math.sin(math.radians(angle)) + center[0]\n    rotated_y = (x - center[0]) * math.sin(math.radians(angle)) + (y - center[1]) * math.cos(math.radians(angle)) + center[1]\n    return math.sqrt(rotated_x ** 2 + rotated_y ** 2) <= region_radius\n\ndef g(center=(0, 0), angle=45, region_radius=5) -> tuple:\n    point = (3, 4)\n    return ((point[0] - center[0]) * math.cos(math.radians(angle)) - (point[1] - center[1]) * math.sin(math.radians(angle)) + center[0],\n            (point[0] - center[0]) * math.sin(math.radians(angle)) + (point[1] - center[1]) * math.cos(math.radians(angle)) + center[1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "Geometry and Coordinate Manipulation",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g()) == True"
        ],
        "problem_func": "import math\n\ndef f(rotated_point: tuple, center=(0, 0), angle=45, region_radius=5) -> bool:\n    x, y = rotated_point\n    rotated_x = (x - center[0]) * math.cos(math.radians(angle)) - (y - center[1]) * math.sin(math.radians(angle)) + center[0]\n    rotated_y = (x - center[0]) * math.sin(math.radians(angle)) + (y - center[1]) * math.cos(math.radians(angle)) + center[1]\n    return math.sqrt(rotated_x ** 2 + rotated_y ** 2) <= region_radius",
        "solution_func": "def g(center=(0, 0), angle=45, region_radius=5) -> tuple:\n    point = (3, 4)\n    return ((point[0] - center[0]) * math.cos(math.radians(angle)) - (point[1] - center[1]) * math.sin(math.radians(angle)) + center[0],\n            (point[0] - center[0]) * math.sin(math.radians(angle)) + (point[1] - center[1]) * math.cos(math.radians(angle)) + center[1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves rotating a point around a center by a given angle and checking if the rotated point falls within a specified region radius."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of basic geometry concepts such as rotation and distance calculation using trigonometric functions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4534718990325928,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves generating a random list of numbers and checking if all numbers in the list are unique.",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(n=3):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"()\"]\n    \n    result = set()\n    for i in range(n):\n        for inside in g(i):\n            for outside in g(n - 1 - i):\n                result.add(\"(\" + inside + \")\" + outside)\n    \n    return result\n\nassert f(g()) == True\n",
            "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))",
        "solution_func": "def g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of random numbers within a specified range and length, and checking if all the numbers in the list are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of generating random numbers in Python and checking for uniqueness in a list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45727214217185974,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    num = 0\n    while True:\n        num += 1\n        if str(num) == str(num)[::-1]:\n            return str(num)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\ndef f(max_sum: int, arr=[3, 2, 7, 10, 5]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(arr=[3, 2, 7, 10, 5]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    num = 0\n    while True:\n        num += 1\n        if str(num) == str(num)[::-1]:\n            return str(num)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given number is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that checks if a given string is a palindrome. The solution function g() iterates through numbers to find the smallest palindrome number and returns it.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6434903740882874,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(password: str) -> bool:\n    import re\n\n    # Criteria: At least 8 characters, 1 uppercase, 1 lowercase, 1 digit, and 1 special character\n    if len(password) < 8:\n        return False\n    \n    if not re.search(r\"[A-Z]\", password):\n        return False\n\n    if not re.search(r\"[a-z]\", password):\n        return False\n\n    if not re.search(r\"\\d\", password):\n        return False\n\n    if not re.search(r\"[!@#$%^&*]\", password):\n        return False\n\n    return True\n\ndef g():\n    import random\n    import string\n\n    characters = string.ascii_letters + string.digits + string.punctuation\n    password = ''.join(random.choices(characters, k=random.randint(8, 12)))\n    return password\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Importing Modules (Itertools, etc.), Randomization",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(password: str) -> bool:\n    import re\n\n    # Criteria: At least 8 characters, 1 uppercase, 1 lowercase, 1 digit, and 1 special character\n    if len(password) < 8:\n        return False\n    \n    if not re.search(r\"[A-Z]\", password):\n        return False\n\n    if not re.search(r\"[a-z]\", password):\n        return False\n\n    if not re.search(r\"\\d\", password):\n        return False\n\n    if not re.search(r\"[!@#$%^&*]\", password):\n        return False\n\n    return True",
        "solution_func": "def g():\n    import random\n    import string\n\n    characters = string.ascii_letters + string.digits + string.punctuation\n    password = ''.join(random.choices(characters, k=random.randint(8, 12)))\n    return password",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a random password and check if it meets specific criteria such as length, uppercase, lowercase, digit, and special character requirements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random password and validating it against specific criteria using regular expressions. It tests the student's understanding of string manipulation, random generation, and regular expressions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3065750002861023,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]\n\ndef g():\n    import random\n    import string\n\n    def generate_palindrome(length):\n        letters = string.ascii_lowercase\n        half_length = length // 2\n        palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n        return palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[:-1][::-1])\n\n    return generate_palindrome(random.randint(5, 10))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    def generate_palindrome(length):\n        letters = string.ascii_lowercase\n        half_length = length // 2\n        palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n        return palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[:-1][::-1])\n\n    return generate_palindrome(random.randint(5, 10))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(text: str) that checks if a given text is a palindrome after removing non-alphanumeric characters, and a function g() that generates a random palindrome string. The assert statement checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and random string generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3987424373626709,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of numbers forms an arithmetic sequence with a common difference. It also includes generating random sequences to test the function. The topics used in this puzzle are: List Operations, Random Number Generation, Arithmetic Operations, and Looping.",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(nums: List[int]) -> bool and g(), where f checks if a list of numbers forms an arithmetic sequence and g generates a random arithmetic sequence to be checked by f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated arithmetic sequence is correctly identified by the function f as an arithmetic sequence. This can be a good exercise to test understanding of list manipulation and conditional statements in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5564149618148804,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(combinations: list, pattern='ABCD') -> bool:\n    return any(pattern in combo for combo in combinations)\n\ndef g(elements: list = ['A', 'B', 'C', 'D']) -> list:\n    combos = []\n    for r in range(1, len(elements) + 1):\n        for combo in itertools.combinations(elements, r):\n            combos.append(''.join(combo))\n    return combos\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, importing modules (Itertools), and permutations and combinations.",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(combinations: list, pattern='ABCD') -> bool:\n    return any(pattern in combo for combo in combinations)",
        "solution_func": "def g(elements: list = ['A', 'B', 'C', 'D']) -> list:\n    combos = []\n    for r in range(1, len(elements) + 1):\n        for combo in itertools.combinations(elements, r):\n            combos.append(''.join(combo))\n    return combos",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all possible combinations of a given list of elements and checking if a specific pattern is present in any of the combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate combinations using itertools in Python and how to check for a specific pattern within those combinations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.3891313374042511,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (factors, primes, etc.) as it checks if a given number is a prime number or not.",
        "idx_generation": 21,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    return [3, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=17):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number or not, and a function g(num) that returns a specific number (default is 17). The puzzle requires g to be modified to return a prime number for the assertion to pass."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python. Students need to modify the g function to return a prime number in order to satisfy the assertion in the puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6293407678604126,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s='radar'):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 21,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    return [3, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s='radar'):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given string is a palindrome. The function g returns a default string 'radar'. The assert statement checks if the function f applied to the output of function g returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6701708436012268,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking is used in the solution to generate a valid permutation of numbers. Set Operations are used in the puzzle to check if the input permutation is a valid set of numbers. Conditional Logic is used in both the puzzle and the solution to implement certain conditions. Permutations and Combinations are used in the puzzle to generate permutations of numbers.",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))",
        "solution_func": "def g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given permutation of numbers satisfies a specific condition, and providing a solution to generate such a permutation."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating a permutation of numbers where each number is within a specific range and has a difference of more than 1 with its adjacent numbers. The solution uses backtracking to generate such a permutation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3309667706489563,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves graph theory and topological sorting to check if a given set of tasks can be completed in a specific order. It also includes concepts of graph traversal and handling dependencies between tasks.",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)",
        "solution_func": "def g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function that checks if a list of tasks can be completed in a specific order based on their dependencies. The function creates a graph of tasks and their dependencies, then checks if the tasks can be completed in a valid order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding graph data structures, topological sorting, and handling dependencies between tasks. The solution function provides a list of tasks with dependencies to test the algorithm.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3093614876270294,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s='racecar'):\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s='racecar'):\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not. The function f(s) returns True if the input string is a palindrome, and the function g(s) reverses the input string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes and understanding string manipulation in Python. It is a suitable puzzle for teaching Python programming concepts like string manipulation and function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5672071576118469,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\nimport string\n\ndef f(s: str) -> bool:\n    return len(set(s)) == len(s)\n\ndef g(length=5):\n    return ''.join(random.sample(string.ascii_lowercase, k=length))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\nimport string\n\ndef f(s: str) -> bool:\n    return len(set(s)) == len(s)",
        "solution_func": "def g(length=5):\n    return ''.join(random.sample(string.ascii_lowercase, k=length))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a random string of a specified length and checking if all characters in the string are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the set data structure to check for uniqueness of characters in a string and generating random strings using the random and string modules in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4793437719345093,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Exception Handling, Importing Modules (Itertools, etc.), Randomization",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False",
        "solution_func": "def g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is within a specific range and even. Another function g() generates a random number within a range and ensures it is even. The puzzle requires g() to generate a number that satisfies the conditions of f(num) to return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves error handling and random number generation to test conditions. It can be used to teach concepts like function definition, error handling, conditional statements, and random number generation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6282289028167725,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_sum: int, numbers=[4, 1, 1, 4, 2]) -> bool:\n    if not numbers:\n        return max_sum == 0\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max_sum == max(incl, excl)\n\ndef g(numbers=[4, 1, 1, 4, 2]):\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_sum: int, numbers=[4, 1, 1, 4, 2]) -> bool:\n    if not numbers:\n        return max_sum == 0\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max_sum == max(incl, excl)",
        "solution_func": "def g(numbers=[4, 1, 1, 4, 2]):\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if a certain condition is met based on a given list of numbers and a maximum sum, and g calculates the maximum sum of a given list of numbers. The puzzle requires understanding of dynamic programming concepts."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of how to calculate the maximum sum of a list of numbers. The solution function g calculates the maximum sum of the input list of numbers, and the puzzle function f checks if the calculated maximum sum meets a given condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.43974122405052185,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sorted_strings: List[str], strings=['apple', 'banana', 'kiwi', 'orange', 'pear']) -> bool:\n    return sorted_strings == sorted(strings, key=lambda x: (len(x), x))\n\ndef g(strings=['apple', 'banana', 'kiwi', 'orange', 'pear']):\n    return sorted(strings, key=lambda x: (len(x), x))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of strings based on length and lexicographical order. It demonstrates the use of lambda functions and sorting algorithms in Python.",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sorted_strings: List[str], strings=['apple', 'banana', 'kiwi', 'orange', 'pear']) -> bool:\n    return sorted_strings == sorted(strings, key=lambda x: (len(x), x))",
        "solution_func": "def g(strings=['apple', 'banana', 'kiwi', 'orange', 'pear']):\n    return sorted(strings, key=lambda x: (len(x), x))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function that sorts a list of strings based on their length and lexicographical order, and then check if the sorted list matches a predefined list of strings."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to sort a list of strings using a custom key function and comparing the sorted list with a predefined list to check for correctness.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.48777997493743896,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(nums: list, threshold=10) -> bool:\n    max_diff = max(nums) - min(nums)\n    return max_diff > threshold\n\ndef g(size: int = 10) -> list:\n    return [random.randint(1, 100) for _ in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and importing modules (random).",
        "idx_generation": 22,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "import random\n\ndef f(nums: list, threshold=10) -> bool:\n    max_diff = max(nums) - min(nums)\n    return max_diff > threshold",
        "solution_func": "def g(size: int = 10) -> list:\n    return [random.randint(1, 100) for _ in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the difference between the maximum and minimum values in a list of numbers is greater than a threshold. Another function g generates a list of random numbers. The puzzle requires ensuring that f returns True when applied to the output of g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic concepts of list manipulation, random number generation, and function composition in Python. It can be used to test students' understanding of function definitions and comparisons in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5388103127479553,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result",
        "solution_func": "def g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that generates all permutations of a given list of numbers and checks if the generated permutations match a given result. The solution function g generates all permutations of [1, 2, 3] and checks if it satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and backtracking to generate permutations of a list of numbers. It also requires checking if the generated permutations match a given result list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44901740550994873,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty(board)\n        if not empty:\n            return True\n        row, col = empty\n        for num in range(1, 10):\n            if is_safe(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n        return False\n\n    def find_empty(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty(board)\n        if not empty:\n            return True\n        row, col = empty\n        for num in range(1, 10):\n            if is_safe(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n        return False\n\n    def find_empty(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver algorithm in Python using a recursive backtracking approach."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a backtracking algorithm. The function should check for the validity of numbers in rows, columns, and subgrids.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.42978912591934204,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def restore_ip_addresses(s):\n        def backtrack(start, path):\n            if len(path) == 4 and start == len(s):\n                result.append('.'.join(path))\n                return\n            if len(path) >= 4:\n                return\n            for size in range(1, 4):\n                if start + size > len(s):\n                    break\n                if size > 1 and s[start] == '0':\n                    continue\n                num = int(s[start:start + size])\n                if num <= 255:\n                    backtrack(start + size, path + [str(num)])\n\n        result = []\n        backtrack(0, [])\n        return result\n\n    return restore_ip_addresses(\"25525511135\") == result\n\ndef g():\n    return ['255.255.11.135', '255.255.111.35']\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(result: List[str]) -> bool:\n    def restore_ip_addresses(s):\n        def backtrack(start, path):\n            if len(path) == 4 and start == len(s):\n                result.append('.'.join(path))\n                return\n            if len(path) >= 4:\n                return\n            for size in range(1, 4):\n                if start + size > len(s):\n                    break\n                if size > 1 and s[start] == '0':\n                    continue\n                num = int(s[start:start + size])\n                if num <= 255:\n                    backtrack(start + size, path + [str(num)])\n\n        result = []\n        backtrack(0, [])\n        return result\n\n    return restore_ip_addresses(\"25525511135\") == result",
        "solution_func": "def g():\n    return ['255.255.11.135', '255.255.111.35']",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that generates all possible valid IP addresses from a given string of numbers, and the solution function returns a list of valid IP addresses. The puzzle checks if the solution function correctly generates the expected IP addresses."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves backtracking to generate all possible valid IP addresses from a given string of numbers. The solution function returns a list of valid IP addresses and the puzzle checks if the solution function correctly generates the expected IP addresses.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44408169388771057,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, target=42) -> bool:\n    return (result * 2) - target == 10\ndef g(target=42):\n    return (target + 10) // 2\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations and Conditional Logic.",
        "idx_generation": 22,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "def f(x: int, a=93252338) -> bool:\n    return -x == a\ndef g(a = 93252338):\n    return - a\nassert f(g()) == True",
            "from typing import List \ndef f(ans: List[List[int]], target=17) -> bool:\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 17):\n    return [[0, 2]] * target\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: int, target=42) -> bool:\n    return (result * 2) - target == 10",
        "solution_func": "def g(target=42):\n    return (target + 10) // 2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given result satisfies a specific mathematical condition, and a function g that calculates a value based on a target. The goal is to find a value for the target that makes f(g()) return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of basic arithmetic operations and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.7204306721687317,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import permutations\n\ndef f(strings: list[str]) -> bool:\n    return any(s == s[::-1] for s in map(''.join, permutations(strings)))\n\ndef g(strings=['abc', 'ba', 'c']):\n    return strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and permutations and combinations.",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import permutations\n\ndef f(strings: list[str]) -> bool:\n    return any(s == s[::-1] for s in map(''.join, permutations(strings)))",
        "solution_func": "def g(strings=['abc', 'ba', 'c']):\n    return strings",
        "quality": [
            null
        ],
        "description": [
            "Given a list of strings, the puzzle checks if there exists a string in the list that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if any string in the list is a palindrome by generating all permutations of the strings and checking if any of them are equal to their reverse.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5066063404083252,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves sorting an array, calculating the median, and comparing the medians of the original and sorted arrays.",
        "idx_generation": 23,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted",
        "solution_func": "def g(size: int = 100):\n    return np.random.randint(1, 100, size=size)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the median of a randomly generated array is the same as the median of the sorted array."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate random arrays using numpy, sort arrays, calculate the median, and compare values in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3352733552455902,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, matrix manipulation, and numpy library functions.",
        "idx_generation": 23,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)",
        "solution_func": "def g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random square matrix of a specified size, calculating the sum of eigenvalues and trace of the matrix, and checking if the sum of eigenvalues is close to the trace of the matrix."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of NumPy for matrix operations, eigenvalues, and trace of a matrix. It also involves checking for numerical closeness using np.isclose().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4209657609462738,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return set('abcdefghijklmnopqrstuvwxyz').issubset(set(text.lower()))\n\ndef g() -> str:\n    return 'abcdefghijklmnopqrstuvwxyz'\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "idx_generation": 23,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return set('abcdefghijklmnopqrstuvwxyz').issubset(set(text.lower()))",
        "solution_func": "def g() -> str:\n    return 'abcdefghijklmnopqrstuvwxyz'",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if all lowercase letters of the alphabet are present in a given text, and a function g that returns the string 'abcdefghijklmnopqrstuvwxyz'. The puzzle tests whether function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets, string manipulation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.48231813311576843,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \n\ndef f(sorted_list: List[int]) -> bool:\n    return sorted_list == sorted(list(range(1000)) + list(range(1000, 2000)))\n\ndef g() -> List[int]:\n    return list(range(1000)) + list(range(1000, 2000))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list and checking if it is equal to a specific sorted list. It also involves generating a list using range function. The topics used in this puzzle are: Sorting and Ordering, List Operations, Mathematical Operations.",
        "idx_generation": 23,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List \n\ndef f(sorted_list: List[int]) -> bool:\n    return sorted_list == sorted(list(range(1000)) + list(range(1000, 2000)))",
        "solution_func": "def g() -> List[int]:\n    return list(range(1000)) + list(range(1000, 2000))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that checks if a given list of integers is equal to a specific sorted list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of integers and comparing it to a predefined sorted list of integers. The solution function generates the predefined sorted list of integers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4988204836845398,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\n\ndef f(sorted_tuples: List[Tuple[int, str]], tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> bool:\n    return sorted_tuples == sorted(tuples, key=lambda x: (x[1], -x[0]))\n\ndef g(tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> List[Tuple[int, str]]:\n    return sorted(tuples, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\nimport math\n\ndef f(distance: float, point1=(0, 0), point2=(3, 4)) -> bool:\n    return math.isclose(distance, math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2))\n\ndef g(point1=(0, 0), point2=(3, 4)) -> float:\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Tuple\n\ndef f(sorted_tuples: List[Tuple[int, str]], tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> bool:\n    return sorted_tuples == sorted(tuples, key=lambda x: (x[1], -x[0]))",
        "solution_func": "def g(tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> List[Tuple[int, str]]:\n    return sorted(tuples, key=lambda x: (x[1], -x[0]))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of tuples based on the second element in ascending order and the first element in descending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of sorting lists of tuples using custom sorting criteria in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5001358389854431,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def check_condition(perm):\n        # Define your condition here\n        return True\n\n    for perm in permutations(nums):\n        if check_condition(perm):\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves permutations and combinations to solve a condition.",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def check_condition(perm):\n        # Define your condition here\n        return True\n\n    for perm in permutations(nums):\n        if check_condition(perm):\n            return True\n    return False",
        "solution_func": "def g():\n    return [1, 2, 3]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a permutation of a given list of numbers that satisfies a certain condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using permutations and a condition check function to find a valid permutation of a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4633602499961853,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(sorted_list: List[int], values=[3, 7, 1, 9, 4, 2, 6, 5, 8]) -> bool:\n    return sorted_list == sorted(values)\ndef g(values=[3, 7, 1, 9, 4, 2, 6, 5, 8]):\n    return sorted(values)\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of integers and checking if it is equal to a predefined sorted list. This involves concepts of sorting and list manipulation.",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(sorted_list: List[int], values=[3, 7, 1, 9, 4, 2, 6, 5, 8]) -> bool:\n    return sorted_list == sorted(values)",
        "solution_func": "def g(values=[3, 7, 1, 9, 4, 2, 6, 5, 8]):\n    return sorted(values)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that checks if a given list is sorted in ascending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves comparing a sorted list with a predefined list to check if they are equal. The solution function returns the sorted version of the predefined list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5844155550003052,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport numpy as np\n\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g(size: int = 10) -> list:\n    return np.random.randint(1, 10, size=size).tolist()\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for duplicate elements in a list using set operations and random number generation using numpy.",
        "idx_generation": 23,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import numpy as np\n\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))",
        "solution_func": "def g(size: int = 10) -> list:\n    return np.random.randint(1, 10, size=size).tolist()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of random numbers and checking if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate a list of random numbers using numpy and check for duplicates in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.49646270275115967,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: set[int]) -> bool:\n    A = {1, 2, 3, 4, 5}\n    B = {3, 4, 5, 6, 7}\n    return intersection == A.intersection(B)\n\ndef g():\n    return {3, 4, 5}\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations to find the intersection of two sets and compare it with a given set. It also includes assertion testing for correctness.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(intersection: set[int]) -> bool:\n    A = {1, 2, 3, 4, 5}\n    B = {3, 4, 5, 6, 7}\n    return intersection == A.intersection(B)",
        "solution_func": "def g():\n    return {3, 4, 5}",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a set as input and checks if the input set is the intersection of two predefined sets A and B. The solution function g returns a specific set, and the puzzle is solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets and set operations in Python, specifically the intersection operation. It also requires implementing a function that compares sets and returns a boolean value based on the comparison.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5700562596321106,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(prob: float) -> bool:\n    return prob == 3/8  # Probability of getting exactly 2 heads when flipping a fair coin 3 times\n\ndef g():\n    outcomes = list(itertools.product(['H', 'T'], repeat=3))\n    favorable_outcomes = [outcome.count('H') for outcome in outcomes].count(2)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Probability and Statistics, Importing Modules (Itertools), List Operations, and Assertion Testing.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(prob: float) -> bool:\n    return prob == 3/8  # Probability of getting exactly 2 heads when flipping a fair coin 3 times",
        "solution_func": "def g():\n    outcomes = list(itertools.product(['H', 'T'], repeat=3))\n    favorable_outcomes = [outcome.count('H') for outcome in outcomes].count(2)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the probability of getting exactly 2 heads when flipping a fair coin 3 times and checking if the calculated probability matches a predefined value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of probability calculations and the use of itertools in Python to generate outcomes of coin flips.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5166144967079163,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the maximum product subarray. It also includes conditional logic and mathematical operations to update the maximum and minimum products. The solution function g() implements the same algorithm as f() to find the maximum product subarray.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product",
        "solution_func": "def g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum product of a subarray within a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming and handling negative numbers in the array.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.31958502531051636,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num_ways: int, message=\"123\") -> bool:\n    if len(message) == 0 or message[0] == '0':\n        return False\n\n    n = len(message)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(message[i - 1:i])\n        two_digits = int(message[i - 2:i])\n\n        if 1 <= one_digit <= 9:\n            dp[i] += dp[i - 1]\n\n        if 10 <= two_digits <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n] == num_ways\n\ndef g(message=\"123\"):\n    if len(message) == 0 or message[0] == '0':\n        return 0\n\n    n = len(message)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(message[i - 1:i])\n        two_digits = int(message[i - 2:i])\n\n        if 1 <= one_digit <= 9:\n            dp[i] += dp[i - 1]\n\n        if 10 <= two_digits <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, String Manipulation",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num_ways: int, message=\"123\") -> bool:\n    if len(message) == 0 or message[0] == '0':\n        return False\n\n    n = len(message)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(message[i - 1:i])\n        two_digits = int(message[i - 2:i])\n\n        if 1 <= one_digit <= 9:\n            dp[i] += dp[i - 1]\n\n        if 10 <= two_digits <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n] == num_ways",
        "solution_func": "def g(message=\"123\"):\n    if len(message) == 0 or message[0] == '0':\n        return 0\n\n    n = len(message)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if message[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(message[i - 1:i])\n        two_digits = int(message[i - 2:i])\n\n        if 1 <= one_digit <= 9:\n            dp[i] += dp[i - 1]\n\n        if 10 <= two_digits <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if a given number of ways can be achieved using a message encoded as numbers, and g calculates the number of ways to decode the message."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming to solve a decoding problem where a message is encoded as numbers. The functions f and g use similar logic to calculate the number of ways to decode the message, with f checking if a specific number of ways can be achieved.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4279385805130005,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(fib_list: list) -> bool:\n    product = 1\n    for num in fib_list:\n        product *= num\n    product_str = str(product)\n    return product_str == product_str[::-1]\n\ndef g(length: int = 10) -> list:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) < length:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and string manipulation.",
        "idx_generation": 24,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(fib_list: list) -> bool:\n    product = 1\n    for num in fib_list:\n        product *= num\n    product_str = str(product)\n    return product_str == product_str[::-1]",
        "solution_func": "def g(length: int = 10) -> list:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) < length:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the product of numbers in a Fibonacci sequence is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to generate a Fibonacci sequence and then check if the product of the numbers in the sequence is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45745691657066345,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]\n\ndef g(word=\"radar\"):\n    palindrome_word = word + word[::-1]\n    return palindrome_word\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to check if a given word is a palindrome. The solution generates a palindrome word based on the input word.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n\ndef g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]",
        "solution_func": "def g(word=\"radar\"):\n    palindrome_word = word + word[::-1]\n    return palindrome_word",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given text is a palindrome after removing non-alphanumeric characters, and a function g that generates a palindrome word based on a given word. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.47465038299560547,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n\ndef g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))",
        "solution_func": "def g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given matrix is symmetric along its diagonal, and a function g that generates a symmetric matrix based on a given size. The assertion checks if the function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding matrix symmetry and using list comprehension in Python to generate a symmetric matrix. The assertion tests the correctness of the solution function g by checking if the function f returns True for the generated matrix.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5127196907997131,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    def is_pythagorean_triplet(arr):\n        a, b, c = sorted(arr)\n        return a**2 + b**2 == c**2\n\n    return is_pythagorean_triplet(numbers)\n\ndef g():\n    def generate_pythagorean_triplet():\n        for a in range(1, 100):\n            for b in range(a, 100):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer():\n                    return [a, b, int(c)]\n        return []\n\n    return generate_pythagorean_triplet()\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [x for x in arr if x != 0]\n        return len(set(arr)) == len(arr)\n\n    def is_valid_sudoku(board):\n        for row in board:\n            if not is_valid(row):\n                return False\n        \n        for col in zip(*board):\n            if not is_valid(col):\n                return False\n        \n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        \n        return True\n\n    return is_valid_sudoku(board)\n\ndef g():\n    def solve_sudoku(board):\n        def is_valid_move(row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[start_row + i][start_col + j] == num:\n                        return False\n            return True\n\n        def solve():\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == 0:\n                        for num in range(1, 10):\n                            if is_valid_move(row, col, num):\n                                board[row][col] = num\n                                if solve():\n                                    return True\n                                board[row][col] = 0\n                        return False\n            return True\n\n        solve()\n        return board\n\n    return solve_sudoku([[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                         [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                         [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                         [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                         [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                         [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                         [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                         [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                         [0, 0, 0, 0, 8, 0, 0, 7, 9]])\n\nassert f(g()) == True\n",
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    def is_pythagorean_triplet(arr):\n        a, b, c = sorted(arr)\n        return a**2 + b**2 == c**2\n\n    return is_pythagorean_triplet(numbers)",
        "solution_func": "def g():\n    def generate_pythagorean_triplet():\n        for a in range(1, 100):\n            for b in range(a, 100):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer():\n                    return [a, b, int(c)]\n        return []\n\n    return generate_pythagorean_triplet()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers forms a Pythagorean triplet."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function to generate Pythagorean triplets and another function to check if a given list of numbers forms a Pythagorean triplet.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4861336648464203,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g(limit=10):\n    return [num for num in range(1, limit+1)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 24,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, prime=19) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(prime**0.5) + 1):\n        if prime % i == 0:\n            return False\n    return True\ndef g(n=5):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % prime != 0 for prime in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\nassert f(g()) == True\n",
            "\nfrom typing import List \ndef f(nums: List[int], has_prime=True) -> bool:\n    return any(num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)) for num in nums) == has_prime\ndef g(range_end=20):\n    return [num for num in range(2, range_end + 1) if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))]\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False",
        "solution_func": "def g(limit=10):\n    return [num for num in range(1, limit+1)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a Pythagorean triplet in a list of numbers using nested loops and checking if the sum of squares of two numbers is equal to the square of the third number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for Pythagorean triplets in a list of numbers using a specific algorithm. The solution generates a list of numbers up to a given limit and checks if there exists a Pythagorean triplet in that list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4282122254371643,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    return is_palindrome(string)\n\ndef g():\n    import random\n    import string\n\n    def generate_palindrome():\n        base = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n        return base + base[::-1]\n\n    return generate_palindrome()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic. The function f checks if a given string is a palindrome, and the function g generates a random palindrome string. The assert statement checks if the generated palindrome string is indeed a palindrome.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    return is_palindrome(string)",
        "solution_func": "def g():\n    import random\n    import string\n\n    def generate_palindrome():\n        base = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n        return base + base[::-1]\n\n    return generate_palindrome()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to check if a given string is a palindrome, and another function to generate a palindrome string. The goal is to ensure that the generated palindrome string is correctly identified as a palindrome by the checking function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, and function definition in Python. It provides a practical exercise to test understanding of these concepts.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4685025215148926,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(tree: TreeNode) -> bool:\n    def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n\n        if not (min_val < node.val < max_val):\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(tree)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion, conditional logic, and binary operations.",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(tree: TreeNode) -> bool:\n    def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n\n        if not (min_val < node.val < max_val):\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(tree)",
        "solution_func": "def g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given binary tree is a valid binary search tree (BST) or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(tree: TreeNode) -> bool that checks if the given binary tree is a valid BST. The solution function g() creates a binary tree with values 1, 2, and 3, and asserts that f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.35151398181915283,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Sorting and Ordering, Binary Operations, Mathematical Operations",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\n\ndef f(sorted_tuples: List[Tuple[int, str]], tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> bool:\n    return sorted_tuples == sorted(tuples, key=lambda x: (x[1], -x[0]))\n\ndef g(tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> List[Tuple[int, str]]:\n    return sorted(tuples, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left",
        "solution_func": "def g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the kth smallest element in a matrix using binary search and comparing it with a sorted version of the matrix."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f(kth_smallest, matrix, k) uses binary search to find the kth smallest element in the matrix and compares it with the result of function g(matrix, k) which returns the kth smallest element by sorting the matrix. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4988803267478943,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g(word=\"radar\") -> str:\n    return word + word[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return intersection == set1.intersection(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]",
        "solution_func": "def g(word=\"radar\") -> str:\n    return word + word[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome by comparing it to its reverse. The solution function constructs a palindrome by appending the reverse of the word starting from the second last character."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes and manipulating strings in Python. It is a suitable puzzle for teaching Python programming concepts related to string manipulation and conditionals.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.503283679485321,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation using regular expressions and conditional logic to check if a string is a palindrome. The solution simply returns a specific string. ",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "Given a string, the puzzle checks if the string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using regular expressions to remove non-alphanumeric characters, converting the string to lowercase, and checking if it is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4852609932422638,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves checking for duplicate elements in a list and generating a list with a specific pattern.",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n",
            "\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    return len(nums) != len(set(nums))",
        "solution_func": "def g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list contains duplicate elements, and a function g that generates a list with duplicate elements at the end. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list manipulation and checking for duplicates in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5930312275886536,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, is_prime=True) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True if is_prime else False\n\ndef g(start=10, end=100):\n    for num in range(start, end + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to prime numbers, mathematical operations, and conditional logic.",
        "idx_generation": 25,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int, is_prime=True) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True if is_prime else False",
        "solution_func": "def g(start=10, end=100):\n    for num in range(start, end + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num: int, is_prime=True) that checks if a given number is prime, and a function g(start=10, end=100) that finds the first prime number within a given range. The puzzle requires g to return a prime number and f to validate if the returned number is indeed prime."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, iteration, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5813016891479492,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, is_palindrome=True) -> bool:\n    return s == s[::-1]\n\ndef g(pattern='abc') -> str:\n    return pattern + pattern[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 25,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str, is_palindrome=True) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(pattern='abc') -> str:\n    return pattern + pattern[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome, and a function g that generates a string by concatenating a pattern with its reverse. The puzzle requires g to be passed to f to check if the generated string is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6022598147392273,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Permutations and Combinations as it uses itertools.combinations to generate all possible combinations of numbers from a given list. It also involves Mathematical Operations as it checks if the sum of the combination is equal to 10.",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "import itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10",
        "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a combination of numbers from a given list that adds up to 10 using itertools.combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using itertools.combinations to generate all possible combinations of numbers from a list and checking if the sum of any combination is equal to 10.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5031661987304688,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sorted_tuples: list) -> bool:\n    return sorted_tuples == sorted(sorted_tuples, key=lambda x: sum(x))\n\ndef g():\n    tuples_list = [(3, 4), (1, 5), (2, 6), (7, 2)]\n    return sorted(tuples_list, key=lambda x: sum(x))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of tuples based on the sum of elements in each tuple.",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "def f(sorted_tuples: list) -> bool:\n    return sorted_tuples == sorted(sorted_tuples, key=lambda x: sum(x))",
        "solution_func": "def g():\n    tuples_list = [(3, 4), (1, 5), (2, 6), (7, 2)]\n    return sorted(tuples_list, key=lambda x: sum(x))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of tuples based on the sum of their elements and checking if the sorted list is equal to the original list sorted in the same manner."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of sorting lists of tuples based on a specific key function in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5431313514709473,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(avg: float, lower_bound=2, upper_bound=8) -> bool:\n    return lower_bound <= avg <= upper_bound\n\ndef g():\n    import random\n    random.seed(1)\n    numbers = [random.randint(1, 10) for _ in range(5)]\n    avg = sum(numbers) / len(numbers)\n    return avg\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and importing modules (random).",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "def f(avg: float, lower_bound=2, upper_bound=8) -> bool:\n    return lower_bound <= avg <= upper_bound",
        "solution_func": "def g():\n    import random\n    random.seed(1)\n    numbers = [random.randint(1, 10) for _ in range(5)]\n    avg = sum(numbers) / len(numbers)\n    return avg",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a list of random numbers, calculate the average, and check if the average falls within a specified range."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating random numbers, calculating the average, and checking if the average is within a given range. The student needs to understand how to use random number generation and basic arithmetic operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45378348231315613,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and function calling in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.49652838706970215,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_product: int, numbers=[2, 5, 3, 7, 8, 4]) -> bool:\n    return max_product == max(numbers) * sorted(numbers)[-2]\n\ndef g(numbers=[2, 5, 3, 7, 8, 4]) -> int:\n    sorted_nums = sorted(numbers)\n    return sorted_nums[-1] * sorted_nums[-2]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and sorting and ordering topics.",
        "idx_generation": 26,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(sorted_list: List[int], values=[3, 7, 1, 9, 4, 2, 6, 5, 8]) -> bool:\n    return sorted_list == sorted(values)\ndef g(values=[3, 7, 1, 9, 4, 2, 6, 5, 8]):\n    return sorted(values)\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_product: int, numbers=[2, 5, 3, 7, 8, 4]) -> bool:\n    return max_product == max(numbers) * sorted(numbers)[-2]",
        "solution_func": "def g(numbers=[2, 5, 3, 7, 8, 4]) -> int:\n    sorted_nums = sorted(numbers)\n    return sorted_nums[-1] * sorted_nums[-2]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where f checks if the maximum product of a list of numbers is equal to the product of the two largest numbers in the list, and g calculates the product of the two largest numbers in the list. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the maximum product of a list of numbers and comparing it with the product of the two largest numbers in the list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.5975637435913086,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(min_coins: int, amount=11, coins=[1, 2, 5, 10]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5, 10]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 26,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(sorted_list: List[int], values=[3, 7, 1, 9, 4, 2, 6, 5, 8]) -> bool:\n    return sorted_list == sorted(values)\ndef g(values=[3, 7, 1, 9, 4, 2, 6, 5, 8]):\n    return sorted(values)\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(min_coins: int, amount=11, coins=[1, 2, 5, 10]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return min_coins == dp[amount]",
        "solution_func": "def g(amount=11, coins=[1, 2, 5, 10]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, f and g, where f checks if a given amount can be made using a specific set of coins with the minimum number of coins, and g calculates the minimum number of coins needed to make the given amount using the same set of coins."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of how to calculate the minimum number of coins needed to make a specific amount using a given set of coins. It also tests the implementation of the algorithm in both the f and g functions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4516145884990692,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    if num in rows[i] or num in cols[j] or num in boxes[(i // 3) * 3 + (j // 3)]:\n                        return False\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[(i // 3) * 3 + (j // 3)].add(num)\n        return True\n\n    return is_valid_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n        [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n        ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n        [8, '.', '.', '.', 6, '.', '.', '.', 3],\n        [4, '.', '.', 8, '.', 3, '.', '.', 1],\n        [7, '.', '.', '.', 2, '.', '.', '.', 6],\n        ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n        ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n        ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires understanding of data structures and algorithms related to board manipulation and validation.",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    if num in rows[i] or num in cols[j] or num in boxes[(i // 3) * 3 + (j // 3)]:\n                        return False\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[(i // 3) * 3 + (j // 3)].add(num)\n        return True\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n        [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n        ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n        [8, '.', '.', '.', 6, '.', '.', '.', 3],\n        [4, '.', '.', 8, '.', 3, '.', '.', 1],\n        [7, '.', '.', '.', 2, '.', '.', '.', 6],\n        ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n        ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n        ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function that checks the validity of a Sudoku board based on the rules of Sudoku. The solution function provides a sample 9x9 Sudoku board and asserts its validity using the implemented function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4164199233055115,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves sorting a list and checking if it is a sequence of consecutive numbers. It also includes exception handling. The topics used in this puzzle are: Sorting and Ordering, Exception Handling.",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False",
        "solution_func": "def g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement two functions: f(lst: list) -> bool, which checks if a given list is a consecutive sequence of numbers, and g() -> list, which generates a random list of consecutive numbers. The student needs to ensure that the generated list satisfies the condition of being a consecutive sequence of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, range generation, and comparison of lists. It also requires handling exceptions and ensuring the correctness of the generated list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49343550205230713,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(matrix: list) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix))])\n\ndef g() -> list:\n    import random\n    n = random.randint(2, 5)\n    matrix = [[random.randint(1, 5) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal. The solution generates a random symmetric matrix and checks if the function f returns True for it.",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(matrix: list) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix))])",
        "solution_func": "def g() -> list:\n    import random\n    n = random.randint(2, 5)\n    matrix = [[random.randint(1, 5) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(matrix) that checks if a given matrix is symmetric along its main diagonal. The solution function g() generates a random symmetric matrix and returns it. The assertion checks if the solution function g() satisfies the condition of the function f()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding matrix symmetry along the main diagonal and implementing a function to check for this property. The solution function generates random symmetric matrices to test the function. This puzzle can be used to teach Python programming concepts related to matrices and condition checking.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5472177267074585,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and pattern recognition.",
        "idx_generation": 27,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(nums: list, threshold=10) -> bool:\n    max_diff = max(nums) - min(nums)\n    return max_diff > threshold\n\ndef g(size: int = 10) -> list:\n    return [random.randint(1, 100) for _ in range(size)]\n\nassert f(g()) == True\n",
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))",
        "solution_func": "def g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(nums) and g(start, diff, size), where f checks if a list of numbers generated by g forms an arithmetic sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation, arithmetic sequences, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5115290284156799,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    word_length = random.randint(3, 8)\n    random_string = ''.join(random.choices(string.ascii_lowercase, k=word_length))\n    return random_string + random_string[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 27,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    word_length = random.randint(3, 8)\n    random_string = ''.join(random.choices(string.ascii_lowercase, k=word_length))\n    return random_string + random_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random string and its palindrome. The puzzle tests whether the generated string and its palindrome satisfy the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.38972118496894836,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using a brute force search algorithm.",
        "idx_generation": 27,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    num = random.randint(2, 100)\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g() that generates a random number between 2 and 100. The puzzle requires students to implement the f function correctly and ensure that it returns True when applied to a number generated by g()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to check for primality. It also requires students to work with random number generation in Python. This puzzle can be used to teach Python programming concepts related to functions, loops, conditionals, and random number generation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.55227130651474,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(words: list) -> bool:\n    return words == sorted(words)\n\ndef g(length=5) -> list:\n    import random\n    import string\n    words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) for _ in range(length)]\n    return sorted(words)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering topics.",
        "idx_generation": 27,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(words: list) -> bool:\n    return words == sorted(words)",
        "solution_func": "def g(length=5) -> list:\n    import random\n    import string\n    words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) for _ in range(length)]\n    return sorted(words)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that checks if a list of words is sorted alphabetically. The solution function generates a list of random words and sorts them before returning."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list sorting and comparison in Python. The solution function uses random generation and sorting to create a list of words that is then checked by the main function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.35984206199645996,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(string_length: int = 5) -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choice(letters) for _ in range(string_length))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 27,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(string_length: int = 5) -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choice(letters) for _ in range(string_length))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, and a function g(string_length) that generates a random palindrome string of a specified length, the puzzle requires finding a palindrome string of length 5 using function g that satisfies the palindrome check in function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate a palindrome string of a specific length and ensuring that the generated string is indeed a palindrome using the provided functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4480614960193634,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    try:\n        return len(nums) != len(set(nums))\n    except:\n        return False\n\ndef g() -> List[int]:\n    import random\n    length = random.randint(5, 10)\n    nums = [random.randint(1, 10) for _ in range(length)]\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, random number generation, exception handling, and set operations.",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], s='kibozekiboze', target='') -> bool:\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'kibozekiboze', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    try:\n        return len(nums) != len(set(nums))\n    except:\n        return False",
        "solution_func": "def g() -> List[int]:\n    import random\n    length = random.randint(5, 10)\n    nums = [random.randint(1, 10) for _ in range(length)]\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list of integers contains any duplicates, and a function g that generates a random list of integers. The goal is to determine if the generated list contains duplicates."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation, set operations, and exception handling in Python. It also requires them to generate random lists of integers using the random module.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4807813763618469,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s != s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + random.choice(letters) + random.choice(letters)\n    return palindrome + random.choice(letters)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g(size: int = 10) -> list:\n    return np.random.randint(1, 10, size=size).tolist()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s != s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + random.choice(letters) + random.choice(letters)\n    return palindrome + random.choice(letters)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is not a palindrome, and a function g() that generates a random string and ensures that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4682709574699402,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(text=\"racecar\"):\n    return [''.join(perm) for perm in itertools.permutations(text)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and permutations and combinations.",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(text=\"racecar\"):\n    return [''.join(perm) for perm in itertools.permutations(text)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if the input text is a palindrome by generating all permutations of the text and comparing each permutation to the original text."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given text is a palindrome using permutations. It demonstrates the use of itertools.permutations and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.34117552638053894,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(tree: TreeNode) -> bool:\n    def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n\n        if not (min_val < node.val < max_val):\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(tree)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'level'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6639651656150818,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    if result == 120:\n        return True\n    else:\n        return False\n\ndef g(number=5):\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and recursion.",
        "idx_generation": 28,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(li: List[int]) -> bool:\n    if len(li) < 2:\n        return True\n    diff = li[1] - li[0]\n    for i in range(2, len(li)):\n        if li[i] - li[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    n = random.randint(5, 10)\n    return [start + i * diff for i in range(n)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    if result == 120:\n        return True\n    else:\n        return False",
        "solution_func": "def g(number=5):\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a recursive function that calculates the factorial of a given number and returns True if the result is 120."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and factorial calculation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6524715423583984,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 199\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (factors, primes, etc.) as it checks if a given number is a prime number or not.",
        "idx_generation": 28,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 199",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(n) that checks if a given number is a prime number, and a function g() that returns the number 199. The puzzle requires g() to return a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of prime numbers and function calls in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.664394736289978,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g(input_str=\"radar\") -> str:\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(input_str=\"radar\") -> str:\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f that checks if a string is a palindrome and a function g that returns a string concatenated with its reverse, the puzzle requires verifying if the output of g is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5641260743141174,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size=5) -> list:\n    return [random.randint(1, 10) for _ in range(size)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for duplicates in a list of numbers generated randomly. It uses the set data structure to remove duplicates and compares the length of the original list with the length of the set to determine if there are duplicates present.",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))",
        "solution_func": "def g(size=5) -> list:\n    return [random.randint(1, 10) for _ in range(size)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to generate a list of random numbers and check if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check for duplicates in a list of numbers and generating a list of random numbers to test the function. The assertion checks if the function correctly identifies duplicates in the generated list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5203350782394409,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)",
        "solution_func": "def g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of permutations and checks if any of the permutations contain only odd numbers. The solution function g generates all permutations of a given list of odd numbers and returns them."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for valid permutations of odd numbers, which is a good exercise in understanding list manipulation and recursion in Python. It also introduces the concept of backtracking for generating permutations. This puzzle can be used to teach Python to master's students in CS as it covers important concepts like list manipulation, recursion, and backtracking.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.32037001848220825,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics as it checks for a uniform distribution of dice rolls.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)",
        "solution_func": "def g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of dice rolls contains all possible outcomes from rolling a fair six-sided die."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating a list of 100 random dice rolls and checking if all numbers from 1 to 6 are present in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.48854318261146545,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(shortest_path: int, grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1] == shortest_path\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\ndef f(sequence: list) -> bool:\n    return all(sequence[i] - sequence[i-1] == sequence[1] - sequence[0] for i in range(2, len(sequence)))\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(shortest_path: int, grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1] == shortest_path",
        "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a given shortest path is achievable in a grid using dynamic programming, and g calculates the minimum path sum in the same grid. The assertion at the end confirms that g is a solution to f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of grid traversal and path optimization. It can be used to teach Python programming and algorithmic thinking to master's students in CS.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.43611687421798706,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list) -> bool:\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                if arr[i]**2 + arr[j]**2 == arr[k]**2:\n                    return True\n    return False\n\ndef g(n: int = 5) -> list:\n    return list(range(1, n+1))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, brute force search, and conditional logic.",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n",
            "\ndef f(result: int) -> bool:\n    def factorial_recursive(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial_recursive(n - 1)\n    \n    return result == factorial_recursive(5)\n\ndef g():\n    return 120\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(arr: list) -> bool:\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                if arr[i]**2 + arr[j]**2 == arr[k]**2:\n                    return True\n    return False",
        "solution_func": "def g(n: int = 5) -> list:\n    return list(range(1, n+1))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exists a Pythagorean triplet (three numbers that satisfy the Pythagorean theorem) in a given list of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.489001989364624,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n",
            "\ndef f(result: int) -> bool:\n    def factorial_recursive(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial_recursive(n - 1)\n    \n    return result == factorial_recursive(5)\n\ndef g():\n    return 120\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"racecar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'racecar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6661233305931091,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(numbers=[1, 2, 3]):\n    def backtrack(path, nums):\n        if not nums:\n            permutations.append(path.copy())\n            return\n        \n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(path, nums[:i] + nums[i+1:])\n            path.pop()\n\n    permutations = []\n    backtrack([], numbers)\n    return permutations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Sorting and Ordering, Backtracking",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    if solve():\n        return True\n    return False\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "solution_func": "def g(numbers=[1, 2, 3]):\n    def backtrack(path, nums):\n        if not nums:\n            permutations.append(path.copy())\n            return\n        \n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(path, nums[:i] + nums[i+1:])\n            path.pop()\n\n    permutations = []\n    backtrack([], numbers)\n    return permutations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all permutations of a given list of numbers and checking if the generated permutations match a specific set of predefined permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion, backtracking, and list manipulation in Python to generate all possible permutations of a list of numbers and compare them to a predefined set of permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.32705456018447876,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a given string is a palindrome.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6713926792144775,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1] + 1:\n            return False\n    return True\n\ndef g():\n    return [3, 4, 5, 6, 7]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1] + 1:\n            return False\n    return True",
        "solution_func": "def g():\n    return [3, 4, 5, 6, 7]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(nums: list) that checks if a list of numbers is consecutive. The function g() returns a list of consecutive numbers, and the assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of numbers and checking if each element is consecutive. The solution function g() returns a list of consecutive numbers, satisfying the condition of function f(nums: list).",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.602681040763855,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for num in nums:\n        if is_prime(num):\n            return True\n    return False\n\ndef g():\n    return [4, 9, 7, 12, 15]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking for prime numbers in a list of integers.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, -1]\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size: int = 10):\n    return [i for i in range(size)] + [size - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for num in nums:\n        if is_prime(num):\n            return True\n    return False",
        "solution_func": "def g():\n    return [4, 9, 7, 12, 15]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(nums: list) that checks if any number in the input list is a prime number. The solution function g() returns a list of numbers, and the puzzle is solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for prime numbers in a list of numbers using a nested function for prime number checking. The solution function returns a list of numbers to test the prime number checking function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5959212779998779,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization, List Operations",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int, numbers=[4, 1, 1, 4, 2]) -> bool:\n    if not numbers:\n        return max_sum == 0\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max_sum == max(incl, excl)\n\ndef g(numbers=[4, 1, 1, 4, 2]):\n    incl = 0\n    excl = 0\n    for num in numbers:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6",
        "solution_func": "def g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it equals 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f checks if the longest subsequence length is 6, and the function g calculates the length of the longest increasing subsequence in the given list of numbers. The assert statement checks if the solution g satisfies the condition of f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4991321861743927,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return len(set(s)) == len(s)\n\ndef g(length=10) -> str:\n    import string\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.sample(chars, length))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return len(set(s)) == len(s)",
        "solution_func": "def g(length=10) -> str:\n    import string\n    import random\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.sample(chars, length))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a random string of a specified length and check if all characters in the string are unique."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, random generation, and set operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4220118820667267,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list) -> bool:\n    return arr == sorted(arr)\n\ndef g(length=5) -> list:\n    import random\n    return sorted(random.sample(range(1, 20), length))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of numbers and generating a random list of numbers. It also includes the use of the `random` module in Python. The solution checks if the generated list is sorted or not.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(arr: list) -> bool:\n    return arr == sorted(arr)",
        "solution_func": "def g(length=5) -> list:\n    import random\n    return sorted(random.sample(range(1, 20), length))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that generates a list of random numbers and checks if the list is sorted in ascending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, sorting, and comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.608576774597168,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(email: str) -> bool:\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return bool(re.match(pattern, email))\n\ndef g() -> str:\n    import random\n    import string\n    domains = ['.com', '.net', '.org']\n    email = ''.join(random.choices(string.ascii_letters + string.digits, k=8)) + '@' + ''.join(random.choices(string.ascii_lowercase, k=5)) + random.choice(domains)\n    return email\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, importing modules (re, random, string), and conditional logic.",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "import re\n\ndef f(email: str) -> bool:\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return bool(re.match(pattern, email))",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    domains = ['.com', '.net', '.org']\n    email = ''.join(random.choices(string.ascii_letters + string.digits, k=8)) + '@' + ''.join(random.choices(string.ascii_lowercase, k=5)) + random.choice(domains)\n    return email",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given email address is valid based on a regular expression pattern. The solution function g generates a random email address and the puzzle is to ensure that f returns True when applied to the output of g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the students' understanding of regular expressions and string manipulation in Python. It also requires them to understand how to generate random strings using the random module. The solution function g generates a random email address and the puzzle is to ensure that the function f correctly validates this email address.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.42460569739341736,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, pattern='ABAB') -> bool:\n    return s == pattern\n\ndef g(pattern='ABAB'):\n    s = ''\n    for i in range(4):\n        s += chr(65 + i % 2)\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    return n // b == a\ndef g(a = -3411193412414137, b = -9070455318026063):\n    return a * b\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, pattern='ABAB') -> bool:\n    return s == pattern",
        "solution_func": "def g(pattern='ABAB'):\n    s = ''\n    for i in range(4):\n        s += chr(65 + i % 2)\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f and g, where f checks if a given string matches a specific pattern and g generates a string based on a predefined pattern. The puzzle tests whether the generated string satisfies the pattern check function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding function definitions, string manipulation, and function invocation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6218051314353943,
        "judgeLM-7b-abs_finetuning": 7.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(words: List[str], palindrome='racecar') -> bool:\n    combined = ''.join(words)\n    return combined == combined[::-1]\ndef g(palindrome='racecar'):\n    return [char for char in palindrome]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(words: List[str], palindrome='racecar') -> bool:\n    combined = ''.join(words)\n    return combined == combined[::-1]",
        "solution_func": "def g(palindrome='racecar'):\n    return [char for char in palindrome]",
        "quality": [
            null
        ],
        "description": [
            "Given a list of words, the puzzle checks if the combined words form a palindrome. The solution function creates a list of characters from a predefined palindrome and checks if it forms a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a combined list of words forms a palindrome. The solution function creates a list of characters from a predefined palindrome and checks if it forms a palindrome. This puzzle can be used to teach Python programming concepts related to string manipulation and list comprehension.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5139517784118652,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(matrix: List[List[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(i, len(matrix)))\ndef g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal. This requires understanding of matrix operations and nested loops.",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(matrix: List[List[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(i, len(matrix)))",
        "solution_func": "def g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given matrix is symmetric along its main diagonal, and a function g that returns a specific matrix. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list comprehension, matrix indexing, and the all() function in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5653235912322998,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, limit=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    return sum(primes) == result\n\ndef g(limit=10):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    return sum(primes)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking for prime numbers, generating a list of prime numbers, and summing them up to check if the sum equals a given result. It also includes function composition and assertion testing.",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    return prob == 3/8  # Probability of getting exactly 2 heads when flipping a fair coin 3 times\n\ndef g():\n    outcomes = list(itertools.product(['H', 'T'], repeat=3))\n    favorable_outcomes = [outcome.count('H') for outcome in outcomes].count(2)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int, limit=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    return sum(primes) == result",
        "solution_func": "def g(limit=10):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    return sum(primes)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if the sum of prime numbers up to a given limit is equal to a specified result, and the second function calculates the sum of prime numbers up to a given limit. The puzzle requires the second function to be a solution to the first function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of functions, loops, conditionals, list comprehension, and prime number checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4822160303592682,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics concepts such as combinations and probability calculations.",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    return prob == 3/8  # Probability of getting exactly 2 heads when flipping a fair coin 3 times\n\ndef g():\n    outcomes = list(itertools.product(['H', 'T'], repeat=3))\n    favorable_outcomes = [outcome.count('H') for outcome in outcomes].count(2)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob",
        "solution_func": "def g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the probability of drawing a red ball from a bag of balls and checking if the calculated probability matches the expected probability."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of probability calculations using combinations and factorial functions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5367977023124695,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]\n\ndef g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Mathematical Operations, Importing Modules (Itertools, etc.)",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]",
        "solution_func": "def g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of integers and checking if the middle element(s) satisfy a specific condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand list sorting, list indexing, and arithmetic operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4871310591697693,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: set) -> bool:\n    return any(intersection)\n\ndef g() -> set:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to find the intersection of two sets and then check if the intersection is not empty. This relates to topics such as Set Operations and Conditional Logic.",
        "idx_generation": 31,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(intersection: set) -> bool:\n    return any(intersection)",
        "solution_func": "def g() -> set:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if any element is present in the intersection of two sets, and a function g that returns the intersection of two predefined sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is suitable for teaching Python to master's students in CS as it involves working with sets, intersections, and boolean checks.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6076035499572754,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import permutations\n\ndef f(permutation: tuple) -> bool:\n    pattern = ('a', 'b', 'c')\n    for perm in permutation:\n        if any(perm[i:i+3] == pattern for i in range(len(perm) - 2)):\n            return True\n    return False\n\ndef g() -> tuple:\n    word = 'abcde'\n    return permutations(word)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and importing modules (Itertools). It also involves pattern recognition and iteration over permutations.",
        "idx_generation": 31,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import permutations\n\ndef f(permutation: tuple) -> bool:\n    pattern = ('a', 'b', 'c')\n    for perm in permutation:\n        if any(perm[i:i+3] == pattern for i in range(len(perm) - 2)):\n            return True\n    return False",
        "solution_func": "def g() -> tuple:\n    word = 'abcde'\n    return permutations(word)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all permutations of a given word and checking if any of the permutations contain a specific pattern of characters."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of permutations, iteration, and pattern matching in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3990214169025421,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport string\n\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return ''.join(char for char in s if char.isalnum())\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.), Pattern Recognition",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import string\n\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return ''.join(char for char in s if char.isalnum())",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing all non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that removes non-alphanumeric characters from a string, converts it to lowercase, and then checks if the resulting string is a palindrome.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.41786304116249084,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combination: List[int], target_sum=10) -> bool:\n    return sum(combination) == target_sum\n\ndef g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    for r in range(1, len(numbers) + 1):\n        for comb in combinations(numbers, r):\n            if sum(comb) == target_sum:\n                return list(comb)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Importing Modules (Itertools), Permutations and Combinations, and Conditional Logic.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import combinations\n\ndef f(combination: List[int], target_sum=10) -> bool:\n    return sum(combination) == target_sum",
        "solution_func": "def g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    for r in range(1, len(numbers) + 1):\n        for comb in combinations(numbers, r):\n            if sum(comb) == target_sum:\n                return list(comb)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a combination of numbers from a given list that adds up to a target sum of 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to use combinations from itertools to find the desired sum.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.48306748270988464,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the longest increasing subsequence in a list of numbers.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(queens: List[int]) -> bool:\n    n = len(queens)\n    for i in range(n):\n        for j in range(i+1, n):\n            if queens[i] == queens[j] or abs(queens[i] - queens[j]) == j - i:\n                return False\n    return True\n\ndef g(n=4):\n    def solve(queens):\n        if len(queens) == n:\n            return queens\n        for i in range(n):\n            if all(queens[j] != i and abs(queens[j] - i) != len(queens) - j for j in range(len(queens))):\n                temp = solve(queens + [i])\n                if temp:\n                    return temp\n        return []\n\n    return solve([])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))",
        "solution_func": "def g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given list of integers is in strictly increasing order, and a function g that finds the longest increasing subsequence in a list of integers. The solution function g returns the longest increasing subsequence of the input list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for a strictly increasing order in a list and finding the longest increasing subsequence using dynamic programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.42397212982177734,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    def generate_palindrome_string():\n        letters = string.ascii_lowercase\n        size = random.randint(3, 8)\n        half_size = size // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_size))\n        second_half = first_half + (random.choice(letters) if size % 2 != 0 else '') + first_half[::-1]\n        return second_half\n\n    return generate_palindrome_string()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization, Importing Modules",
        "idx_generation": 31,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\ndef f(num: int, is_prime=True) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True if is_prime else False\n\ndef g(start=10, end=100):\n    for num in range(start, end + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_palindrome(num) and is_prime(num)\n\ndef g():\n    import random\n\n    def generate_palindrome_prime():\n        def is_palindrome(n):\n            return str(n) == str(n)[::-1]\n        \n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(10, 1000)\n        while not is_palindrome(num) or not is_prime(num):\n            num = random.randint(10, 1000)\n        return num\n\n    return generate_palindrome_prime()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    def generate_palindrome_string():\n        letters = string.ascii_lowercase\n        size = random.randint(3, 8)\n        half_size = size // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_size))\n        second_half = first_half + (random.choice(letters) if size % 2 != 0 else '') + first_half[::-1]\n        return second_half\n\n    return generate_palindrome_string()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a given string is a palindrome and another function to generate a random palindrome string. The assertion at the end ensures that the generated string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4419991075992584,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    numbers.append(random.choice(numbers))  # introducing a duplicate\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves checking for duplicates in a list of numbers generated randomly.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))",
        "solution_func": "def g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    numbers.append(random.choice(numbers))  # introducing a duplicate\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of random numbers and checking if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate random numbers in Python, create a list with duplicates, and check for duplicates using set operations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4680592119693756,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(result: int) -> bool:\n    return result == 5  # Check if the nth Fibonacci number is 5\n\ndef g(n=5) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion to calculate the nth Fibonacci number and then checks if the result is equal to 5. It also involves mathematical operations and conditional logic.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int, div=5) -> bool:\n    return result % div == 0\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n",
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    return result == 5  # Check if the nth Fibonacci number is 5",
        "solution_func": "def g(n=5) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the nth Fibonacci number is equal to 5 using a recursive Fibonacci function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and Fibonacci sequence in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6255872845649719,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    target_sequence = list(range(1, len(nums) * 2, 2))\n    return all(num in nums for num in target_sequence)\n\ndef g() -> List[int]:\n    start = 1\n    step = 2\n    length = 5\n    return list(itertools.islice(itertools.count(start, step), length))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves importing modules (Itertools), list manipulation, and checking if a list contains a specific sequence of numbers.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    target_sequence = list(range(1, len(nums) * 2, 2))\n    return all(num in nums for num in target_sequence)",
        "solution_func": "def g() -> List[int]:\n    start = 1\n    step = 2\n    length = 5\n    return list(itertools.islice(itertools.count(start, step), length))",
        "quality": [
            null
        ],
        "description": [
            "Given a list of integers, the puzzle checks if the list contains all odd numbers starting from 1 up to twice the length of the list. The solution generates a list of odd numbers using itertools and checks if the puzzle function returns True for this list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a list contains a specific sequence of odd numbers. The solution generates this sequence using itertools and checks if the puzzle function returns True for it.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.445670485496521,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\nfrom typing import List, Tuple\ndef f(tuples: List[Tuple[int, str]]) -> bool:\n    target_pattern = [(1, 'A'), (2, 'B'), (3, 'C')]\n    return all(t in tuples for t in target_pattern)\n\ndef g() -> List[Tuple[int, str]]:\n    base_pattern = [(1, 'A'), (2, 'B'), (3, 'C')]\n    repetitions = 2\n    return list(itertools.chain.from_iterable(itertools.repeat(base_pattern, repetitions)))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves importing modules, list manipulation, and checking for a specific pattern in a list.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\nfrom typing import List, Tuple\ndef f(tuples: List[Tuple[int, str]]) -> bool:\n    target_pattern = [(1, 'A'), (2, 'B'), (3, 'C')]\n    return all(t in tuples for t in target_pattern)",
        "solution_func": "def g() -> List[Tuple[int, str]]:\n    base_pattern = [(1, 'A'), (2, 'B'), (3, 'C')]\n    repetitions = 2\n    return list(itertools.chain.from_iterable(itertools.repeat(base_pattern, repetitions)))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of tuples contains a specific target pattern. The solution generates a list of tuples by repeating a base pattern a certain number of times."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation and pattern matching in Python using itertools. The solution demonstrates how to generate a list by repeating a base pattern multiple times and then checking if the generated list contains a specific target pattern.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4469970762729645,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subset: List[int], target=10) -> bool:\n    def is_subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n - 1] > target:\n            return is_subset_sum(nums, n - 1, target)\n        return is_subset_sum(nums, n - 1, target) or is_subset_sum(nums, n - 1, target - nums[n - 1])\n\n    return is_subset_sum(subset, len(subset), target)\n\ndef g():\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Dynamic Programming",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\ndef f(sudoku: list) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku(sudoku)\n    return all(all(cell != 0 for cell in row) for row in sudoku)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subset: List[int], target=10) -> bool:\n    def is_subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n - 1] > target:\n            return is_subset_sum(nums, n - 1, target)\n        return is_subset_sum(nums, n - 1, target) or is_subset_sum(nums, n - 1, target - nums[n - 1])\n\n    return is_subset_sum(subset, len(subset), target)",
        "solution_func": "def g():\n    return [2, 4, 6, 8, 10, 12]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a subset of integers can sum up to a target value using recursion."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and subset sum problem in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4272582530975342,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Conditional Logic are used in the problem f and solution g.",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\ndef f(sudoku: list) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku(sudoku)\n    return all(all(cell != 0 for cell in row) for row in sudoku)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome after removing non-alphanumeric characters, find a string that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to check for palindromes and manipulate strings in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.46210622787475586,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Recursion, Binary Operations, Algorithm Optimization",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\ndef f(sudoku: list) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku(sudoku)\n    return all(all(cell != 0 for cell in row) for row in sudoku)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)",
        "solution_func": "def g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given binary tree is a Binary Search Tree (BST) or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(root: TreeNode) -> bool that checks if the given binary tree is a BST. The solution function g() creates a binary tree with values 1, 2, and 3, and asserts that the function f returns True for this tree.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3817894458770752,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    alphanumeric_s = ''.join(char.lower() for char in s if char.isalnum())\n    return alphanumeric_s == alphanumeric_s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    alphanumeric_chars = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(5, 10)))\n    return alphanumeric_chars + alphanumeric_chars[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.), Randomization",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(sorted_tuples: List[Tuple[int, str]], tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> bool:\n    return sorted_tuples == sorted(tuples, key=lambda x: (x[1], -x[0]))\n\ndef g(tuples=[(3, 'apple'), (1, 'banana'), (2, 'cherry')]) -> List[Tuple[int, str]]:\n    return sorted(tuples, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    alphanumeric_s = ''.join(char.lower() for char in s if char.isalnum())\n    return alphanumeric_s == alphanumeric_s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    alphanumeric_chars = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(5, 10)))\n    return alphanumeric_chars + alphanumeric_chars[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function f(s: str) that checks if a given string is a palindrome after removing non-alphanumeric characters, and another function g() that generates a random alphanumeric string and its palindrome. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, random generation of strings, and checking for palindromes. It can be used to teach students about string operations, list comprehensions, random module, and function testing with assert statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3941792845726013,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom math import sqrt\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 13  # A prime number for illustration\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and number theory (primes).",
        "idx_generation": 32,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from math import sqrt\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    num = 13  # A prime number for illustration\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is a prime number, and a function g() that returns a prime number (in this case, 13). The puzzle tests whether the function f correctly identifies the prime number returned by g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number using a function f, and then verifying this with a specific prime number returned by function g. This can be a good exercise to understand prime number checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6465449929237366,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"radar\"  # A palindrome word for illustration\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a word is a palindrome.",
        "idx_generation": 32,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int], common_diff=5) -> bool:\n    return all(int_list[i] - int_list[i - 1] == common_diff for i in range(1, len(int_list)))\n\ndef g(common_diff=5):\n    return [i * common_diff for i in range(10)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"radar\"  # A palindrome word for illustration",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that returns True if the input word is a palindrome, and a function g() that returns the word 'radar'. The assertion checks if the function f(g()) returns True for the word 'radar', which is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6302189230918884,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int) -> bool:\n    return longest_subsequence_length == 4  # Length of the longest increasing subsequence\n\ndef g():\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence([3, 4, 2, 8, 10, 5, 1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Dynamic Programming to find the longest increasing subsequence in a list of numbers.",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int) -> bool:\n    return longest_subsequence_length == 4  # Length of the longest increasing subsequence",
        "solution_func": "def g():\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence([3, 4, 2, 8, 10, 5, 1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it equals 4."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that calculates the length of the longest increasing subsequence in a list of numbers and then check if this length is equal to 4.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.482252299785614,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport string\n\ndef f(s: str) -> bool:\n    alphanumeric = [char for char in s if char.isalnum()]\n    return alphanumeric == alphanumeric[::-1] and any(char.isdigit() for char in s)\n\ndef g(length: int = 10) -> str:\n    import random\n\n    def generate_random_string(length):\n        chars = random.choices(string.ascii_letters + string.digits, k=length)\n        return ''.join(chars)\n\n    palindrome = generate_random_string(length)\n    return palindrome + random.choice(string.digits) + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.), Probability and Statistics",
        "idx_generation": 32,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import string\n\ndef f(s: str) -> bool:\n    alphanumeric = [char for char in s if char.isalnum()]\n    return alphanumeric == alphanumeric[::-1] and any(char.isdigit() for char in s)",
        "solution_func": "def g(length: int = 10) -> str:\n    import random\n\n    def generate_random_string(length):\n        chars = random.choices(string.ascii_letters + string.digits, k=length)\n        return ''.join(chars)\n\n    palindrome = generate_random_string(length)\n    return palindrome + random.choice(string.digits) + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome with at least one digit, and another function g(length) that generates a random palindrome string with a digit in the middle."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, list comprehension, random module, and function definition in Python. It also tests the understanding of palindrome strings and checking for digits in a string.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3680875301361084,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string concatenated with its reverse is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string, concatenating it with its reverse, and checking if the resulting string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4574558734893799,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g():\n    import string\n    import random\n    letters = string.ascii_lowercase\n    random_string = ''.join(random.choice(letters) for _ in range(10))\n    return random_string + random_string[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g():\n    import string\n    import random\n    letters = string.ascii_lowercase\n    random_string = ''.join(random.choice(letters) for _ in range(10))\n    return random_string + random_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f that checks if a string is a palindrome, the puzzle requires generating a random string and its reverse, and checking if the generated string satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, generating random strings, and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.433660089969635,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) > 2\n\n    return longest_increasing_subsequence(nums)\n\ndef g(nums=[3, 10, 2, 1, 20]):\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to find the longest increasing subsequence in a list of numbers.",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target=10) -> bool:\n    def is_subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n - 1] > target:\n            return is_subset_sum(nums, n - 1, target)\n        return is_subset_sum(nums, n - 1, target) or is_subset_sum(nums, n - 1, target - nums[n - 1])\n\n    return is_subset_sum(subset, len(subset), target)\n\ndef g():\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) > 2\n\n    return longest_increasing_subsequence(nums)",
        "solution_func": "def g(nums=[3, 10, 2, 1, 20]):\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest increasing subsequence in a list of integers and checking if the length of the subsequence is greater than 2."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming to find the longest increasing subsequence and comparing its length to 2.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4487118422985077,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_palindrome(s):\n        clean_s = ''.join(char.lower() for char in s if char.isalnum())\n        return clean_s == clean_s[::-1]\n\n    return is_palindrome(s)\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target=10) -> bool:\n    def is_subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n - 1] > target:\n            return is_subset_sum(nums, n - 1, target)\n        return is_subset_sum(nums, n - 1, target) or is_subset_sum(nums, n - 1, target - nums[n - 1])\n\n    return is_subset_sum(subset, len(subset), target)\n\ndef g():\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_palindrome(s):\n        clean_s = ''.join(char.lower() for char in s if char.isalnum())\n        return clean_s == clean_s[::-1]\n\n    return is_palindrome(s)",
        "solution_func": "def g(s=\"A man, a plan, a canal: Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome after cleaning it by removing non-alphanumeric characters and converting it to lowercase. The solution function simply returns a specific string. The assertion checks if the solution function satisfies the palindrome condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4438125193119049,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s='racecar') -> str:\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s='racecar') -> str:\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g(s) that returns the input string. The assertion checks if the function f(g()) returns True for the default input 'racecar'.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6670405864715576,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(triangle_sides: List[int]) -> bool:\n    a, b, c = sorted(triangle_sides)\n    return a + b > c\n\ndef g() -> List[int]:\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given set of numbers can form a valid triangle (Triangle Inequality Theorem). The solution function generates a list of triangle sides that satisfy the condition.",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(triangle_sides: List[int]) -> bool:\n    a, b, c = sorted(triangle_sides)\n    return a + b > c",
        "solution_func": "def g() -> List[int]:\n    return [3, 4, 5]",
        "quality": [
            null
        ],
        "description": [
            "Given a list of three integers representing the sides of a triangle, function f checks if the sides form a valid triangle by applying the triangle inequality theorem. Function g returns a list [3, 4, 5] which represents a valid right-angled triangle, and the assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given set of three integers can form a valid triangle using the triangle inequality theorem. The solution function g returns a list representing a valid right-angled triangle, and the assert statement verifies the correctness of the solution.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6383261680603027,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = random.randint(1, 5)\n    random_str = ''.join(random.choices(letters, k=half_length))\n    palindrome = random_str + random_str[::-1]\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 33,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if numbers[i]**2 + numbers[j]**2 == numbers[k]**2:\n                    return True\n    return False\n\ndef g():\n    import random\n    numbers = [random.randint(1, 20) for _ in range(7)]\n    # Generate a list where a Pythagorean triplet exists\n    numbers.append((numbers[-1]**2 + numbers[-2]**2)**0.5)\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = random.randint(1, 5)\n    random_str = ''.join(random.choices(letters, k=half_length))\n    palindrome = random_str + random_str[::-1]\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is suitable for teaching Python concepts such as string manipulation, functions, and assertions. It also reinforces the concept of palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.44256457686424255,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g() -> List[int]:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    n = random.randint(3, 7)\n    return [start + i * diff for i in range(n)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and pattern recognition.",
        "idx_generation": 33,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if numbers[i]**2 + numbers[j]**2 == numbers[k]**2:\n                    return True\n    return False\n\ndef g():\n    import random\n    numbers = [random.randint(1, 20) for _ in range(7)]\n    # Generate a list where a Pythagorean triplet exists\n    numbers.append((numbers[-1]**2 + numbers[-2]**2)**0.5)\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))",
        "solution_func": "def g() -> List[int]:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    n = random.randint(3, 7)\n    return [start + i * diff for i in range(n)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list of integers forms an arithmetic sequence, and a function g that generates a random arithmetic sequence. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation, arithmetic sequences, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5165054202079773,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutation: str) -> bool:\n    def permute(s):\n        if len(s) == 1:\n            return [s]\n        result = []\n        for i, c in enumerate(s):\n            for perm in permute(s[:i] + s[i + 1:]):\n                result.append(c + perm)\n        return result\n\n    return permutation in permute(\"abc\")\n\ndef g():\n    return \"cab\"\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(permutation: str) -> bool:\n    def permute(s):\n        if len(s) == 1:\n            return [s]\n        result = []\n        for i, c in enumerate(s):\n            for perm in permute(s[:i] + s[i + 1:]):\n                result.append(c + perm)\n        return result\n\n    return permutation in permute(\"abc\")",
        "solution_func": "def g():\n    return \"cab\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that generates all permutations of a given string and then checks if a specific permutation is in the list of generated permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves recursion and string manipulation to generate permutations of a string. The solution function g() returns a specific permutation 'cab' and the puzzle function f() checks if this permutation is in the list of all permutations of 'abc'.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4667791724205017,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Pattern Recognition, Conditional Logic",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)",
        "solution_func": "def g():\n    return [2, 4, 6, 8, 10]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of integers and checks if the list forms an arithmetic sequence. The solution function g returns a specific arithmetic sequence to test the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given list of integers forms an arithmetic sequence with a common difference. The solution function provides a known arithmetic sequence to test the function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5652347803115845,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str, s='banana') -> bool:\n    return palindrome == max((s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1) if s[i:j] == s[i:j][::-1]), key=len)\n\ndef g(s='banana') -> str:\n    return max((s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1) if s[i:j] == s[i:j][::-1]), key=len)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True"
        ],
        "problem_func": "def f(palindrome: str, s='banana') -> bool:\n    return palindrome == max((s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1) if s[i:j] == s[i:j][::-1]), key=len)",
        "solution_func": "def g(s='banana') -> str:\n    return max((s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1) if s[i:j] == s[i:j][::-1]), key=len)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if a given string is a palindrome and the second function finds the longest palindrome substring in a given string. The puzzle requires the second function to be a solution to the first function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, list comprehension, and comparison of strings in Python. It also requires knowledge of functions and how to define and call them in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45679783821105957,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int, n=5) -> bool:\n    def recursive_factorial(n):\n        return 1 if n == 0 else n * recursive_factorial(n - 1)\n    return factorial == recursive_factorial(n)\n\ndef g(n=5) -> int:\n    def recursive_factorial(n):\n        return 1 if n == 0 else n * recursive_factorial(n - 1)\n    return recursive_factorial(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations (factorial calculation).",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True"
        ],
        "problem_func": "def f(factorial: int, n=5) -> bool:\n    def recursive_factorial(n):\n        return 1 if n == 0 else n * recursive_factorial(n - 1)\n    return factorial == recursive_factorial(n)",
        "solution_func": "def g(n=5) -> int:\n    def recursive_factorial(n):\n        return 1 if n == 0 else n * recursive_factorial(n - 1)\n    return recursive_factorial(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given factorial value matches the factorial calculated using a recursive function. Another function g calculates the factorial using recursion. The puzzle tests if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursive functions and factorial calculation in Python. It can be used to teach students about recursion and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6078702211380005,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    word = word.lower().replace(\" \", \"\")  # Remove spaces and lowercase\n    if len(word) <= 1:\n        return True\n    if word[0] == word[-1]:\n        return f(word[1:-1])\n    return False\n\ndef g():\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(8))\n    return word + word[::-1]  # Generate a palindrome string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, recursion, and conditional logic.",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    word = word.lower().replace(\" \", \"\")  # Remove spaces and lowercase\n    if len(word) <= 1:\n        return True\n    if word[0] == word[-1]:\n        return f(word[1:-1])\n    return False",
        "solution_func": "def g():\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(8))\n    return word + word[::-1]  # Generate a palindrome string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(word: str) that checks if a given word is a palindrome after removing spaces and converting to lowercase. Another function g() generates a random palindrome string and the assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, recursion, and palindrome checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4816634953022003,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    length = random.randint(3, 6)\n    return [start + diff * i for i in range(length)]  # Generate an arithmetic sequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Brute Force Search to check if a given list of numbers forms an arithmetic sequence.",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    length = random.randint(3, 6)\n    return [start + diff * i for i in range(length)]  # Generate an arithmetic sequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of integers forms an arithmetic sequence with a common difference between consecutive elements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of arithmetic sequences and list manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4464946389198303,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_palindrome(s):\n        s = ''.join(char.lower() for char in s if char.isalnum())\n        return s == s[::-1]\n\n    return is_palindrome(s)\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(tree: TreeNode) -> bool:\n    def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n\n        if not (min_val < node.val < max_val):\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(tree)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_palindrome(s):\n        s = ''.join(char.lower() for char in s if char.isalnum())\n        return s == s[::-1]\n\n    return is_palindrome(s)",
        "solution_func": "def g(s=\"A man, a plan, a canal: Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome after removing non-alphanumeric characters and ignoring case. The solution function simply returns a specific string. The assertion at the end checks if the solution function correctly solves the challenge defined in the puzzle function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46218958497047424,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and number theory (primes).",
        "idx_generation": 34,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    num = 17\n    return num",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(num) that checks if a number is prime, write a function g() that returns the number 17 and assert that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is prime using function f(num) and writing a function g() that returns a specific number. The assertion tests if the function g() returns the correct number to satisfy the condition of being prime.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6886076331138611,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g():\n    s = \"A man a plan a canal Panama\"\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 34,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g():\n    s = \"A man a plan a canal Panama\"\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing spaces and converting to lowercase. The solution function g returns a specific string, and the assertion checks if f applied to the output of g returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation and checking for palindromes in Python. It is a suitable challenge for students learning Python as it tests their understanding of string methods and functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.627007007598877,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(length: int) -> bool:\n    return length >= 3\n\ndef g(nums=[4, 2, 8, 5, 7, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Dynamic Programming for finding the length of the longest increasing subsequence in a list of numbers.",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(length: int) -> bool:\n    return length >= 3",
        "solution_func": "def g(nums=[4, 2, 8, 5, 7, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that checks if the length of a list is greater than or equal to 3. The solution function uses dynamic programming to find the length of the longest increasing subsequence in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list lengths and dynamic programming concepts in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4028750956058502,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: set) -> bool:\n    return len(result) == 3\n\ndef g(set1={1, 2, 3, 4}, set2={3, 4, 5}):\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: set) -> bool:\n    return len(result) == 3",
        "solution_func": "def g(set1={1, 2, 3, 4}, set2={3, 4, 5}):\n    return set1.symmetric_difference(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a set has a length of 3, and a function g that returns the symmetric difference of two sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with sets and understanding the symmetric difference operation in Python. It tests the student's knowledge of set operations and function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6420779824256897,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int) -> bool:\n    return max_sum == 15\n\ndef g(numbers=[3, 7, 2, 8, 5], threshold=15):\n    def backtrack(index, path, current_sum):\n        if current_sum > threshold:\n            return\n        \n        max_sum[0] = max(max_sum[0], current_sum)\n\n        for i in range(index, len(numbers)):\n            path.append(numbers[i])\n            backtrack(i + 1, path, current_sum + numbers[i])\n            path.pop()\n\n    max_sum = [0]\n    backtrack(0, [], 0)\n    return max_sum[0]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 34,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(numbers=[1, 2, 3]):\n    def backtrack(path, nums):\n        if not nums:\n            permutations.append(path.copy())\n            return\n        \n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(path, nums[:i] + nums[i+1:])\n            path.pop()\n\n    permutations = []\n    backtrack([], numbers)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int) -> bool:\n    return max_sum == 15",
        "solution_func": "def g(numbers=[3, 7, 2, 8, 5], threshold=15):\n    def backtrack(index, path, current_sum):\n        if current_sum > threshold:\n            return\n        \n        max_sum[0] = max(max_sum[0], current_sum)\n\n        for i in range(index, len(numbers)):\n            path.append(numbers[i])\n            backtrack(i + 1, path, current_sum + numbers[i])\n            path.pop()\n\n    max_sum = [0]\n    backtrack(0, [], 0)\n    return max_sum[0]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum sum of a subset of numbers from a given list that does not exceed a specified threshold, and checking if the maximum sum is equal to 15."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves backtracking to find the maximum sum of a subset of numbers that does not exceed a threshold. The solution function g uses backtracking to find the maximum sum and returns it. The puzzle function f checks if the maximum sum is equal to 15.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45763227343559265,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal, Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal, Panama\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome after removing non-alphanumeric characters and converting to lowercase, and a function g() that returns a specific string, determine if the string returned by g() is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a specific string is a palindrome after removing non-alphanumeric characters and converting to lowercase. The solution function g() returns a specific string, and the puzzle function f(s) checks if this string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5467609763145447,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to generating arithmetic sequences and checking if a list of numbers forms an arithmetic sequence.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))",
        "solution_func": "def g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of numbers forms an arithmetic sequence, and a function g that generates a random arithmetic sequence of length 5. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding arithmetic sequences, list comprehension, and random number generation in Python. It provides a practical application of these concepts in a programming challenge.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5555610656738281,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation to check if a word is a palindrome. It also includes conditional logic to compare the word with its reverse. The solution provides a specific word 'radar' that is a palindrome.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that returns True if the word is a palindrome (reads the same forwards and backwards), and a function g() that returns the word 'radar'. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.637157142162323,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Bitwise Operations, Set Operations",
        "idx_generation": 35,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val",
        "solution_func": "def g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum XOR value that can be obtained from a given list of numbers, with a specific target value. The function f checks if the provided maximum XOR value is correct, while function g calculates the maximum XOR value."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves bitwise operations and finding the maximum XOR value, which may be challenging for students who are not familiar with these concepts. It requires understanding of bitwise manipulation and set operations. The puzzle may be too complex for master's students in CS who are new to Python programming.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.37678512930870056,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sorted_strings: List[str], strings=['apple', 'banana', 'orange', 'grape']) -> bool:\n    return sorted(strings, key=lambda x: (len(x), x)) == sorted_strings\n\ndef g(strings=['apple', 'banana', 'orange', 'grape']) -> List[str]:\n    return sorted(strings, key=lambda x: (len(x), x))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering.",
        "idx_generation": 35,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(sorted_strings: List[str], strings=['apple', 'banana', 'orange', 'grape']) -> bool:\n    return sorted(strings, key=lambda x: (len(x), x)) == sorted_strings",
        "solution_func": "def g(strings=['apple', 'banana', 'orange', 'grape']) -> List[str]:\n    return sorted(strings, key=lambda x: (len(x), x))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that sorts a list of strings based on their length and lexicographical order, and then check if the sorted list matches a given list of strings."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to sort a list of strings using a custom key function and comparing the sorted list with a given list to determine if they are equal.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.5047764182090759,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(substrings: list, s='hello') -> bool:\n    all_substrings = {s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)}\n    return set(substrings) == all_substrings\n\ndef g(s='hello'):\n    return [s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations, Permutations and Combinations",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(substrings: list, s='hello') -> bool:\n    all_substrings = {s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)}\n    return set(substrings) == all_substrings",
        "solution_func": "def g(s='hello'):\n    return [s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given list of substrings is equal to all possible substrings of a given string 'hello'. The solution function g generates all possible substrings of the string 'hello'."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, sets, and string slicing in Python. It tests the ability to generate all possible substrings of a given string and compare them to a list of substrings.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4331014156341553,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(combinations: list, list1=[1, 2, 3], list2=['a', 'b']) -> bool:\n    all_combinations = list(itertools.product(list1, list2))\n    return set(combinations) == set(all_combinations)\n\ndef g(list1=[1, 2, 3], list2=['a', 'b']):\n    return list(itertools.product(list1, list2))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves importing the itertools module, using itertools.product for generating combinations, and comparing sets for equality.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(combinations: list, list1=[1, 2, 3], list2=['a', 'b']) -> bool:\n    all_combinations = list(itertools.product(list1, list2))\n    return set(combinations) == set(all_combinations)",
        "solution_func": "def g(list1=[1, 2, 3], list2=['a', 'b']):\n    return list(itertools.product(list1, list2))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to understand how to generate all possible combinations of elements from two given lists and compare them to a given list of combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the itertools module to generate all combinations of elements from two lists and then comparing these combinations to a given list of combinations to check for equality.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4036107659339905,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(subset: list, limit=100) -> bool:\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return set(subset).issubset(fibonacci)\n\ndef g(limit=100):\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Fibonacci sequence generation and set operations.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(subset: list, limit=100) -> bool:\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return set(subset).issubset(fibonacci)",
        "solution_func": "def g(limit=100):\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given subset of numbers is a subset of the Fibonacci sequence up to a certain limit. The solution function g generates the Fibonacci sequence up to the specified limit and returns it. The puzzle requires f(g()) to return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate and check subsets of the Fibonacci sequence within a given limit. It tests the student's knowledge of sets, loops, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5108185410499573,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(prime_pairs: List[List[int]], pattern=(2, 4, 6)) -> bool:\n    def check_pattern(pair, pattern):\n        return abs(pair[1] - pair[0]) in pattern\n\n    return any(check_pattern(pair, pattern) for pair in prime_pairs)\n\ndef g(limit=20, pattern=(2, 4, 6)):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    prime_pairs = [[primes[i], primes[j]] for i in range(len(primes)) for j in range(i + 1, len(primes))]\n    return prime_pairs\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Number Theory (factors, primes, etc.) and Conditional Logic.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    target_sequence = [1, 2, 3, 4]  # Sequence to find in the matrix\n    \n    def find_sequence_in_row(row):\n        for i in range(len(row) - len(target_sequence) + 1):\n            if row[i:i+len(target_sequence)] == target_sequence:\n                return True\n        return False\n\n    for row in matrix:\n        if find_sequence_in_row(row):\n            return True\n    return False\n\ndef g(matrix=[[1, 2, 3, 4, 5],\n             [6, 7, 8, 9, 10],\n             [11, 12, 1, 2, 3],\n             [4, 5, 6, 7, 8]]):\n    return matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(prime_pairs: List[List[int]], pattern=(2, 4, 6)) -> bool:\n    def check_pattern(pair, pattern):\n        return abs(pair[1] - pair[0]) in pattern\n\n    return any(check_pattern(pair, pattern) for pair in prime_pairs)",
        "solution_func": "def g(limit=20, pattern=(2, 4, 6)):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    prime_pairs = [[primes[i], primes[j]] for i in range(len(primes)) for j in range(i + 1, len(primes))]\n    return prime_pairs",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if there exist pairs of prime numbers in a given range that satisfy a specific pattern of the difference between the two numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to generate pairs of prime numbers within a given range and then check if any of these pairs satisfy a specific pattern of differences between the two numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4176730811595917,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Mathematical Operations, Dynamic Programming, and Algorithm Optimization.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6",
        "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum sum of a subarray within a given list of integers and checking if the maximum sum is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the maximum sum of a subarray using dynamic programming and comparing it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4622094929218292,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves permutations and set operations to check if a list of permutations matches a specific set of tuples.",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}",
        "solution_func": "def g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the permutations of a given list of numbers contain a specific set of tuples."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to generate all permutations of a list of numbers and check if they match a specific set of tuples.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.426542192697525,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_combination: int) -> bool:\n    return sum_combination == 20\n\ndef g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int) -> bool:\n    return max_sum == 15\n\ndef g(numbers=[3, 7, 2, 8, 5], threshold=15):\n    def backtrack(index, path, current_sum):\n        if current_sum > threshold:\n            return\n        \n        max_sum[0] = max(max_sum[0], current_sum)\n\n        for i in range(index, len(numbers)):\n            path.append(numbers[i])\n            backtrack(i + 1, path, current_sum + numbers[i])\n            path.pop()\n\n    max_sum = [0]\n    backtrack(0, [], 0)\n    return max_sum[0]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(sum_combination: int) -> bool:\n    return sum_combination == 20",
        "solution_func": "def g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a combination of numbers from a given list that adds up to 20 using backtracking algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a backtracking algorithm to find a combination of numbers that sum up to 20. The solution function g() recursively explores all possible combinations of numbers to achieve the target sum.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.40763962268829346,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(length=5, chars='abc'):\n    mid = length // 2\n    palindrome = chars[:mid] + chars[length - mid - length % 2 - 1::-1]\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(length=5, chars='abc'):\n    mid = length // 2\n    palindrome = chars[:mid] + chars[length - mid - length % 2 - 1::-1]\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g(length=5, chars='abc') that generates a palindrome string based on the input length and characters. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5258806943893433,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nth_fib: int, n=5) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == nth_fib\n\ndef g(n=5):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion to calculate the nth Fibonacci number and then checks if the calculated Fibonacci number matches the expected nth Fibonacci number. The solution function g() calculates the nth Fibonacci number using a loop. The puzzle mainly focuses on Recursion and Mathematical Operations topics.",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nth_fib: int, n=5) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == nth_fib",
        "solution_func": "def g(n=5):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the nth Fibonacci number using two functions, f and g. Function f checks if the nth Fibonacci number matches a predefined value, while function g calculates the nth Fibonacci number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a common programming concept of calculating Fibonacci numbers using iterative methods. It tests the student's understanding of function composition and algorithm implementation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6616824865341187,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(smallest_divisible: int) -> bool:\n    def is_divisible(num, limit):\n        for i in range(1, limit + 1):\n            if num % i != 0:\n                return False\n        return True\n\n    return is_divisible(smallest_divisible, 10)\n\ndef g(limit=10):\n    def lcm(a, b):\n        return a * b // math.gcd(a, b)\n\n    result = 1\n    for i in range(2, limit + 1):\n        result = lcm(result, i)\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, number theory, and importing modules (math). It requires understanding of finding the least common multiple (LCM) and checking divisibility.",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(prime_pairs: List[List[int]], pattern=(2, 4, 6)) -> bool:\n    def check_pattern(pair, pattern):\n        return abs(pair[1] - pair[0]) in pattern\n\n    return any(check_pattern(pair, pattern) for pair in prime_pairs)\n\ndef g(limit=20, pattern=(2, 4, 6)):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    prime_pairs = [[primes[i], primes[j]] for i in range(len(primes)) for j in range(i + 1, len(primes))]\n    return prime_pairs\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(smallest_divisible: int) -> bool:\n    def is_divisible(num, limit):\n        for i in range(1, limit + 1):\n            if num % i != 0:\n                return False\n        return True\n\n    return is_divisible(smallest_divisible, 10)",
        "solution_func": "def g(limit=10):\n    def lcm(a, b):\n        return a * b // math.gcd(a, b)\n\n    result = 1\n    for i in range(2, limit + 1):\n        result = lcm(result, i)\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the smallest positive number that is evenly divisible by all numbers from 1 to a given limit."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of finding the least common multiple (LCM) and checking divisibility.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5360667705535889,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1))\n\ndef g():\n    import random\n\n    length = random.randint(5, 10)\n    numbers = random.sample(range(1, 100), length)\n    numbers.sort()\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves sorting a list of numbers in ascending order using random sampling and sorting algorithms.",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1))",
        "solution_func": "def g():\n    import random\n\n    length = random.randint(5, 10)\n    numbers = random.sample(range(1, 100), length)\n    numbers.sort()\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a list of random numbers, sorting them, and then checking if the list is sorted in ascending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random list of numbers, sorting them, and checking if the list is sorted in ascending order. The solution function g() generates a random list of numbers, sorts it, and returns the sorted list. The puzzle function f(numbers) checks if the input list is sorted in ascending order.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4518510699272156,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(words[i] >= words[i+1] for i in range(len(words)-1))\n\ndef g():\n    import random\n    import string\n\n    length = random.randint(5, 10)\n    words = [''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(3, 8))) for _ in range(length)]\n    words.sort(reverse=True)\n    return words\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, random generation of strings, sorting, and list comprehension.",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i - 1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n\n    start = random.randint(1, 10)\n    common_diff = random.randint(1, 5)\n    length = random.randint(3, 7)\n    return [start + i * common_diff for i in range(length)]\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(words[i] >= words[i+1] for i in range(len(words)-1))",
        "solution_func": "def g():\n    import random\n    import string\n\n    length = random.randint(5, 10)\n    words = [''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(3, 8))) for _ in range(length)]\n    words.sort(reverse=True)\n    return words",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating a list of random words, sorting them in reverse order, and checking if the list is sorted in non-increasing order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating random words, sorting them in reverse order, and then checking if the list is sorted in non-increasing order using the provided functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.3601616322994232,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(length: int = 5) -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = length // 2\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[-2::-1])\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to create a palindrome and then check if it is indeed a palindrome.",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(length: int = 5) -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = length // 2\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[-2::-1])\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g(length: int = 5) that generates a random palindrome string of a specified length. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, random generation, and function assertion in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4498786926269531,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (primes) and Importing Modules (Sympy).",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and another function g() that generates a random prime number between 1 and 100. The puzzle requires g() to return a prime number that satisfies the condition of f(g()) == True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, generating random prime numbers, and checking if a number is prime using a given function. It tests the student's knowledge of prime number generation and checking algorithms in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6604961156845093,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Set\n\ndef f(intersection_set: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return intersection_set == set1 & set2\n\ndef g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return set1 & set2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to find the intersection of two sets and compare it with another set.",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import Set\n\ndef f(intersection_set: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return intersection_set == set1 & set2",
        "solution_func": "def g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return set1 & set2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the intersection of two sets is equal to a given set, and a function g that returns the intersection of two specific sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sets, set operations, and function definition in Python. It tests the understanding of set intersection and function composition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.598301887512207,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    target_combination = ('a', 'b')\n    return target_combination in combinations_list\n\ndef g(chars=['a', 'b', 'c', 'd']) -> List[str]:\n    return list(combinations(chars, 2))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves importing the itertools module and using combinations to generate all possible combinations of characters in a list. The f function checks if a specific target combination is present in the list of combinations generated by g. The solution g generates all combinations of characters in a given list. The assert statement checks if the target combination ('a', 'b') is present in the combinations list generated by g.",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    target_combination = ('a', 'b')\n    return target_combination in combinations_list",
        "solution_func": "def g(chars=['a', 'b', 'c', 'd']) -> List[str]:\n    return list(combinations(chars, 2))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a specific combination ('a', 'b') is present in a list of combinations generated by function g. Function g generates combinations of characters from a given list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is suitable for teaching Python programming concepts such as list manipulation, function definition, and using itertools module for generating combinations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5072344541549683,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    palindrome = \"racecar\"\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation to check for palindrome, which falls under the topic of String Manipulation.",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(number=17):\n    return number\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    palindrome = \"racecar\"\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns a predefined palindrome string. The assertion checks if the function f(g()) returns True for the predefined palindrome string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6601685285568237,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Conditional Logic are used in the problem f and solution g.",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal: Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase. The solution function g returns a specific string, and the puzzle asserts that applying f to the output of g should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5394111275672913,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using a brute force search approach.",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given number is a prime number, and a function g() that finds the next prime number after 17. The assertion checks if the next prime number after 17 is correctly identified."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to find the next prime number after a given number. It tests the student's knowledge of loops, conditionals, and prime number checking.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6488509774208069,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to check for uniqueness of elements in a list.",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    return len(nums) == len(set(nums))",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9, 11, 13]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of numbers and returns True if all the numbers in the list are unique, and a function g that returns a list of numbers. The puzzle is solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a list of numbers contains only unique elements. The solution function g returns a list of numbers, and the puzzle is solved if the function f correctly identifies if all elements in the list are unique.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5636407732963562,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Set\n\ndef f(intersection_set: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    \n    return intersection_set == set1.intersection(set2)\n\ndef g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    \n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to find the intersection of two sets and compare it with another set. It also includes the concept of assertions for testing the solution.",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import Set\n\ndef f(intersection_set: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    \n    return intersection_set == set1.intersection(set2)",
        "solution_func": "def g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    \n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the intersection of two sets is equal to a given set, and a function g that returns the intersection of two specific sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is a simple exercise in working with sets and set operations in Python. It tests the understanding of set intersection and comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5223289132118225,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using a simple algorithm. It does not directly relate to any specific topic from the list provided.",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(probs: List[float]) -> bool:\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06\ndef g():\n    return [1 / 3] * 3\nassert f(g()) == True",
            "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 13",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(num) that checks if a number is prime, write a function g() that returns the number 13 and assert that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(num) that checks if a number is prime, and then defining a function g() that returns the number 13. The puzzle asserts that f(g()) should return True.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.7145236730575562,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    return result % 5 == 0\n\ndef g():\n    num = 5\n    for i in range(1, 10):\n        num *= i\n        if num % 5 == 0:\n            return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a number is divisible by 5.",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(probs: List[float]) -> bool:\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06\ndef g():\n    return [1 / 3] * 3\nassert f(g()) == True",
            "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    return result % 5 == 0",
        "solution_func": "def g():\n    num = 5\n    for i in range(1, 10):\n        num *= i\n        if num % 5 == 0:\n            return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a number that is a multiple of 5 after performing a series of multiplications."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if a given result is divisible by 5, and a function g that iteratively multiplies a number by integers and returns the first multiple of 5. The assertion checks if the result of g satisfies the condition of f.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.7081626653671265,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"racecar\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome and a function g(s) that returns a default string 'racecar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6722093820571899,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=7):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and number theory (primality testing). The function f checks if a given number is a prime number. The function g returns a default number (7) to be checked for primality. The assert statement checks if the function f returns True for the number returned by function g.",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=7):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g(num) that returns a specific number (default is 7). The puzzle requires g to be implemented in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function implementation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6193795800209045,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 38,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that returns a specific string 'radar'. The assertion tests if the function f(g()) returns True for the string 'radar', which is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.673439621925354,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef f(numbers: list[int]) -> bool:\n    return any(is_prime(num) for num in numbers)\n\ndef g(length=5) -> list[int]:\n    return [i for i in range(2, 2*length+2, 2)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, loops, and list comprehension.",
        "idx_generation": 38,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef f(numbers: list[int]) -> bool:\n    return any(is_prime(num) for num in numbers)",
        "solution_func": "def g(length=5) -> list[int]:\n    return [i for i in range(2, 2*length+2, 2)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if any of the numbers generated by function g are prime numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand prime numbers and how to generate a list of numbers using list comprehension in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.47446298599243164,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 38,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"racecar\") -> str:\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, write a function g(input_str) that appends the reverse of the input string to itself and returns the result. The puzzle requires g to be implemented in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically reversing a string and checking for palindromes. It also tests the ability to compose functions and understand function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5278496742248535,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sorted_list: List[int]) -> bool:\n    return all(sorted_list[i] <= sorted_list[i+1] for i in range(len(sorted_list) - 1))\n\ndef g(numbers=[4, 2, 2, 8, 3, 3, 1]):\n    max_num = max(numbers)\n    count_arr = [0] * (max_num + 1)\n\n    for num in numbers:\n        count_arr[num] += 1\n\n    sorted_list = []\n    for i in range(len(count_arr)):\n        sorted_list.extend([i] * count_arr[i])\n\n    return sorted_list\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering",
        "idx_generation": 38,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(shortest_path: int, grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1] == shortest_path\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sorted_list: List[int]) -> bool:\n    return all(sorted_list[i] <= sorted_list[i+1] for i in range(len(sorted_list) - 1))",
        "solution_func": "def g(numbers=[4, 2, 2, 8, 3, 3, 1]):\n    max_num = max(numbers)\n    count_arr = [0] * (max_num + 1)\n\n    for num in numbers:\n        count_arr[num] += 1\n\n    sorted_list = []\n    for i in range(len(count_arr)):\n        sorted_list.extend([i] * count_arr[i])\n\n    return sorted_list",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given list is sorted in non-decreasing order, and a function g that takes a list of numbers, counts the occurrences of each number, and returns a sorted list based on the counts. The assertion at the end checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sorting and counting elements in a list. It requires knowledge of list comprehension, loops, and the all() function in Python. It can be used to teach students about sorting algorithms and list manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.41754671931266785,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(triplet_sum: List[int]) -> bool:\n    return any(sum(triplet) == 0 for triplet in triplet_sum)\n\ndef g(numbers=[-1, 0, 1, 2, -1, -4]):\n    numbers.sort()\n    triplets = []\n    for i in range(len(numbers) - 2):\n        if i > 0 and numbers[i] == numbers[i-1]:\n            continue\n        left, right = i + 1, len(numbers) - 1\n        while left < right:\n            total = numbers[i] + numbers[left] + numbers[right]\n            if total == 0:\n                triplets.append([numbers[i], numbers[left], numbers[right]])\n                left += 1\n                right -= 1\n                while left < right and numbers[left] == numbers[left-1]:\n                    left += 1\n                while left < right and numbers[right] == numbers[right+1]:\n                    right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return triplets\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves finding triplets in a list that sum up to zero using a specific algorithm. The topics used in this puzzle are sorting, loops, conditional logic, and list manipulation.",
        "idx_generation": 38,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(shortest_path: int, grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1] == shortest_path\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(triplet_sum: List[int]) -> bool:\n    return any(sum(triplet) == 0 for triplet in triplet_sum)",
        "solution_func": "def g(numbers=[-1, 0, 1, 2, -1, -4]):\n    numbers.sort()\n    triplets = []\n    for i in range(len(numbers) - 2):\n        if i > 0 and numbers[i] == numbers[i-1]:\n            continue\n        left, right = i + 1, len(numbers) - 1\n        while left < right:\n            total = numbers[i] + numbers[left] + numbers[right]\n            if total == 0:\n                triplets.append([numbers[i], numbers[left], numbers[right]])\n                left += 1\n                right -= 1\n                while left < right and numbers[left] == numbers[left-1]:\n                    left += 1\n                while left < right and numbers[right] == numbers[right+1]:\n                    right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return triplets",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding triplets in a list of numbers whose sum is equal to zero."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if there exists a triplet in a list of numbers whose sum is zero. The solution function g finds such triplets in a given list of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.31825998425483704,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 38,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g()) == True"
        ],
        "problem_func": "def f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function f(number: int) that checks if a given number is a prime number. The student also needs to define a function g() that returns the number 17. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number and returning True if it is. The solution function g() returns the number 17, which is a prime number. The puzzle tests the student's understanding of prime numbers and function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6411516070365906,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(input_str: str) -> bool:\n    return input_str == input_str[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 38,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g()) == True"
        ],
        "problem_func": "def f(input_str: str) -> bool:\n    return input_str == input_str[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given string is a palindrome. The solution function g returns the string 'radar', which is a palindrome. The assert statement confirms that f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6529030203819275,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 38,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome (reads the same forwards and backwards). The solution function g() returns the string 'radar', which is a palindrome, and the assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6713894009590149,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport string\nimport random\n\ndef f(text: str) -> bool:\n    has_digit = any(char.isdigit() for char in text)\n    has_special = any(char in string.punctuation for char in text)\n    return has_digit and has_special\n\ndef g() -> str:\n    length = random.randint(8, 12)\n    digits = ''.join(random.choices(string.digits, k=length // 2))\n    specials = ''.join(random.choices(string.punctuation, k=(length + 1) // 2))\n    mixed = list(digits + specials)\n    random.shuffle(mixed)\n    return ''.join(mixed)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation using random module to generate a random string, Conditional logic with the use of any() function, Importing modules (string, random),",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import string\nimport random\n\ndef f(text: str) -> bool:\n    has_digit = any(char.isdigit() for char in text)\n    has_special = any(char in string.punctuation for char in text)\n    return has_digit and has_special",
        "solution_func": "def g() -> str:\n    length = random.randint(8, 12)\n    digits = ''.join(random.choices(string.digits, k=length // 2))\n    specials = ''.join(random.choices(string.punctuation, k=(length + 1) // 2))\n    mixed = list(digits + specials)\n    random.shuffle(mixed)\n    return ''.join(mixed)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random string with a mix of digits and special characters, and then checking if the string contains at least one digit and at least one special character."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation, random generation, and boolean logic in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.39022180438041687,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    clean_string = ''.join(char.lower() for char in string if char.isalnum())\n    return clean_string == clean_string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    clean_string = ''.join(char.lower() for char in string if char.isalnum())\n    return clean_string == clean_string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome after removing non-alphanumeric characters, and a function g that generates a random palindrome string. The assert statement checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, random string generation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49064621329307556,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(matrix: list) -> bool:\n    return all(row == list(col) for row, col in zip(matrix, zip(*matrix)))\n\ndef g() -> list:\n    import random\n    n = random.randint(2, 5)\n    symmetric_matrix = [[random.randint(1, 9) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            symmetric_matrix[j][i] = symmetric_matrix[i][j]\n    return symmetric_matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves matrix manipulation and symmetry checking.",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(matrix: list) -> bool:\n    return all(row == list(col) for row, col in zip(matrix, zip(*matrix)))",
        "solution_func": "def g() -> list:\n    import random\n    n = random.randint(2, 5)\n    symmetric_matrix = [[random.randint(1, 9) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            symmetric_matrix[j][i] = symmetric_matrix[i][j]\n    return symmetric_matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random symmetric matrix and checking if the matrix is symmetric by comparing rows with columns."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of generating symmetric matrices and checking for symmetry in Python using list comprehension and zip functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.4492155611515045,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty(board)\n        if not empty:\n            return True\n        row, col = empty\n        for num in range(1, 10):\n            if is_safe(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n        return False\n\n    def find_empty(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome (reads the same forwards and backwards) by comparing the word to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(word) that checks if a word is a palindrome, and a function g() that returns the word 'radar'. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.576379120349884,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return result == factorial(5)\n\ndef g() -> int:\n    return 120\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Mathematical Operations",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty(board)\n        if not empty:\n            return True\n        row, col = empty\n        for num in range(1, 10):\n            if is_safe(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n        return False\n\n    def find_empty(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return result == factorial(5)",
        "solution_func": "def g() -> int:\n    return 120",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the result is equal to the factorial of 5, and a function g that returns the factorial of 5. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of recursion and function calls in Python by checking if a function correctly calculates the factorial of a number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6514167189598083,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: int, n=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return s == sum(num for num in range(2, n) if is_prime(num))\n\ndef g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return sum(num for num in range(2, n) if is_prime(num))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, loops, and function composition.",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: int, n=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return s == sum(num for num in range(2, n) if is_prime(num))",
        "solution_func": "def g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return sum(num for num in range(2, n) if is_prime(num))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the sum of prime numbers from 2 to n is equal to a given input s, and g calculates the sum of prime numbers from 2 to n. The assertion at the end checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and summing them up within a given range. It tests the student's knowledge of functions, loops, conditionals, and assertions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5787798166275024,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_length: int, nums=[4, 2, 3, 1, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == max_length\n\ndef g(nums=[4, 2, 3, 1, 5, 6]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Sorting and Ordering",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n",
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_length: int, nums=[4, 2, 3, 1, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == max_length",
        "solution_func": "def g(nums=[4, 2, 3, 1, 5, 6]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a list of numbers using dynamic programming."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding dynamic programming concepts to find the length of the longest increasing subsequence in a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4419461488723755,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=3))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 40,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=3))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given text is a palindrome, and a function g that generates a random palindrome string. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of palindrome strings and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5255082249641418,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_string = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return random_string + random_string[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic. The function f checks if a given string is a palindrome, and the function g generates a random string and its palindrome. The assertion checks if the generated string and its palindrome satisfy the palindrome condition.",
        "idx_generation": 40,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)\n\ndef g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_string = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return random_string + random_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, write a function g() that generates a random string and its palindrome, and returns them concatenated. The puzzle is to ensure that the generated string satisfies the palindrome condition when passed to f()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and its palindrome, then checking if the concatenated string satisfies the palindrome condition using the function f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.44334471225738525,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_str = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return random_str + random_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_str = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return random_str + random_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(s: str) -> bool checks if a given string is a palindrome, and g() -> str generates a random string and its palindrome. The assert statement checks if the generated string and its palindrome satisfy the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48864632844924927,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)\n\ndef g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, list operations, and random sampling from a range.",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)",
        "solution_func": "def g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the difference between the maximum and minimum values in a list of integers is equal to the maximum value in the list minus the minimum value. The solution function g generates a random list of 5 integers within a specified range and the assertion checks if f applied to the output of g returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic list manipulation and comparison operations in Python. It tests the understanding of generating random lists and calculating differences between elements. The solution function g generates a random list of integers, and the function f checks if the condition specified in the puzzle is met for the generated list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45522254705429077,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(lst: List[int]) -> bool:\n    return len(lst) != len(set(lst))\n\ndef g() -> List[int]:\n    import random\n    return random.choices(range(1, 10), k=5)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for duplicate elements in a list and generating a random list of integers.",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(lst: List[int]) -> bool:\n    return len(lst) != len(set(lst))",
        "solution_func": "def g() -> List[int]:\n    import random\n    return random.choices(range(1, 10), k=5)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list contains duplicate elements, and a function g that generates a random list of integers. The goal is to ensure that function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list manipulation and random number generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5356423854827881,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lst: list) -> bool:\n    return all(num % 2 == 0 for num in lst)\n\ndef g() -> list:\n    import random\n    return [random.randint(1, 100) * 2 for _ in range(5)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if all numbers in a list are even and generating a list of random even numbers.",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lst: list) -> bool:\n    return all(num % 2 == 0 for num in lst)",
        "solution_func": "def g() -> list:\n    import random\n    return [random.randint(1, 100) * 2 for _ in range(5)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(lst) that checks if all numbers in a list are even, and a function g() that generates a list of 5 random even numbers. The assert statement checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, the all() function, and generating random numbers in Python. It tests the student's knowledge of list operations and logical conditions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6110699772834778,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    palindrome = random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    palindrome = random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase) + random.choice(string.ascii_lowercase)\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string concatenated with its reverse is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and checking if the concatenated string with its reverse is a palindrome.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46689659357070923,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    import string\n    import random\n\n    letters = string.ascii_letters\n    palindrome = random.choices(letters, k=10)\n    palindrome += palindrome[::-1]\n\n    return ''.join(palindrome)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import string\n    import random\n\n    letters = string.ascii_letters\n    palindrome = random.choices(letters, k=10)\n    palindrome += palindrome[::-1]\n\n    return ''.join(palindrome)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to write a function that checks if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase. The solution function generates a random palindrome string and returns it."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, list comprehension, and checking for palindromes. It also requires knowledge of string methods and random module in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.37259501218795776,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g(input_str: str = \"racecar\"):\n    return input_str + input_str[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 40,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(input_str: str = \"racecar\"):\n    return input_str + input_str[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it to its reverse. The solution function creates a palindrome by appending the reverse of the string excluding the last two characters."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes and manipulating strings in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5108581185340881,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    \n    def generate_palindrome(length):\n        chars = string.ascii_lowercase\n        half_length = length // 2\n        first_half = ''.join(random.choice(chars) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    return generate_palindrome(random.randint(2, 10))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    \n    def generate_palindrome(length):\n        chars = string.ascii_lowercase\n        half_length = length // 2\n        first_half = ''.join(random.choice(chars) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    return generate_palindrome(random.randint(2, 10))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle consists of two functions, f(string: str) -> bool which checks if a given string is a palindrome, and g() -> str which generates a random palindrome string. The assert statement at the end verifies if the generated string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43233272433280945,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g(input_string=\"racecar\"):\n    return input_string[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to string manipulation and conditional logic.",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(input_string=\"racecar\"):\n    return input_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a string is a palindrome, and a function g that returns the reverse of a default string. The assertion tests if the reverse of the default string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.651289165019989,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))\n\ndef g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of tuples based on the second element of each tuple and then checking if the sorted list satisfies a specific condition.",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))",
        "solution_func": "def g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of tuples based on the second element of each tuple in ascending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that checks if a list of tuples is sorted based on the second element of each tuple in ascending order. The solution function generates random tuples, sorts them based on the second element, and then checks if the sorting is correct using the provided function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4684216380119324,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    string = \"radar\"\n    return string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    string = \"radar\"\n    return string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6649991273880005,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport sympy\n\ndef f(prime_nums: list) -> bool:\n    for num in prime_nums:\n        if num % 4 == 1:\n            return True\n    return False\n\ndef g():\n    primes = list(sympy.primerange(10, 30))\n    return primes\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if there exists a prime number in a given range that satisfies a specific condition.",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "import sympy\n\ndef f(prime_nums: list) -> bool:\n    for num in prime_nums:\n        if num % 4 == 1:\n            return True\n    return False",
        "solution_func": "def g():\n    primes = list(sympy.primerange(10, 30))\n    return primes",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if any prime number in a given list satisfies a specific condition, and a function g that generates a list of prime numbers within a certain range. The goal is to find a prime number in the generated list that satisfies the condition in function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with prime numbers, conditions, and function composition in Python. It requires understanding of list iteration, modulo operation, and prime number generation using sympy library.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5994933843612671,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sequence: list) -> bool:\n    for i in range(2, len(sequence)):\n        if sequence[i] != sequence[i-1] + sequence[i-2]:\n            return False\n    return True\n\ndef g():\n    sequence = [1, 1]\n    for i in range(2, 10):\n        sequence.append(sequence[i-1] + sequence[i-2])\n    return sequence\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for a specific pattern in the sequence.",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "def f(sequence: list) -> bool:\n    for i in range(2, len(sequence)):\n        if sequence[i] != sequence[i-1] + sequence[i-2]:\n            return False\n    return True",
        "solution_func": "def g():\n    sequence = [1, 1]\n    for i in range(2, 10):\n        sequence.append(sequence[i-1] + sequence[i-2])\n    return sequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(sequence: list) that checks if a given sequence follows a specific pattern, and a function g() that generates a sequence based on a specific rule. The puzzle tests if the generated sequence satisfies the pattern defined in function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to iterate over a sequence and check for a specific pattern. It also requires implementing a rule to generate a sequence based on the Fibonacci sequence. The solution function g() generates a sequence following the Fibonacci rule, and the function f(sequence) checks if the generated sequence satisfies the Fibonacci pattern.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.518729031085968,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves recursion and conditional logic to solve the climbing stairs problem. It also touches on mathematical operations with the use of addition and subtraction. Additionally, it can be considered as a Dynamic Programming problem as well.",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_partition(nums, index, sum1, sum2):\n        if index == len(nums):\n            return sum1 == sum2\n        \n        return can_partition(nums, index + 1, sum1 + nums[index], sum2) or can_partition(nums, index + 1, sum1, sum2 + nums[index])\n    \n    return can_partition(nums, 0, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True"
        ],
        "problem_func": "def f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)",
        "solution_func": "def g(n=3):\n    return n",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a person can climb stairs in 1 or 2 steps, and a function g that returns a fixed number. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves recursion and checking if a person can climb stairs in 1 or 2 steps. The solution function g always returns 3, which will not satisfy the condition of f. Therefore, this puzzle may not be suitable for teaching Python to master's students in CS as it does not effectively demonstrate Python concepts.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6360304951667786,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(cardinality: int) -> bool:\n    return cardinality == 2  # Cardinality of the intersection of two sets\n\ndef g():\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    intersection_set = set1.intersection(set2)\n    return len(intersection_set)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Set Operations, Conditional Logic",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    return prob == 3/8  # Probability of getting exactly 2 heads when flipping a fair coin 3 times\n\ndef g():\n    outcomes = list(itertools.product(['H', 'T'], repeat=3))\n    favorable_outcomes = [outcome.count('H') for outcome in outcomes].count(2)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "def f(cardinality: int) -> bool:\n    return cardinality == 2  # Cardinality of the intersection of two sets",
        "solution_func": "def g():\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    intersection_set = set1.intersection(set2)\n    return len(intersection_set)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the cardinality of the intersection of two sets and checking if it equals 2."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand sets, intersections, and cardinality in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5443176031112671,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(longest_length: int) -> bool:\n    return longest_length > 2\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Sorting and Ordering",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def max_subarray(nums):\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray(nums) > 0  \n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(longest_length: int) -> bool:\n    return longest_length > 2",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it is greater than 2."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding dynamic programming to find the longest increasing subsequence in a list of numbers and checking if its length is greater than 2.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4575760066509247,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(smallest_prime_factor: int, num=91) -> bool:\n    if smallest_prime_factor == 0:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i == smallest_prime_factor\n    return False\n\ndef g(num=91) -> int:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i\n    return 0\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Number Theory (factors, primes, etc.) and Conditional Logic.",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_length: int, nums=[4, 2, 3, 1, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == max_length\n\ndef g(nums=[4, 2, 3, 1, 5, 6]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(smallest_prime_factor: int, num=91) -> bool:\n    if smallest_prime_factor == 0:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i == smallest_prime_factor\n    return False",
        "solution_func": "def g(num=91) -> int:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i\n    return 0",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if a given number is divisible by its smallest prime factor, and g finds the smallest prime factor of a given number. The puzzle requires g to be called within f to check if the algorithm works correctly."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, divisibility, loops, and function calling in Python. It provides a practical application of finding the smallest prime factor of a number and checking divisibility.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6818735599517822,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum\n\ndef g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve a problem related to finding the maximum sum of non-adjacent numbers in a list. It also includes mathematical operations and conditional logic to determine the maximum sum. The solution function g() implements the dynamic programming approach to find the maximum sum.",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_length: int, nums=[4, 2, 3, 1, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == max_length\n\ndef g(nums=[4, 2, 3, 1, 5, 6]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum",
        "solution_func": "def g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of a subsequence of numbers in a list, where adjacent numbers cannot be included in the sum. The puzzle provides a function f(max_sum, nums) to check if a given maximum sum can be achieved from the list of numbers, and a function g(nums) to calculate the maximum sum of a subsequence from the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and challenges students to understand and implement the logic for finding the maximum sum of a subsequence with specific constraints. It is suitable for teaching Python programming and algorithmic thinking to master's students in CS.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4699147045612335,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6713948249816895,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(integers: list) -> bool:\n    if len(integers) < 3:\n        return False\n    diff = integers[1] - integers[0]\n    for i in range(2, len(integers)):\n        if integers[i] - integers[i - 1] != diff:\n            return False\n    return True\n\ndef g() -> list:\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of integers forms an arithmetic sequence.",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(subset: list, limit=100) -> bool:\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return set(subset).issubset(fibonacci)\n\ndef g(limit=100):\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(integers: list) -> bool:\n    if len(integers) < 3:\n        return False\n    diff = integers[1] - integers[0]\n    for i in range(2, len(integers)):\n        if integers[i] - integers[i - 1] != diff:\n            return False\n    return True",
        "solution_func": "def g() -> list:\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of integers forms an arithmetic sequence, and a function g that returns a specific arithmetic sequence. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for an arithmetic sequence in a list of integers and implementing a function to generate a specific arithmetic sequence. The assertion tests the correctness of the implementation by verifying if f(g()) returns True.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5952901840209961,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return vowels.issubset(set(s.lower()))\n\ndef g() -> str:\n    return \"Python is a versatile programming language.\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    try:\n        return len(nums) != len(set(nums))\n    except:\n        return False\n\ndef g() -> List[int]:\n    import random\n    length = random.randint(5, 10)\n    nums = [random.randint(1, 10) for _ in range(length)]\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return vowels.issubset(set(s.lower()))",
        "solution_func": "def g() -> str:\n    return \"Python is a versatile programming language.\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if the string returned by function g contains all the vowels (a, e, i, o, u) in a case-insensitive manner."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string contains all the vowels. The function f checks if the vowels are present in the string returned by function g. The assertion at the end confirms that the solution g satisfies the condition of containing all vowels.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.519736647605896,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(result: int) -> bool:\n    return result == sum(range(1, 11)) * 2\n\ndef g() -> int:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return sum(numbers) * 2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and list manipulation to calculate the sum of numbers from 1 to 10 and check if it is equal to a specific value.",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]\n\ndef g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(result: int) -> bool:\n    return result == sum(range(1, 11)) * 2",
        "solution_func": "def g() -> int:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return sum(numbers) * 2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function that checks if the result of summing numbers from 1 to 10 and multiplying by 2 is equal to a given input."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate the sum of a range of numbers and compare it to a given result.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5506529808044434,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Exception Handling and Mathematical Operations.",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]\n\ndef g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False",
        "solution_func": "def g() -> str:\n    return \"42\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num: int) -> bool and g() -> str. Function f checks if the input number is even by parsing it and returning True if it is even, and False otherwise. Function g returns the string '42'. The puzzle requires g to be called as an argument to f, and the assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves type conversion, exception handling, and checking for even numbers. It is a simple puzzle that tests the understanding of function calls and return values in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5897245407104492,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(permutation: tuple) -> bool:\n    return sum(permutation) == 10\n\ndef g() -> tuple:\n    numbers = [1, 2, 3, 4]\n    return next(itertools.permutations(numbers))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.)",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]\n\ndef g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(permutation: tuple) -> bool:\n    return sum(permutation) == 10",
        "solution_func": "def g() -> tuple:\n    numbers = [1, 2, 3, 4]\n    return next(itertools.permutations(numbers))",
        "quality": [
            null
        ],
        "description": [
            "Given a list of numbers [1, 2, 3, 4], the puzzle requires finding a permutation of these numbers such that their sum is equal to 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating permutations of the numbers [1, 2, 3, 4] and checking if the sum of the permutation is equal to 10.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5799437165260315,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves permutation and combination using itertools, as well as mathematical operations to check for a specific target value.",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False",
        "solution_func": "def g(arr=[10, 20, 25, 40, 50]):\n    return arr",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a subset of numbers from a given list whose product equals a target value, or a single number in the list equals the target value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of combinations, loops, and conditional statements in Python to find a subset of numbers that meet the specified condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5014512538909912,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(combinations_list: list, s='xyz') -> bool:\n    valid_combinations = []\n    for r in range(1, len(s)+1):\n        valid_combinations.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return set(combinations_list) == set(valid_combinations)\n\ndef g(s='xyz'):\n    combinations_list = []\n    for r in range(1, len(s)+1):\n        combinations_list.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return combinations_list\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(combinations_list: list, s='xyz') -> bool:\n    valid_combinations = []\n    for r in range(1, len(s)+1):\n        valid_combinations.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return set(combinations_list) == set(valid_combinations)",
        "solution_func": "def g(s='xyz'):\n    combinations_list = []\n    for r in range(1, len(s)+1):\n        combinations_list.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return combinations_list",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all possible combinations of characters in a given string and checking if a provided list of combinations matches the generated combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of itertools module in Python for generating combinations and set operations for comparison.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.36256933212280273,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    random_string = ''.join(random.choices(string.ascii_lowercase, k=10))\n    reversed_string = random_string[::-1]\n    return random_string + reversed_string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(sorted_list: List[int]) -> bool:\n    return all(sorted_list[i] <= sorted_list[i+1] for i in range(len(sorted_list) - 1))\n\ndef g(numbers=[4, 2, 2, 8, 3, 3, 1]):\n    max_num = max(numbers)\n    count_arr = [0] * (max_num + 1)\n\n    for num in numbers:\n        count_arr[num] += 1\n\n    sorted_list = []\n    for i in range(len(count_arr)):\n        sorted_list.extend([i] * count_arr[i])\n\n    return sorted_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    random_string = ''.join(random.choices(string.ascii_lowercase, k=10))\n    reversed_string = random_string[::-1]\n    return random_string + reversed_string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a random string and its reverse concatenated together. The puzzle requires g() to generate a palindrome string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically checking for palindromes and generating random strings. It can be used to teach students about string operations and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.41504478454589844,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef g(num=12321):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a number is a palindrome.",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    return str(num) == str(num)[::-1]",
        "solution_func": "def g(num=12321):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given number is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(num) that returns True if the input number is a palindrome, and a function g(num) that returns a specific number. The assertion checks if the output of g() satisfies the palindrome condition defined in f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.674001157283783,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0",
        "solution_func": "def g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of a subarray within a given list of numbers, and checking if the maximum sum is greater than 0."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming concepts to find the maximum sum of a subarray. The solution function returns a list of numbers, and the puzzle function checks if the maximum sum of a subarray in that list is greater than 0.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4526243209838867,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(text: str) -> bool:\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text).lower()\n    return cleaned_text == cleaned_text[::-1]\n\ndef g(text=\"A man, a plan, a canal, Panama!\"):\n    return text\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation using regular expressions and conditional logic for checking palindrome",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import re\n\ndef f(text: str) -> bool:\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text).lower()\n    return cleaned_text == cleaned_text[::-1]",
        "solution_func": "def g(text=\"A man, a plan, a canal, Panama!\"):\n    return text",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given text is a palindrome after removing non-alphanumeric characters and converting to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand string manipulation using regular expressions, string cleaning, and checking for palindromes.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.40324273705482483,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(result: int) -> bool:\n    if result < 2:\n        return False\n    for i in range(2, int(math.sqrt(result)) + 1):\n        if result % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    num = 2\n    while True:\n        if is_prime(num):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 43,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return result == factorial(5)\n\ndef g() -> int:\n    return 120\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(result: int) -> bool:\n    if result < 2:\n        return False\n    for i in range(2, int(math.sqrt(result)) + 1):\n        if result % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    num = 2\n    while True:\n        if is_prime(num):\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(result: int) that checks if a given integer is a prime number, and a function g() that finds and returns the next prime number starting from 2. The puzzle requires the student to understand prime numbers and implement a function to find the next prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, implementing a function to check for primality, and creating a function to find the next prime number. It tests the student's knowledge of loops, conditionals, and mathematical operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4801763594150543,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    max_product = max(nums[i] * nums[j] for i in range(len(nums)) for j in range(i + 1, len(nums)))\n    return max_product == max(nums) * sorted(nums)[-2]\n\ndef g():\n    import random\n    return [random.randint(1, 100) for _ in range(5)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": 43,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))\n\ndef g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    max_product = max(nums[i] * nums[j] for i in range(len(nums)) for j in range(i + 1, len(nums)))\n    return max_product == max(nums) * sorted(nums)[-2]",
        "solution_func": "def g():\n    import random\n    return [random.randint(1, 100) for _ in range(5)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that calculates the maximum product of pairs of numbers in a list and checks if this maximum product is equal to the product of the two largest numbers in the list. The solution function g generates a list of random integers, and the assertion checks if f applied to the output of g returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with lists, calculating products, and sorting elements. It also requires understanding list comprehensions and random number generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.49994224309921265,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(solution: List[List[int]]) -> bool:\n    def is_valid(num, i, j, board):\n        for x in range(9):\n            if board[i][x] == num or board[x][j] == num or board[3 * (i // 3) + x // 3][3 * (j // 3) + x % 3] == num:\n                return False\n        return True\n\n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(num, i, j, board):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve(solution)\n    for i in range(9):\n        if len(set(solution[i])) != 9 or len(set(row[i] for row in solution)) != 9:\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if len(set(solution[x][y] for x in range(i, i + 3) for y in range(j, j + 3))) != 9:\n                return False\n    return True\n\ndef g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sudoku Solver using Backtracking",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(solution: List[List[int]]) -> bool:\n    def is_valid(num, i, j, board):\n        for x in range(9):\n            if board[i][x] == num or board[x][j] == num or board[3 * (i // 3) + x // 3][3 * (j // 3) + x % 3] == num:\n                return False\n        return True\n\n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(num, i, j, board):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve(solution)\n    for i in range(9):\n        if len(set(solution[i])) != 9 or len(set(row[i] for row in solution)) != 9:\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if len(set(solution[x][y] for x in range(i, i + 3) for y in range(j, j + 3))) != 9:\n                return False\n    return True",
        "solution_func": "def g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a Sudoku solver algorithm implemented in Python. The function f checks if the given solution is a valid Sudoku solution, and the function g provides a sample Sudoku puzzle to be solved."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a Sudoku solver algorithm in Python, which can be a challenging and educational task for master's students in CS to understand algorithms and problem-solving. It also helps in practicing Python programming skills and understanding nested loops and recursion.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.40474623441696167,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    n_str = str(n)\n    return n_str == n_str[::-1]\n\ndef g() -> int:\n    import random\n    palindrome = random.randint(10, 99)  # Generate a 2-digit palindrome number\n    return int(str(palindrome) + str(palindrome)[::-1])\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a number is a palindrome. It also includes random number generation and assertion testing.",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    n_str = str(n)\n    return n_str == n_str[::-1]",
        "solution_func": "def g() -> int:\n    import random\n    palindrome = random.randint(10, 99)  # Generate a 2-digit palindrome number\n    return int(str(palindrome) + str(palindrome)[::-1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given integer is a palindrome, and a function g() that generates a 2-digit palindrome number. The assertion checks if the generated number is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in Python using string manipulation and generating random 2-digit palindrome numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5226542949676514,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not.",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function f(num: int) that checks if a given number is a prime number. The student also needs to define a function g() that returns the number 17. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number and returning a specific number. The student needs to understand how to define a function to check for prime numbers and how to return a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6403940916061401,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g():\n    return \"A man a plan a canal Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"A man a plan a canal Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing spaces and converting to lowercase. The solution function g returns a specific string, and the puzzle asserts that f applied to the output of g should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after removing spaces and converting to lowercase. The solution function returns a specific string that is a palindrome, satisfying the puzzle condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6178510189056396,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Mathematical Operations",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]",
        "solution_func": "def g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function f that calculates the minimum number of coins needed to make up a given amount using a given set of coin denominations. The solution function g calculates the minimum number of coins needed for a specific amount using specific coin denominations and checks if it matches the expected result."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming and coin change problem concepts in Python. It tests the understanding of implementing a solution to find the minimum number of coins needed to make up a given amount using a given set of coin denominations.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4513930380344391,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(common_elements: set, list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> bool:\n    return common_elements == set(list1) & set(list2)\n\ndef g(list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> set:\n    return set(list1) & set(list2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to find common elements between two lists.",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(common_elements: set, list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> bool:\n    return common_elements == set(list1) & set(list2)",
        "solution_func": "def g(list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> set:\n    return set(list1) & set(list2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, f and g. Function f checks if the common elements between two lists are equal to a given set. Function g returns the common elements between two lists as a set. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with sets and lists in Python to find common elements between two lists. It tests the understanding of set operations and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5948960781097412,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves binary operations (bitwise shifting, AND, OR) and mathematical operations.",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True"
        ],
        "problem_func": "def f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')",
        "solution_func": "def g(num=23) -> int:\n    return bin(num).count('1')",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if the number of set bits in a binary representation of a given number matches a specified value, and the second function calculates the number of set bits in the binary representation of a given number. The assertion statement checks if the first function returns True when called with the output of the second function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding binary representation, counting set bits, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6105204820632935,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 44,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num: int) -> bool and g() -> int. Function f checks if a given number is a prime number, and function g returns the number 17. The puzzle asserts that function f called with the result of function g should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number and returning a specific number. It tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6113287210464478,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix[0]))])\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a given matrix is symmetric along its diagonal. It requires understanding of nested lists, list comprehension, and boolean operations.",
        "idx_generation": 44,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix[0]))])",
        "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given matrix is symmetric along its main diagonal. The solution function g returns a specific matrix, and the puzzle is to verify if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, nested lists, and the all() function in Python. It also tests the concept of symmetry in matrices along the main diagonal.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5208056569099426,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(num_list: List[int]) -> bool:\n    return all([num_list[i] <= num_list[i + 1] for i in range(len(num_list) - 1)])\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list is sorted in ascending order using a list comprehension and the all() function.",
        "idx_generation": 44,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(num_list: List[int]) -> bool:\n    return all([num_list[i] <= num_list[i + 1] for i in range(len(num_list) - 1)])",
        "solution_func": "def g() -> List[int]:\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of integers is sorted in ascending order, and a function g that returns a specific list of integers. The assertion checks if the function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and the all() function in Python. It also tests the ability to define functions and use assertions for testing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5300095677375793,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(fibonacci_number: int, position=5) -> bool:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(position) == fibonacci_number\n\ndef g(position=5):\n    return position\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations to calculate the Fibonacci sequence. The solution simply returns the position value. The assertion checks if the Fibonacci number at the specified position matches the input Fibonacci number.",
        "idx_generation": 44,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(fibonacci_number: int, position=5) -> bool:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(position) == fibonacci_number",
        "solution_func": "def g(position=5):\n    return position",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to calculate the Fibonacci sequence at a specific position and checking if a given Fibonacci number matches the calculated value at that position."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of recursion and function calls in Python, specifically in the context of calculating Fibonacci numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5560587048530579,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(merged_intervals: List[List[int]], intervals=[[1, 3], [2, 6], [8, 10], [15, 18]]) -> bool:\n    if not merged_intervals:\n        return False\n    for i in range(1, len(merged_intervals)):\n        if merged_intervals[i][0] <= merged_intervals[i-1][1]:\n            return False\n    return True\n\ndef g(intervals=[[1, 3], [2, 6], [8, 10], [15, 18]]):\n    intervals.sort(key=lambda x: x[0])\n    merged_intervals = []\n    for interval in intervals:\n        if not merged_intervals or interval[0] > merged_intervals[-1][1]:\n            merged_intervals.append(interval)\n        else:\n            merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1])\n    return merged_intervals\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves merging intervals and checking for overlapping intervals. This requires knowledge of list manipulation, sorting, and conditional logic.",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(merged_intervals: List[List[int]], intervals=[[1, 3], [2, 6], [8, 10], [15, 18]]) -> bool:\n    if not merged_intervals:\n        return False\n    for i in range(1, len(merged_intervals)):\n        if merged_intervals[i][0] <= merged_intervals[i-1][1]:\n            return False\n    return True",
        "solution_func": "def g(intervals=[[1, 3], [2, 6], [8, 10], [15, 18]]):\n    intervals.sort(key=lambda x: x[0])\n    merged_intervals = []\n    for interval in intervals:\n        if not merged_intervals or interval[0] > merged_intervals[-1][1]:\n            merged_intervals.append(interval)\n        else:\n            merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1])\n    return merged_intervals",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves merging overlapping intervals in a list and checking if the merged intervals are valid."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function to merge overlapping intervals and then check if the merged intervals are valid by comparing them with the original intervals.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3267871141433716,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    random_str = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n    return random_str + random_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    random_str = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 7)))\n    return random_str + random_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(s: str) -> bool and g() -> str. Function f checks if a given string is a palindrome, while function g generates a random string and appends its reverse to it. The puzzle tests whether the generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated string, with its reverse appended to it, is a palindrome or not.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4541760981082916,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix[i]))])\n\ndef g() -> List[List[int]]:\n    import random\n    n = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[j][i] = matrix[i][j]\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves matrix manipulation and checking for symmetry. It also includes random number generation and list comprehension.",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    return all([matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix[i]))])",
        "solution_func": "def g() -> List[List[int]]:\n    import random\n    n = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[j][i] = matrix[i][j]\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random symmetric matrix and checking if the matrix satisfies a specific condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating a random symmetric matrix and checking if the elements in the matrix satisfy a specific condition based on their positions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.40911680459976196,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return all([nums[i + 1] - nums[i] == nums[1] - nums[0] for i in range(len(nums) - 1)])\n\ndef g() -> List[int]:\n    import random\n    start = random.randint(1, 5)\n    diff = random.randint(2, 5)\n    n = random.randint(3, 6)\n    return [start + i * diff for i in range(n)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and list manipulation to check for a specific pattern.",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    return all([nums[i + 1] - nums[i] == nums[1] - nums[0] for i in range(len(nums) - 1)])",
        "solution_func": "def g() -> List[int]:\n    import random\n    start = random.randint(1, 5)\n    diff = random.randint(2, 5)\n    n = random.randint(3, 6)\n    return [start + i * diff for i in range(n)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of integers with a specific arithmetic progression and checking if the list satisfies a certain condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to generate a list of integers with a specific arithmetic progression and then check if the generated list satisfies a condition based on the arithmetic progression.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43854349851608276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_valid_palindrome(s, left, right, can_remove):\n        while left < right:\n            if s[left] != s[right]:\n                if can_remove:\n                    return is_valid_palindrome(s, left + 1, right, False) or is_valid_palindrome(s, left, right - 1, False)\n                else:\n                    return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_valid_palindrome(s, 0, len(s) - 1, True)\n\ndef g() -> str:\n    import random\n    import string\n    s = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return s + s[-2::-1]  # Generate a palindrome by duplicating a random 3-letter string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Recursion",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(partition: list) -> bool:\n    def is_partitionable(arr, n, target_sum, sum_so_far, visited, start):\n        if sum_so_far == target_sum:\n            return True\n        if sum_so_far > target_sum:\n            return False\n        for i in range(start, n):\n            if not visited[i]:\n                visited[i] = True\n                if is_partitionable(arr, n, target_sum, sum_so_far + arr[i], visited, i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    total_sum = sum(partition)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(partition)\n    visited = [False] * n\n    return is_partitionable(partition, n, target_sum, 0, visited, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g()) == True\n",
            "\ndef f(n: int) -> bool:\n    n_str = str(n)\n    return n_str == n_str[::-1]\n\ndef g() -> int:\n    import random\n    palindrome = random.randint(10, 99)  # Generate a 2-digit palindrome number\n    return int(str(palindrome) + str(palindrome)[::-1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_valid_palindrome(s, left, right, can_remove):\n        while left < right:\n            if s[left] != s[right]:\n                if can_remove:\n                    return is_valid_palindrome(s, left + 1, right, False) or is_valid_palindrome(s, left, right - 1, False)\n                else:\n                    return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_valid_palindrome(s, 0, len(s) - 1, True)",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    s = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return s + s[-2::-1]  # Generate a palindrome by duplicating a random 3-letter string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string can be converted into a palindrome by removing at most one character."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion, string manipulation, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.32281792163848877,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact % 10 == 0\n\ndef g():\n    return 5  # Example number to calculate factorial\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Factorials, Mathematical Operations, Conditional Logic",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\ndef f(cardinality: int) -> bool:\n    return cardinality == 2  # Cardinality of the intersection of two sets\n\ndef g():\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    intersection_set = set1.intersection(set2)\n    return len(intersection_set)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact % 10 == 0",
        "solution_func": "def g():\n    return 5  # Example number to calculate factorial",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(n) that calculates the factorial of a given number and checks if the last digit of the factorial is 0. The solution function g() returns the number 5, and the puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the factorial of a number and checking the last digit. The solution function returns a specific number to test the factorial calculation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6890522241592407,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"racecar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome (reads the same forwards and backwards) by comparing the word to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(word) that checks if a word is a palindrome, and a function g() that returns the word 'racecar'. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5744696259498596,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(combo: str) -> bool:\n    return combo == 'ABC'\n\ndef g():\n    chars = ['A', 'B', 'C', 'D']\n    for r in range(1, len(chars) + 1):\n        for c in combinations(chars, r):\n            if ''.join(c) == 'ABC':\n                return 'ABC'\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and importing modules (Itertools). It also includes conditional logic and permutations and combinations.",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(combo: str) -> bool:\n    return combo == 'ABC'",
        "solution_func": "def g():\n    chars = ['A', 'B', 'C', 'D']\n    for r in range(1, len(chars) + 1):\n        for c in combinations(chars, r):\n            if ''.join(c) == 'ABC':\n                return 'ABC'",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a combination of characters from a given list that matches the string 'ABC'."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the itertools combinations function to generate all possible combinations of characters from a list and checking if any combination equals 'ABC'.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5038519501686096,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(num: int) -> bool:\n    return is_prime(num)\n\ndef g(num=17):\n    num += 1\n    while True:\n        if is_prime(num):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Mathematical Operations, Conditional Logic, Recursion, and Number Theory.",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nimport itertools\n\ndef f(perm: List[int]) -> bool:\n    return all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1))\n\ndef g(numbers=[5, 6, 3, 7, 4]):\n    # Generate all permutations of the input list\n    perms = itertools.permutations(numbers)\n    \n    # Find the permutation that forms a sequence of consecutive numbers\n    for perm in perms:\n        if all(abs(perm[i] - perm[i+1]) == 1 for i in range(len(perm) - 1)):\n            return list(perm)\n    return []\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(num: int) -> bool:\n    return is_prime(num)",
        "solution_func": "def g(num=17):\n    num += 1\n    while True:\n        if is_prime(num):\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given number is a prime number and finding the next prime number after a given number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and requires finding the next prime number after a given input.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5539065003395081,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sequence: List[int]) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] + sequence[i+1] == sequence[i+2] for i in range(len(sequence) - 2))\n\ndef g(length=10):\n    fibonacci = [0, 1]\n    while len(fibonacci) < length:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and sequence manipulation to check if the given sequence follows a specific pattern (Fibonacci sequence).",
        "idx_generation": 45,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sequence: List[int]) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] + sequence[i+1] == sequence[i+2] for i in range(len(sequence) - 2))",
        "solution_func": "def g(length=10):\n    fibonacci = [0, 1]\n    while len(fibonacci) < length:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that checks if a given list of integers follows a specific pattern. The solution generates a Fibonacci sequence up to a specified length and checks if it satisfies the pattern defined in the function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, iteration, and pattern recognition. The solution demonstrates generating a Fibonacci sequence and using it to satisfy the pattern condition in the function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4362120032310486,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str='racecar'):\n    return input_str + input_str[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 45,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str='racecar'):\n    return input_str + input_str[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it with its reverse. The solution function creates a palindrome by appending the reverse of the input string to itself."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and checking for palindromes in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5560576915740967,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list[int]) -> bool:\n    for a in numbers:\n        for b in numbers:\n            for c in numbers:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g(size: int = 5) -> list[int]:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Sample numbers where a Pythagorean triplet exists\n    return numbers[:size]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for Pythagorean triplets in a list of numbers using nested loops and mathematical operations.",
        "idx_generation": 45,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list[int]) -> bool:\n    for a in numbers:\n        for b in numbers:\n            for c in numbers:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False",
        "solution_func": "def g(size: int = 5) -> list[int]:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Sample numbers where a Pythagorean triplet exists\n    return numbers[:size]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet in a given list of numbers using nested loops and checking if the sum of squares of two numbers is equal to the square of the third number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Pythagorean triplets and nested loops in Python to check for the condition. The solution function g() returns a subset of numbers from a predefined list to test the algorithm.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4600459337234497,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 45,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    mean = np.mean(nums)\n    std_dev = np.std(nums)\n    return np.isclose(mean, 0, atol=0.1) and np.isclose(std_dev, 1, atol=0.1)\n\ndef g(size: int = 1000) -> np.ndarray:\n    return np.random.normal(loc=0, scale=1, size=size)\n\nassert f(g()) == True\n",
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]",
        "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given text is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase. The solution function g returns a specific text that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is suitable for teaching Python programming concepts such as string manipulation, palindrome checking, list comprehension, and function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5015936493873596,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def largest_prime_factor(num):\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n        return num\n\n    return is_prime(largest_prime_factor(number))\n\ndef g(number=84):\n    return number\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    if solve():\n        return True\n    return False\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(number: int) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def largest_prime_factor(num):\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n        return num\n\n    return is_prime(largest_prime_factor(number))",
        "solution_func": "def g(number=84):\n    return number",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the largest prime factor of a given number is a prime number. The solution function g simply returns a specified number. The puzzle is to determine if the largest prime factor of the specified number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, prime factorization, and function composition in Python. It requires understanding how to check for prime numbers and find the largest prime factor of a number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6265356540679932,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(removals: int, string=\"radar\") -> bool:\n    return removals == 0\n\ndef g(string=\"radar\"):\n    def min_removals_palindrome(s):\n        from collections import Counter\n        char_count = Counter(s)\n        odd_count = sum(count % 2 for count in char_count.values())\n        return max(0, odd_count - 1)\n    \n    return min_removals_palindrome(string)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4) -> bool:\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True\ndef g(items = [5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length = 4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]\nassert f(g()) == True"
        ],
        "problem_func": "def f(removals: int, string=\"radar\") -> bool:\n    return removals == 0",
        "solution_func": "def g(string=\"radar\"):\n    def min_removals_palindrome(s):\n        from collections import Counter\n        char_count = Counter(s)\n        odd_count = sum(count % 2 for count in char_count.values())\n        return max(0, odd_count - 1)\n    \n    return min_removals_palindrome(string)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the minimum number of character removals needed to make a given string a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to calculate the minimum number of character removals required to make a string a palindrome and then checking if this function satisfies the condition set by the puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.44160497188568115,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g(length=5):\n    return \"a\" * length + \"b\" + \"a\" * length\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 46,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(length=5):\n    return \"a\" * length + \"b\" + \"a\" * length",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a string generated by function g() is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f() that checks if a given string is a palindrome, and a function g() that generates a specific string. The assertion tests if the string generated by g() is a palindrome using f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6085494160652161,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr: List[int]) -> bool:\n        arr = [x for x in arr if x != 0]\n        return len(arr) == len(set(arr))\n    \n    n = 9\n    for i in range(n):\n        if not is_valid(board[i]):\n            return False\n        \n        if not is_valid([board[j][i] for j in range(n)]):\n            return False\n        \n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            subgrid = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n            if not is_valid(subgrid):\n                return False\n    \n    return True\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires understanding of list manipulation, iteration, and validation. It also involves checking rows, columns, and subgrids for uniqueness of numbers.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n",
            "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr: List[int]) -> bool:\n        arr = [x for x in arr if x != 0]\n        return len(arr) == len(set(arr))\n    \n    n = 9\n    for i in range(n):\n        if not is_valid(board[i]):\n            return False\n        \n        if not is_valid([board[j][i] for j in range(n)]):\n            return False\n        \n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            subgrid = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n            if not is_valid(subgrid):\n                return False\n    \n    return True",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not based on the rules of Sudoku. The function f(board) checks if the board is valid by ensuring each row, column, and 3x3 subgrid contains unique numbers from 1 to 9. The function g() provides a sample 9x9 Sudoku board to be checked for validity."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a function to check the validity of a Sudoku board, which can be a good exercise for practicing list manipulation and nested loops in Python. It also reinforces the concept of checking conditions and returning boolean values based on the conditions met.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.34118518233299255,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(ip_addresses: List[str]) -> bool:\n    def is_valid(segment):\n        if segment[0] == '0':\n            return len(segment) == 1\n        return 0 <= int(segment) <= 255\n\n    def restore_ip_addresses(s):\n        def backtrack(start, path):\n            if len(path) == 4:\n                if start == len(s):\n                    ip_addresses.append('.'.join(path))\n                return\n            for size in range(1, 4):\n                if start + size <= len(s):\n                    segment = s[start:start + size]\n                    if is_valid(segment):\n                        backtrack(start + size, path + [segment])\n\n        ip_addresses = []\n        backtrack(0, [])\n        return ip_addresses\n\n    return restore_ip_addresses(\"25525511135\") == ip_addresses\n\ndef g():\n    return [\"255.255.11.135\", \"255.255.111.35\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves backtracking to generate valid IP addresses from a given string. It also includes string manipulation and conditional logic to check the validity of segments. The solution function g() returns a list of valid IP addresses.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(ip_addresses: List[str]) -> bool:\n    def is_valid(segment):\n        if segment[0] == '0':\n            return len(segment) == 1\n        return 0 <= int(segment) <= 255\n\n    def restore_ip_addresses(s):\n        def backtrack(start, path):\n            if len(path) == 4:\n                if start == len(s):\n                    ip_addresses.append('.'.join(path))\n                return\n            for size in range(1, 4):\n                if start + size <= len(s):\n                    segment = s[start:start + size]\n                    if is_valid(segment):\n                        backtrack(start + size, path + [segment])\n\n        ip_addresses = []\n        backtrack(0, [])\n        return ip_addresses\n\n    return restore_ip_addresses(\"25525511135\") == ip_addresses",
        "solution_func": "def g():\n    return [\"255.255.11.135\", \"255.255.111.35\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that takes a list of IP addresses as input and checks if a specific IP address can be restored from a given string. The solution function generates a list of valid IP addresses from a given string and compares it with the input list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, backtracking, and validation of IP address segments. The solution function uses backtracking to generate all possible valid IP addresses from a given string and compares it with the input list to check if the specific IP address can be restored.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3655124008655548,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(merged_intervals: List[List[int]]) -> bool:\n    def merge_intervals(intervals):\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged\n\n    return merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) == merged_intervals\n\ndef g():\n    return [[1, 6], [8, 10], [15, 18]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves merging intervals in a list, which falls under the topic of Sorting and Ordering. The solution involves implementing a function to merge intervals and then checking if the merged intervals match a given list of intervals.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(merged_intervals: List[List[int]]) -> bool:\n    def merge_intervals(intervals):\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged\n\n    return merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) == merged_intervals",
        "solution_func": "def g():\n    return [[1, 6], [8, 10], [15, 18]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves merging intervals in a list and checking if the merged intervals match a given list of intervals."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that merges intervals in a list and compare the result with a predefined list of intervals.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.426772803068161,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and random sampling, which can be categorized under topics such as Set Operations and Importing Modules (Itertools, etc.).",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(lst: List[int]) -> bool:\n    return len(lst) != len(set(lst))\n\ndef g() -> List[int]:\n    import random\n    return random.choices(range(1, 10), k=5)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(common_elements: set, list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> bool:\n    return common_elements == set(list1) & set(list2)\n\ndef g(list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> set:\n    return set(list1) & set(list2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)",
        "solution_func": "def g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given set is a subset of a predefined set, and a function g that generates a random set of 5 numbers between 1 and 9. The puzzle requires ensuring that the generated set is a subset of the predefined set."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of sets, subset checking, random number generation, and function definition in Python. It provides a practical application of these concepts in a programming challenge.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5104464292526245,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Set\n\ndef f(sym_diff: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return sym_diff == set1.symmetric_difference(set2)\n\ndef g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations, specifically symmetric difference operation. The solution function uses the symmetric difference operation to find the symmetric difference between two sets and check if it matches a given set.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import Set\n\ndef f(sym_diff: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return sym_diff == set1.symmetric_difference(set2)",
        "solution_func": "def g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return set1.symmetric_difference(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the symmetric difference of two sets is equal to a given set, and a function g that returns the symmetric difference of two predefined sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets and the symmetric difference operation in Python. It requires students to implement a function that compares sets and uses the symmetric difference method.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5229928493499756,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    return set(combinations_list) == {('a', 'b'), ('a', 'c'), ('b', 'c')}\n\ndef g(chars=['a', 'b', 'c'], length=2) -> List[str]:\n    return list(combinations(chars, length))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves using the itertools module to generate combinations and checking if the generated combinations match a specific set.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    return set(combinations_list) == {('a', 'b'), ('a', 'c'), ('b', 'c')}",
        "solution_func": "def g(chars=['a', 'b', 'c'], length=2) -> List[str]:\n    return list(combinations(chars, length))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating combinations of characters and checking if a specific set of combinations is present."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to generate combinations of characters and compare them to a predefined set of combinations to determine if they match.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4704456627368927,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result\n\ndef g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves bitwise operations (AND) and comparison of binary numbers.",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result",
        "solution_func": "def g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given bitwise AND result matches the result of performing bitwise AND operation on a list of binary numbers. The solution function g calculates the bitwise AND result of a list of binary numbers and returns it."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding bitwise AND operation and comparing results. It is a good puzzle to teach Python programming concepts related to bitwise operations and list manipulation.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46348169445991516,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    letters = string.ascii_lowercase\n    length = random.randint(3, 9)\n    half_length = length // 2\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    return palindrome_half + (palindrome_half[:-1])[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 46,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    return all(num % 2 == 0 for num in lst)\n\ndef g() -> list:\n    import random\n    return [random.randint(1, 100) * 2 for _ in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    letters = string.ascii_lowercase\n    length = random.randint(3, 9)\n    half_length = length // 2\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    return palindrome_half + (palindrome_half[:-1])[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string, checking if it is a palindrome, and then verifying the result using the provided functions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.44522926211357117,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (primes) and Importing Modules (Sympy).",
        "idx_generation": 46,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    return all(num % 2 == 0 for num in lst)\n\ndef g() -> list:\n    import random\n    return [random.randint(1, 100) * 2 for _ in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    import random\n    import sympy\n    return sympy.randprime(1, 100)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g() that generates a random prime number between 1 and 100. The puzzle requires ensuring that the generated random prime number satisfies the prime number check in function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, generating random numbers, and using a library function to check for primality. It provides a practical application of prime number generation and checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6264944076538086,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(longest_length: int) -> bool:\n    return longest_length == 4\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the length of the longest increasing subsequence in a list of numbers.",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)\n\ndef g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(longest_length: int) -> bool:\n    return longest_length == 4",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it equals 4."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a dynamic programming solution to find the length of the longest increasing subsequence in a list of numbers and then check if it equals 4.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4957108199596405,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    random_str = ''.join(random.choices(string.ascii_lowercase, k=10))\n    palindrome = random_str + random_str[::-1]  # Creating a palindrome\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a given string is a palindrome. It also involves importing modules (random and string) to generate random strings for testing the palindrome function.",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    random_str = ''.join(random.choices(string.ascii_lowercase, k=10))\n    palindrome = random_str + random_str[::-1]  # Creating a palindrome\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding palindrome strings and string manipulation in Python. It provides a practical application of checking for palindromes and generating palindrome strings using random characters.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.46267053484916687,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]\n\ndef g(s='A man, a plan, a canal: Panama'):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]",
        "solution_func": "def g(s='A man, a plan, a canal: Panama'):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "Given a string, the puzzle checks if the string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using regular expressions to remove non-alphanumeric characters and checking if the resulting string is a palindrome. The solution function returns a specific string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48646238446235657,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(coords: List[List[int]]) -> bool:\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    d = set()\n    for i in range(len(coords)):\n        for j in range(i + 1, len(coords)):\n            d.add(distance(coords[i], coords[j]))\n    return len(d) == 2 and 0 not in d\n\ndef g(coords=[[0, 0], [0, 1], [1, 1], [1, 0]]):\n    return coords\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves geometry and coordinate manipulation to calculate distances between points and check for a specific condition. It also uses set operations to store unique distances. Additionally, it includes conditional logic to check the final condition. The solution simply returns the given coordinates. The assert statement is used for testing the solution.",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(coords: List[List[int]]) -> bool:\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    d = set()\n    for i in range(len(coords)):\n        for j in range(i + 1, len(coords)):\n            d.add(distance(coords[i], coords[j]))\n    return len(d) == 2 and 0 not in d",
        "solution_func": "def g(coords=[[0, 0], [0, 1], [1, 1], [1, 0]]):\n    return coords",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a set of coordinates forms a square by calculating the distances between all pairs of coordinates and checking if there are exactly 2 unique distances and none of them are zero."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle challenges students to understand nested loops, set operations, and distance calculation in Python. The solution function g simply returns a set of coordinates.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.39433109760284424,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(random.randint(3, 8)))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g() -> List[int]:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    n = random.randint(3, 7)\n    return [start + i * diff for i in range(n)]\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=7):\n    return num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(random.randint(3, 8)))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(text: str) -> bool checks if a given text is a palindrome, and g() -> str generates a random word followed by its reverse. The puzzle tests whether the generated word is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated word and its reverse is a palindrome. The solution function g() generates a random word followed by its reverse, and the puzzle function f(text: str) checks if the text is a palindrome.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3902871012687683,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence_len: int) -> bool:\n    return subsequence_len == 4\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Dynamic Programming and List Manipulation.",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence_len: int) -> bool:\n    return subsequence_len == 4",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it equals 4."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a dynamic programming solution to find the length of the longest increasing subsequence in a list of numbers and then check if it equals 4.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5004369616508484,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a string is a palindrome.",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6713942289352417,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lcs_length: int, text1=\"abcde\", text2=\"ace\") -> bool:\n    def longest_common_subsequence(text1, text2):\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    return longest_common_subsequence(text1, text2) == lcs_length\n\ndef g(text1=\"abcde\", text2=\"ace\") -> int:\n    def longest_common_subsequence(text1, text2):\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    return longest_common_subsequence(text1, text2)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and dynamic programming.",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lcs_length: int, text1=\"abcde\", text2=\"ace\") -> bool:\n    def longest_common_subsequence(text1, text2):\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    return longest_common_subsequence(text1, text2) == lcs_length",
        "solution_func": "def g(text1=\"abcde\", text2=\"ace\") -> int:\n    def longest_common_subsequence(text1, text2):\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    return longest_common_subsequence(text1, text2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where function f checks if the length of the longest common subsequence between two given texts is equal to a specified length, and function g calculates the length of the longest common subsequence between the same texts."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle provides a challenge related to dynamic programming and finding the longest common subsequence between two texts. The solution function g calculates this length, and the puzzle function f checks if the calculated length matches the specified length.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3218189775943756,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(graph: List[int]) -> bool:\n    def has_cycle(graph):\n        visited = [0] * len(graph)\n        for i in range(len(graph)):\n            if not visited[i]:\n                if dfs_cycle(graph, i, visited):\n                    return True\n        return False\n\n    def dfs_cycle(graph, node, visited):\n        visited[node] = 1\n        if visited[graph[node]] == 1:\n            return True\n        if visited[graph[node]] == 0:\n            return dfs_cycle(graph, graph[node], visited)\n        visited[node] = 2\n        return False\n\n    return has_cycle(graph)\n\ndef g() -> List[int]:\n    return [1, 2, 0, 3, 4, 2]  # Example of a graph with a cycle 2 -> 0 -> 1 -> 2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    def bfs(start, end):\n        queue = [start]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            visited.add(node)\n            for neighbor in [(node[0] + 1, node[1]), (node[0] - 1, node[1]), (node[0], node[1] + 1), (node[0], node[1] - 1)]:\n                if neighbor[0] >= 0 and neighbor[0] < len(grid) and neighbor[1] >= 0 and neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0 and neighbor not in visited:\n                    queue.append(neighbor)\n        return False\n\n    start, end = (0, 0), (len(grid) - 1, len(grid[0]) - 1)\n    return bfs(start, end)\n\ndef g():\n    return [[0, 0, 0], [1, 1, 0], [0, 0, 0]]\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result\n\ndef g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(graph: List[int]) -> bool:\n    def has_cycle(graph):\n        visited = [0] * len(graph)\n        for i in range(len(graph)):\n            if not visited[i]:\n                if dfs_cycle(graph, i, visited):\n                    return True\n        return False\n\n    def dfs_cycle(graph, node, visited):\n        visited[node] = 1\n        if visited[graph[node]] == 1:\n            return True\n        if visited[graph[node]] == 0:\n            return dfs_cycle(graph, graph[node], visited)\n        visited[node] = 2\n        return False\n\n    return has_cycle(graph)",
        "solution_func": "def g() -> List[int]:\n    return [1, 2, 0, 3, 4, 2]  # Example of a graph with a cycle 2 -> 0 -> 1 -> 2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given graph has a cycle or not using depth-first search (DFS) algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of graph traversal and cycle detection using DFS in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.38163772225379944,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import permutations\n\ndef f(s: str) -> bool:\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n\n    for r in range(1, len(s) + 1):\n        for subset in permutations(s, r):\n            if is_palindrome(''.join(subset)):\n                return True\n    return False\n\ndef g(s='racecar'):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, String Manipulation",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "from itertools import permutations\n\ndef f(s: str) -> bool:\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n\n    for r in range(1, len(s) + 1):\n        for subset in permutations(s, r):\n            if is_palindrome(''.join(subset)):\n                return True\n    return False",
        "solution_func": "def g(s='racecar'):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if there exists a palindrome substring in a given string by generating all possible substrings and checking if any of them is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of string manipulation, permutations, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3511603772640228,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Number Theory (factors, primes, etc.)",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False",
        "solution_func": "def g(numbers=[2, 3, 5, 7, 4]):\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a subset of numbers from a given list such that the product of the subset is a perfect square."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking all possible subsets of the given list of numbers and determining if the product of any subset is a perfect square.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.470898300409317,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: int, num=12321) -> bool:\n    return str(palindrome) == str(palindrome)[::-1]\n\ndef g(num=12321) -> int:\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(smallest_prime_factor: int, num=91) -> bool:\n    if smallest_prime_factor == 0:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i == smallest_prime_factor\n    return False\n\ndef g(num=91) -> int:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i\n    return 0\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: int, num=12321) -> bool:\n    return str(palindrome) == str(palindrome)[::-1]",
        "solution_func": "def g(num=12321) -> int:\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to check if a given number is a palindrome, and another function to find the next palindrome number after a given number. The assertion at the end checks if the second function correctly finds the next palindrome number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, loops, and function composition in Python. It tests the understanding of palindrome numbers and algorithmic thinking.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6238730549812317,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    length = random.randint(5, 10)\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    palindrome_half = ''.join(random.choices(letters, k=half_length))\n    if length % 2 == 0:\n        return palindrome_half + palindrome_half[::-1]\n    else:\n        return palindrome_half + random.choice(letters) + palindrome_half[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    length = random.randint(5, 10)\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    palindrome_half = ''.join(random.choices(letters, k=half_length))\n    if length % 2 == 0:\n        return palindrome_half + palindrome_half[::-1]\n    else:\n        return palindrome_half + random.choice(letters) + palindrome_half[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and checking if it is a palindrome by comparing it with its reverse. The solution function generates a random string that is either a palindrome or not, and the puzzle function checks if the generated string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.42022088170051575,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(10))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(10))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome and a function g() that generates a random string and its reverse, the puzzle requires finding a string that is a palindrome of its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.42442992329597473,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(palindrome: str, strings=['race', 'car', 'level']) -> bool:\n    all_permutations = [''.join(p) for p in itertools.permutations(strings)]\n    return palindrome in all_permutations or palindrome[::-1] in all_permutations\n\ndef g(strings=['race', 'car', 'level']):\n    return ''.join(strings)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, String Manipulation",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(combinations: list, list1=[1, 2, 3], list2=['a', 'b']) -> bool:\n    all_combinations = list(itertools.product(list1, list2))\n    return set(combinations) == set(all_combinations)\n\ndef g(list1=[1, 2, 3], list2=['a', 'b']):\n    return list(itertools.product(list1, list2))\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(palindrome: str, strings=['race', 'car', 'level']) -> bool:\n    all_permutations = [''.join(p) for p in itertools.permutations(strings)]\n    return palindrome in all_permutations or palindrome[::-1] in all_permutations",
        "solution_func": "def g(strings=['race', 'car', 'level']):\n    return ''.join(strings)",
        "quality": [
            null
        ],
        "description": [
            "Given a list of strings, the puzzle checks if a given palindrome string is a permutation of any combination of the strings in the list or their reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating all permutations of the strings in the list and checking if the given palindrome string is present in any of these permutations or their reverse. The solution function simply joins the strings in the list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4278515875339508,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(factorial_result: int) -> bool:\n    return factorial_result % 10 == 0\n\ndef g(number=5) -> int:\n    return math.factorial(number)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations (index 1) and importing modules (index 12).",
        "idx_generation": 49,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    return all(num % 2 == 0 for num in lst)\n\ndef g() -> list:\n    import random\n    return [random.randint(1, 100) * 2 for _ in range(5)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(subset: List[int], target_sum=50) -> bool:\n    return sum(subset) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30], target_sum=50):\n    # brute force approach to find subset sum\n    import itertools\n    for r in range(1, len(numbers) + 1):\n        for subset in itertools.combinations(numbers, r):\n            if sum(subset) == target_sum:\n                return list(subset)\n    return []\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(factorial_result: int) -> bool:\n    return factorial_result % 10 == 0",
        "solution_func": "def g(number=5) -> int:\n    return math.factorial(number)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the last digit of the factorial of a given number is 0."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to calculate the factorial of a number and check if the last digit is 0.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6880483031272888,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum, target_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index], target_sum) or can_partition(nums, index + 1, current_sum, target_sum)\n\n    return can_partition(nums, 0, 0, target_sum)\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion, conditional logic, and backtracking to solve the problem of partitioning a list into two equal sum subsets.",
        "idx_generation": 49,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(board, row):\n        return len(set(board[row])) == len(board[row])\n\n    def is_valid_col(board, col):\n        return len(set(row[col] for row in board)) == len(board)\n\n    def is_valid_subgrid(board, row, col):\n        subgrid = [board[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n        return len(set(subgrid)) == len(subgrid)\n\n    for i in range(9):\n        if not is_valid_row(board, i) or not is_valid_col(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(board, i, j):\n                return False\n\n    return True\n\ndef g():\n    import random\n\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve_sudoku(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    sudoku_board = [[0 for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum, target_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index], target_sum) or can_partition(nums, index + 1, current_sum, target_sum)\n\n    return can_partition(nums, 0, 0, target_sum)",
        "solution_func": "def g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(nums: List[int]) that checks if a given list of integers can be partitioned into two sublists with equal sum. The function g() returns a specific list of integers to test the partitioning."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and list manipulation in Python to check if a list can be partitioned into two sublists with equal sum.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3820003569126129,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(s)\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and recursion to check if a given string is a palindrome.",
        "idx_generation": 49,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(s)",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(s: str) that checks if a given string is a palindrome recursively. The solution function g() returns the string 'radar', and the puzzle is solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and checking for palindromes in strings. It is a good exercise for students to practice recursion and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5041254758834839,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 49,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6713939905166626,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not.",
        "idx_generation": 49,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(num) that checks if a number is prime, write a function g() that returns the number 17 and assert that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(num) that checks if a number is prime, and then defining a function g() that returns the number 17. The puzzle requires students to understand prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.7129145264625549,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid_sudoku(grid):\n        def is_valid_row(row):\n            return len(set(row)) == 9 and all(1 <= num <= 9 for num in row)\n\n        def is_valid_col(col):\n            return len(set(col)) == 9 and all(1 <= num <= 9 for num in col)\n\n        def is_valid_box(box):\n            flat_box = [num for sublist in box for num in sublist]\n            return len(set(flat_box)) == 9 and all(1 <= num <= 9 for num in flat_box)\n\n        for row in grid:\n            if not is_valid_row(row):\n                return False\n\n        for col in zip(*grid):\n            if not is_valid_col(col):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not is_valid_box([box]):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(grid)\n\ndef g():\n    return [[5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku grid, which requires knowledge of list manipulation, iteration, and set operations.",
        "idx_generation": 50,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid_sudoku(grid):\n        def is_valid_row(row):\n            return len(set(row)) == 9 and all(1 <= num <= 9 for num in row)\n\n        def is_valid_col(col):\n            return len(set(col)) == 9 and all(1 <= num <= 9 for num in col)\n\n        def is_valid_box(box):\n            flat_box = [num for sublist in box for num in sublist]\n            return len(set(flat_box)) == 9 and all(1 <= num <= 9 for num in flat_box)\n\n        for row in grid:\n            if not is_valid_row(row):\n                return False\n\n        for col in zip(*grid):\n            if not is_valid_col(col):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not is_valid_box([box]):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(grid)",
        "solution_func": "def g():\n    return [[5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 grid represents a valid Sudoku solution."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of nested functions, list manipulation, and Sudoku rules. The solution function g provides a valid Sudoku grid as input to the puzzle function f, which checks if the grid is a valid Sudoku solution.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.42230290174484253,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 50,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n",
            "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"racecar\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, provide a solution g() that returns the string 'racecar' to satisfy the palindrome check."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to understand how to define a function that checks for palindromes and provide a specific string that is a palindrome to pass the check.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6328021883964539,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_of_elements: int, nums={20, 30, 40, 15}) -> bool:\n    return sum_of_elements > 100\n\ndef g(nums={20, 30, 40, 15}) -> int:\n    return sum(nums)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 50,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g(size=5) -> list:\n    return [random.randint(1, 10) for _ in range(size)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_of_elements: int, nums={20, 30, 40, 15}) -> bool:\n    return sum_of_elements > 100",
        "solution_func": "def g(nums={20, 30, 40, 15}) -> int:\n    return sum(nums)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where f checks if the sum of elements in a set is greater than 100, and g calculates the sum of elements in a set. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is about checking if the sum of elements in a set is greater than 100 using two functions. The solution function calculates the sum of elements in the set and the puzzle function checks if this sum is greater than 100.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6432791948318481,
        "judgeLM-7b-abs_finetuning": 7.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(matrix: list) -> bool:\n    return all(len(row) == len(matrix) for row in matrix) and all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))\n\ndef g(size=3, symmetric=True) -> list:\n    import random\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    if symmetric:\n        for i in range(size):\n            for j in range(i):\n                matrix[i][j] = matrix[j][i]\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal. The solution generates a random matrix of a specified size and optionally makes it symmetric. The algorithmic challenge involves understanding matrix symmetry and generating random matrices.",
        "idx_generation": 50,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(matrix: list) -> bool:\n    return all(len(row) == len(matrix) for row in matrix) and all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))",
        "solution_func": "def g(size=3, symmetric=True) -> list:\n    import random\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    if symmetric:\n        for i in range(size):\n            for j in range(i):\n                matrix[i][j] = matrix[j][i]\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given matrix is symmetric, and a function g that generates a random matrix of a specified size and symmetry. The assertion at the end checks if the generated matrix satisfies the symmetry condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding matrix symmetry and generating random matrices. It tests the student's knowledge of list comprehension, matrix operations, and boolean conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48002347350120544,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom math import factorial\n\ndef f(result: int) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(sum(int(digit) for digit in str(result)))\n\ndef g(number=5) -> int:\n    return factorial(number)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory (primality check).",
        "idx_generation": 50,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    return arr == sorted(arr)\n\ndef g(length=5) -> list:\n    import random\n    return sorted(random.sample(range(1, 20), length))\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True"
        ],
        "problem_func": "from math import factorial\n\ndef f(result: int) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(sum(int(digit) for digit in str(result)))",
        "solution_func": "def g(number=5) -> int:\n    return factorial(number)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function that checks if the sum of the digits of the factorial of a given number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for prime numbers and calculating factorials of numbers in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.595650315284729,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(fib_num: int, index=6) -> bool:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) <= index:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_num == fib_sequence[index]\n\ndef g(index=6) -> int:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) <= index:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence[index]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Fibonacci sequence generation and comparison, which falls under Mathematical Operations and Sequence Generation.",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(min_coins: int, amount=11, coins=[1, 2, 5]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return min_coins == dp[amount]\n\ndef g(amount=11, coins=[1, 2, 5]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(fib_num: int, index=6) -> bool:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) <= index:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_num == fib_sequence[index]",
        "solution_func": "def g(index=6) -> int:\n    fib_sequence = [0, 1]\n    while len(fib_sequence) <= index:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence[index]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, related to Fibonacci sequences. Function f checks if a given Fibonacci number matches the number at a specific index in the Fibonacci sequence up to that index. Function g generates the Fibonacci number at a specific index. The puzzle tests if function f returns True when given the output of function g as input."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding Fibonacci sequences and function composition in Python. It tests the student's ability to work with functions and algorithmic challenges related to Fibonacci numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.48620450496673584,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Binary Operations, Data Structures",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result\n\ndef g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result\n\nassert f(g()) == True\n"
        ],
        "problem_func": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)",
        "solution_func": "def g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given binary tree is symmetric by comparing the left and right subtrees recursively."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of binary trees, recursion, and conditional statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.32230815291404724,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(strings: list) -> bool:\n    return max(strings, key=len) == max(strings, key=len)\n\ndef g(size=3):\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 15))) for _ in range(size)]\n    return strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and random generation of strings. The solution checks if the longest string in the list is the same as the longest string in the list.",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums_set = set(nums)\n    for a in nums_set:\n        for b in nums_set:\n            if a != b:\n                c = (a**2 + b**2) ** 0.5\n                if c in nums_set:\n                    return True\n    return False\n\ndef g(nums=[3, 5, 12, 13, 8]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(strings: list) -> bool:\n    return max(strings, key=len) == max(strings, key=len)",
        "solution_func": "def g(size=3):\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 15))) for _ in range(size)]\n    return strings",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if the longest string in a list of randomly generated strings is equal to the longest string in the same list. The solution function g generates a list of random strings of varying lengths."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle may not be suitable for teaching Python to master's students in CS as the condition in function f is always True, making it trivial and not challenging for students to solve.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.41271692514419556,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    palindrome = \"racecar\"  # Example palindrome string\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a given string is a palindrome.",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(volume: float, vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]) -> bool:\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6 - volume) < 1e-6\n\ndef g(vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]):\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    palindrome = \"racecar\"  # Example palindrome string\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s: str) that returns True if the input string is a palindrome. The solution function g() returns a hardcoded palindrome string 'racecar'. The assert statement checks if f(g()) returns True for the given palindrome string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6490563154220581,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17  # Example prime number\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a given number is a prime number or not. It uses a simple algorithm to iterate through numbers up to the square root of the given number to check for divisibility. The solution function returns a prime number (in this case, 17) and the puzzle function checks if it is a prime number.",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\ndef f(volume: float, vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]) -> bool:\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6 - volume) < 1e-6\n\ndef g(vertices=[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]):\n    def det(a, b, c):\n        return a[0]*(b[1]*c[2]-b[2]*c[1]) - a[1]*(b[0]*c[2]-b[2]*c[0]) + a[2]*(b[0]*c[1]-b[1]*c[0])\n    \n    return abs(det(vertices[1], vertices[2], vertices[3]) / 6)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    num = 17  # Example prime number\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g() that returns a specific number (in this case, 17). The puzzle tests whether the function f correctly identifies the number returned by g as a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to check for primality. It also requires knowledge of function definitions and function calls in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6642946600914001,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] >= end:\n            end = interval[1]\n        else:\n            return False\n    return True\n\ndef g(intervals: List[List[int]] = [[1, 2], [2, 3], [3, 4], [4, 5]]):\n    return intervals\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting intervals and checking for overlapping intervals. This relates to topics such as Sorting and Ordering, Conditional Logic, and List Operations.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] >= end:\n            end = interval[1]\n        else:\n            return False\n    return True",
        "solution_func": "def g(intervals: List[List[int]] = [[1, 2], [2, 3], [3, 4], [4, 5]]):\n    return intervals",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires checking if a list of intervals is non-overlapping, where each interval is represented as a list of two integers. The function f sorts the intervals based on their end points and then iterates through them to check for overlapping intervals. The function g provides a default list of intervals for testing."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sorting, iteration, and comparison of intervals in a list. The solution function g provides a default list of intervals for testing the algorithm. The puzzle is suitable for teaching Python programming concepts related to sorting and list manipulation.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4950951039791107,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom collections import Counter\n\ndef f(palindrome_permutation: str) -> bool:\n    char_count = Counter(palindrome_permutation.replace(\" \", \"\").lower())\n    odd_count = sum(1 for count in char_count.values() if count % 2 != 0)\n    return odd_count <= 1\n\ndef g(palindrome_permutation: str = \"Tact Coa\"):\n    return palindrome_permutation\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to check if a given string is a palindrome permutation.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from collections import Counter\n\ndef f(palindrome_permutation: str) -> bool:\n    char_count = Counter(palindrome_permutation.replace(\" \", \"\").lower())\n    odd_count = sum(1 for count in char_count.values() if count % 2 != 0)\n    return odd_count <= 1",
        "solution_func": "def g(palindrome_permutation: str = \"Tact Coa\"):\n    return palindrome_permutation",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires checking if a given string can be rearranged into a palindrome by ignoring spaces and considering case insensitively."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves counting the frequency of characters in a string, checking if there is at most one character with an odd frequency, and determining if the string can be rearranged into a palindrome. The solution function simply returns the input string.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.34981971979141235,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku_util(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku_util(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku_util(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n             [6, 0, 0, 1, 9, 5, 0, 0, 0],\n             [0, 9, 8, 0, 0, 0, 0, 6, 0],\n             [8, 0, 0, 0, 6, 0, 0, 0, 3],\n             [4, 0, 0, 8, 0, 3, 0, 0, 1],\n             [7, 0, 0, 0, 2, 0, 0, 0, 6],\n             [0, 6, 0, 0, 0, 0, 2, 8, 0],\n             [0, 0, 0, 4, 1, 9, 0, 0, 5],\n             [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku_util(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku_util(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku_util(board)",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n             [6, 0, 0, 1, 9, 5, 0, 0, 0],\n             [0, 9, 8, 0, 0, 0, 0, 6, 0],\n             [8, 0, 0, 0, 6, 0, 0, 0, 3],\n             [4, 0, 0, 8, 0, 3, 0, 0, 1],\n             [7, 0, 0, 0, 2, 0, 0, 0, 6],\n             [0, 6, 0, 0, 0, 0, 2, 8, 0],\n             [0, 0, 0, 4, 1, 9, 0, 0, 5],\n             [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a function to solve a Sudoku puzzle using backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to solve a Sudoku puzzle by filling in the empty cells with numbers 1 to 9 such that each row, column, and 3x3 subgrid contains all numbers from 1 to 9 without repetition. The solution function initializes a Sudoku board and returns it for testing.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.47533249855041504,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\nimport random\n\ndef f(factorial: int, n=5) -> bool:\n    return math.factorial(n) == factorial\n\ndef g(n=5) -> int:\n    return math.factorial(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and importing modules (math). It also includes function definition and assertion for testing the solution.",
        "idx_generation": 52,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nth_fib: int, n=5) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == nth_fib\n\ndef g(n=5):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\nimport random\n\ndef f(factorial: int, n=5) -> bool:\n    return math.factorial(n) == factorial",
        "solution_func": "def g(n=5) -> int:\n    return math.factorial(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the factorial of a given number n is equal to a specified factorial value, and a function g that calculates the factorial of a given number. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of factorial calculation in Python and function composition. It is a suitable puzzle for teaching Python programming concepts to master's students in CS.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6768977642059326,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_primes: int, n=10) -> bool:\n    return sum_primes == 17\n\ndef g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            prime_sum += i\n    return prime_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to Mathematical Operations, Conditional Logic, Functions, and Algorithm Optimization.",
        "idx_generation": 52,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)\n\ndef g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)\n\ndef g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_primes: int, n=10) -> bool:\n    return sum_primes == 17",
        "solution_func": "def g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            prime_sum += i\n    return prime_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions: f(sum_primes: int, n=10) -> bool checks if the sum of prime numbers up to n is equal to 17. g(n=10) -> int calculates the sum of prime numbers up to n. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if the sum of prime numbers up to a given limit is equal to a specific value. The solution function calculates the sum of prime numbers up to the given limit and the puzzle function checks if this sum is equal to the specified value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.642279326915741,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \ndef f(numbers: List[int]) -> bool:\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))\ndef g(start=1, diff=5, length=10):\n    return [start + diff*i for i in range(length)]\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a list of numbers follows an arithmetic progression pattern.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List \ndef f(numbers: List[int]) -> bool:\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))",
        "solution_func": "def g(start=1, diff=5, length=10):\n    return [start + diff*i for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a list of numbers generated using a given start, difference, and length follows an arithmetic sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of arithmetic sequences and list comprehension in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.503135085105896,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\ndef g(base='racecar'):\n    return base + base[-2::-1]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(base='racecar'):\n    return base + base[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it to its reverse. The solution generates a palindrome by concatenating a base string with its reverse excluding the last character."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes and manipulating strings in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5958951711654663,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"radar\"):\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(diff: int, numbers=[5, 10, 2, 8, 3]) -> bool:\n    return diff == max(numbers) - min(numbers)\n\ndef g(numbers=[5, 10, 2, 8, 3]):\n    return max(numbers) - min(numbers)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"radar\"):\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not. The function f(s) returns True if the input string is equal to its reverse, and function g(s) returns the reverse of the default string 'radar'. The assert statement checks if the reverse of 'radar' is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes in strings and understanding string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5796651244163513,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=7):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(diff: int, numbers=[5, 10, 2, 8, 3]) -> bool:\n    return diff == max(numbers) - min(numbers)\n\ndef g(numbers=[5, 10, 2, 8, 3]):\n    return max(numbers) - min(numbers)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=7):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num) and g(num=7), where f checks if a given number is a prime number and g returns a fixed number. The puzzle requires g to return a number such that f returns True when applied to that number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of prime numbers and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6389080882072449,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(point: tuple) -> bool:\n    return point[0] == 2 and point[1] == 3\n\ndef g(x1=1, y1=1, x2=3, y2=5, x3=2, y3=1, x4=2, y4=5):\n    # Compute the intersection point of lines passing through (x1, y1)-(x2, y2) and (x3, y3)-(x4, y4)\n    x_num = (x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)\n    y_num = (x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)\n    denom = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)\n\n    if denom == 0:\n        return \"Lines are parallel\"\n    else:\n        x = x_num / denom\n        y = y_num / denom\n        return (x, y)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to compute the intersection point of two lines.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(diff: int, numbers=[5, 10, 2, 8, 3]) -> bool:\n    return diff == max(numbers) - min(numbers)\n\ndef g(numbers=[5, 10, 2, 8, 3]):\n    return max(numbers) - min(numbers)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(point: tuple) -> bool:\n    return point[0] == 2 and point[1] == 3",
        "solution_func": "def g(x1=1, y1=1, x2=3, y2=5, x3=2, y3=1, x4=2, y4=5):\n    # Compute the intersection point of lines passing through (x1, y1)-(x2, y2) and (x3, y3)-(x4, y4)\n    x_num = (x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)\n    y_num = (x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)\n    denom = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)\n\n    if denom == 0:\n        return \"Lines are parallel\"\n    else:\n        x = x_num / denom\n        y = y_num / denom\n        return (x, y)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g. Function f checks if a given point is (2, 3). Function g calculates the intersection point of two lines and returns it. The puzzle requires checking if the intersection point satisfies the condition of being (2, 3)."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a mathematical computation to find the intersection point of two lines and then checking if this point is equal to (2, 3). It combines mathematical concepts with Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4888973832130432,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(text: str) -> bool:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return set(text.lower()).intersection(vowels) == vowels\n\ndef g():\n    import random\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    random.shuffle(vowels)\n    text = ''.join(random.choices(vowels, k=10))\n    return text\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Set Operations, Importing Modules (Itertools, etc.)",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(text: str) -> bool:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return set(text.lower()).intersection(vowels) == vowels",
        "solution_func": "def g():\n    import random\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    random.shuffle(vowels)\n    text = ''.join(random.choices(vowels, k=10))\n    return text",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given text contains all vowels (a, e, i, o, u) in lowercase. The solution function g generates a random string of 10 characters using the vowels and checks if f returns True for this generated string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, set operations, and random generation in Python. It tests the understanding of sets, intersections, and random module usage in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4048587679862976,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    return all(numbers[i] - numbers[i - 1] == numbers[i - 1] - numbers[i - 2] for i in range(2, len(numbers)))\n\ndef g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + i * diff for i in range(random.randint(3, 10))]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves list manipulation and checking for a specific pattern in the list elements.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) == len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 10)\n    numbers.extend(random.sample(numbers, 5))\n    return list(set(numbers))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 3, 1, 2, 3]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2, 3]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-2])\n            pattern.append(pattern[-1])\n            pattern.append(pattern[-3])\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    return all(numbers[i] - numbers[i - 1] == numbers[i - 1] - numbers[i - 2] for i in range(2, len(numbers)))",
        "solution_func": "def g():\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + i * diff for i in range(random.randint(3, 10))]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list of numbers follows an arithmetic sequence pattern, and a function g that generates a random list of numbers following an arithmetic sequence pattern. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, arithmetic sequences, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5430346131324768,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver in Python using a backtracking algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a backtracking algorithm. The function f(board: List[List[int]]) takes a 9x9 Sudoku board as input and returns True if the board is solvable, and False otherwise. The solution function g() provides an example Sudoku board that needs to be solved.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4235334098339081,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome, find a string that satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in strings using Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6057461500167847,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(num) that checks if a number is prime, write a function g() that returns the number 17 and assert that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves writing a function that returns a specific number and ensuring that the given prime checking function returns True when applied to the output of the function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.7001911997795105,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(missing_num: int, nums=[1, 2, 3, 4, 6, 7, 8, 9]) -> bool:\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return missing_num == total_sum - sum(nums)\n\ndef g(nums=[1, 2, 3, 4, 6, 7, 8, 9]) -> int:\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return total_sum - sum(nums)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": 53,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport math\n\ndef f(closest_distance: float, points=[(1, 2), (3, 4), (5, 6), (7, 8)]) -> bool:\n    return math.isclose(closest_distance, 2.8284, abs_tol=0.001)\n\ndef g(points: List[tuple] = [(1, 2), (3, 4), (5, 6), (7, 8)]) -> float:\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(missing_num: int, nums=[1, 2, 3, 4, 6, 7, 8, 9]) -> bool:\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return missing_num == total_sum - sum(nums)",
        "solution_func": "def g(nums=[1, 2, 3, 4, 6, 7, 8, 9]) -> int:\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return total_sum - sum(nums)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a missing number in a list of integers by calculating the sum of the list and comparing it to the expected sum of a sequence of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of list manipulation, arithmetic operations, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5370537042617798,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums, target=15) -> bool:\n    return any((n ^ 15 == 0) for n in nums)\n\ndef g(target=15):\n    import itertools\n    \n    max_num = 20\n    max_length = 5\n    for length in range(1, max_length + 1):\n        for combination in itertools.product(range(max_num), repeat=length):\n            if any((n ^ target == 0) for n in combination):\n                return list(combination)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves bitwise operations, iteration using itertools, and checking conditions in a loop. It also includes the concept of XOR operation and returning a list of numbers that satisfy a condition.",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(nums, target=15) -> bool:\n    return any((n ^ 15 == 0) for n in nums)",
        "solution_func": "def g(target=15):\n    import itertools\n    \n    max_num = 20\n    max_length = 5\n    for length in range(1, max_length + 1):\n        for combination in itertools.product(range(max_num), repeat=length):\n            if any((n ^ target == 0) for n in combination):\n                return list(combination)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if any number in a given list XORed with a target number equals zero. The solution function g generates combinations of numbers and returns the first combination where XOR with the target number equals zero."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves bitwise XOR operation and generating combinations of numbers. It can be used to teach students about bitwise operations and itertools in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.43933117389678955,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums, threshold=3) -> bool:\n    return sum((n % 2 == 0) for n in nums) >= threshold\n\ndef g(threshold=3):\n    import random\n    \n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        solution = [random.randint(0, 10) for _ in range(8)]\n        if sum((n % 2 == 0) for n in solution) >= threshold:\n            return solution\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and importing modules (random).",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(nums, threshold=3) -> bool:\n    return sum((n % 2 == 0) for n in nums) >= threshold",
        "solution_func": "def g(threshold=3):\n    import random\n    \n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        solution = [random.randint(0, 10) for _ in range(8)]\n        if sum((n % 2 == 0) for n in solution) >= threshold:\n            return solution",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the number of even elements in a list of numbers is greater than or equal to a threshold. The solution function g generates a list of random numbers and returns it if the condition is met."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic concepts of list comprehension, condition checking, and random number generation in Python. It can be used to teach students how to work with lists and conditions in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5315751433372498,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport string\n\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(coords: List[List[int]]) -> bool:\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    d = set()\n    for i in range(len(coords)):\n        for j in range(i + 1, len(coords)):\n            d.add(distance(coords[i], coords[j]))\n    return len(d) == 2 and 0 not in d\n\ndef g(coords=[[0, 0], [0, 1], [1, 1], [1, 0]]):\n    return coords\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import string\n\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "Given a string, the puzzle checks if the string is a palindrome after removing all non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after removing all non-alphanumeric characters and ignoring case. The solution function returns the provided string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5036031603813171,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(arr: list) -> bool:\n    return len(arr) == len(set(arr))\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list contains only unique elements.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(coords: List[List[int]]) -> bool:\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    d = set()\n    for i in range(len(coords)):\n        for j in range(i + 1, len(coords)):\n            d.add(distance(coords[i], coords[j]))\n    return len(d) == 2 and 0 not in d\n\ndef g(coords=[[0, 0], [0, 1], [1, 1], [1, 0]]):\n    return coords\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(arr: list) -> bool:\n    return len(arr) == len(set(arr))",
        "solution_func": "def g(arr=[1, 2, 3, 4, 5]):\n    return arr",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a list contains only unique elements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that returns True if a list contains only unique elements, and a function g that returns a list. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6740370988845825,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g(n=3) -> List[List[int]]:\n    symmetric_matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            val = i * n + j + 1\n            symmetric_matrix[i][j] = val\n            symmetric_matrix[j][i] = val\n    return symmetric_matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal. The solution generates a symmetric matrix based on a given size 'n' and then checks if it satisfies the symmetry condition.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\nfrom typing import Set\n\ndef f(sym_diff: Set[int]) -> bool:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return sym_diff == set1.symmetric_difference(set2)\n\ndef g() -> Set[int]:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {3, 4, 5, 6, 7}\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True",
        "solution_func": "def g(n=3) -> List[List[int]]:\n    symmetric_matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            val = i * n + j + 1\n            symmetric_matrix[i][j] = val\n            symmetric_matrix[j][i] = val\n    return symmetric_matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given matrix is symmetric along its diagonal."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that checks if a given matrix is symmetric along its diagonal. The solution function generates a symmetric matrix based on a given size and the puzzle function checks if this generated matrix is symmetric.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.38139092922210693,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i + 1] for i in range(len(subsequence) - 1))\n\ndef g(arr=[3, 2, 6, 4, 5, 1]):\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_len = max(dp)\n    start_index = dp.index(max_len)\n    subsequence = [arr[start_index]]\n    for i in range(start_index - 1, -1, -1):\n        if arr[i] < arr[start_index] and dp[i] == max_len - 1:\n            subsequence.insert(0, arr[i])\n            max_len -= 1\n            start_index = i\n    return subsequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Sorting and Ordering",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i + 1] for i in range(len(subsequence) - 1))",
        "solution_func": "def g(arr=[3, 2, 6, 4, 5, 1]):\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_len = max(dp)\n    start_index = dp.index(max_len)\n    subsequence = [arr[start_index]]\n    for i in range(start_index - 1, -1, -1):\n        if arr[i] < arr[start_index] and dp[i] == max_len - 1:\n            subsequence.insert(0, arr[i])\n            max_len -= 1\n            start_index = i\n    return subsequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python. The first function f(subsequence: List[int]) checks if a given list of integers is in strictly increasing order. The second function g(arr=[3, 2, 6, 4, 5, 1]) finds the longest increasing subsequence in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for a strictly increasing subsequence and finding the longest increasing subsequence in a list of integers using dynamic programming. It tests the student's knowledge of list manipulation and algorithmic thinking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.2999657690525055,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    palindrome = ''.join(random.choice(letters) for _ in range(5))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic. The function f checks if a given string is a palindrome, and the function g generates a random palindrome string.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    palindrome = ''.join(random.choice(letters) for _ in range(5))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random string and its palindrome. The assert statement checks if the generated string and its palindrome satisfy the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python and checking for palindromes. It provides a practical application of string slicing and comparison operations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4458763897418976,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]\n\ndef g(s = \"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    s = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return s == s[::-1]",
        "solution_func": "def g(s = \"A man, a plan, a canal: Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand string manipulation, regular expressions, and palindrome checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4617097079753876,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(options: str = 'abcdefghijklmnopqrstuvwxyz') -> str:\n    return options + options[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 54,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(options: str = 'abcdefghijklmnopqrstuvwxyz') -> str:\n    return options + options[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it with its reverse. The solution generates a string by concatenating a given string with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python and checking for palindromes. The solution demonstrates string concatenation and slicing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.3281010091304779,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    return random.choice(['radar', 'level', 'deified', 'civic', 'stats'])\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    return random.choice(['radar', 'level', 'deified', 'civic', 'stats'])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly selected string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a function f(s) that checks if a given string is a palindrome, and function g() that returns a random palindrome string. The puzzle is solved if the randomly selected string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6392744779586792,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g():\n    import random\n    return random.sample(range(1, 10), 5) + random.sample(range(1, 10), 5)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and random sampling, which are related to topics 9 (Set Operations) and 12 (Importing Modules).",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))",
        "solution_func": "def g():\n    import random\n    return random.sample(range(1, 10), 5) + random.sample(range(1, 10), 5)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires generating two lists of random numbers between 1 and 10, each with 5 unique numbers, and checking if there are any duplicates between the two lists."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, generating random numbers, and checking for duplicates in Python lists.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4712720215320587,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Permutations and Combinations",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))",
        "solution_func": "def g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list of integers is a permutation of the numbers 1 to n, and a function g that generates a random permutation of numbers 1 to n. The assertion checks if the generated permutation satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list operations, random number generation, and function calls in Python. It can be used to teach concepts of list manipulation, random module usage, and function testing in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5092958807945251,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    cleaned_string = ''.join(filter(str.isalnum, string)).lower()\n    return cleaned_string == cleaned_string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 1:\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:\n                return False\n            if col + (row - i) < len(board) and board[i][col + (row - i)] == 1:\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == len(board):\n            return True\n        for col in range(len(board)):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if solve_n_queens(board, row + 1):\n                    return True\n                board[row][col] = 0\n        return False\n\n    return solve_n_queens(board, 0)\n\ndef g(n=4):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    cleaned_string = ''.join(filter(str.isalnum, string)).lower()\n    return cleaned_string == cleaned_string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    palindrome = ''.join(random.choices(string.ascii_lowercase, k=random.randint(5, 10)))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome after removing non-alphanumeric characters and converting to lowercase. The solution function g generates a random palindrome string and its reverse, and checks if f returns True for this generated string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, and random string generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4154389798641205,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to check if a given string is a palindrome.",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(solution: List[List[int]]) -> bool:\n    def is_valid(num, i, j, board):\n        for x in range(9):\n            if board[i][x] == num or board[x][j] == num or board[3 * (i // 3) + x // 3][3 * (j // 3) + x % 3] == num:\n                return False\n        return True\n\n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(num, i, j, board):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    solve(solution)\n    for i in range(9):\n        if len(set(solution[i])) != 9 or len(set(row[i] for row in solution)) != 9:\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if len(set(solution[x][y] for x in range(i, i + 3) for y in range(j, j + 3))) != 9:\n                return False\n    return True\n\ndef g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase. The function g returns a specific string. The puzzle tests whether the function f correctly identifies the given string as a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after certain modifications. It tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4542880058288574,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves bitwise operations and random number generation, which are related to topics such as Binary Operations and Randomization.",
        "idx_generation": 55,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n",
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0",
        "solution_func": "def g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n, m) that checks if a given number n is divisible by m and is a power of 2. The solution function g(m) generates a random number that is a multiple of m and a power of 2, and then checks if this number satisfies the conditions of function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of bitwise operations, random number generation, and function composition in Python. It provides a practical application of these concepts in a programming challenge.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6159877777099609,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(n=5) -> int:\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as Mathematical Operations, Conditional Logic, and Number Theory (primes). The function f checks if a number is prime, while the function g generates the nth Fibonacci number using mathematical operations and conditional logic.",
        "idx_generation": 55,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(n=5) -> int:\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return b",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(num) checks if a given number is a prime number, and g(n) generates the nth Fibonacci number. The puzzle requires checking if the nth Fibonacci number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle combines concepts of prime numbers and Fibonacci sequence in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5538628101348877,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, random number generation, and function definition.",
        "idx_generation": 55,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is prime, and a function g() that generates a random number and ensures it is prime before returning it. The assert statement checks if the generated number from g() is prime according to f()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, loops, and random number generation in Python. It provides a practical application of checking for prime numbers using functions and loops.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.533983051776886,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    palindrome = ''.join(random.choice(letters) for _ in range(random.randint(3, 8)))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Importing Modules (Itertools, etc.), Probability and Statistics",
        "idx_generation": 55,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    palindrome = ''.join(random.choice(letters) for _ in range(random.randint(3, 8)))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, random string generation, and function assertion testing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4537072479724884,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int) -> bool:\n    return max_sum == 12  # Maximum sum of non-adjacent numbers in the list\n\ndef g():\n    def max_non_adjacent_sum(nums):\n        if not nums:\n            return 0\n\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n\n        return max(incl, excl)\n\n    num_list = [2, 4, 6, 8, 3]\n    return max_non_adjacent_sum(num_list)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the maximum sum of non-adjacent numbers in a list.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int) -> bool:\n    return max_sum == 12  # Maximum sum of non-adjacent numbers in the list",
        "solution_func": "def g():\n    def max_non_adjacent_sum(nums):\n        if not nums:\n            return 0\n\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n\n        return max(incl, excl)\n\n    num_list = [2, 4, 6, 8, 3]\n    return max_non_adjacent_sum(num_list)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of non-adjacent numbers in a list and checking if it equals 12."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding how to find the maximum sum of non-adjacent numbers in a list using dynamic programming and comparing it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.5327035784721375,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 21  # Calculate the 8th Fibonacci number\n\ndef g():\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n\n        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n        return memo[n]\n\n    return fibonacci(8)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Recursion, Mathematical Operations",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_paths: int) -> bool:\n    return total_paths == 28  # Total unique paths for a 3x7 grid\n\ndef g():\n    def unique_paths(m, n):\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n\n    return unique_paths(3, 7)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 21  # Calculate the 8th Fibonacci number",
        "solution_func": "def g():\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n\n        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n        return memo[n]\n\n    return fibonacci(8)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to calculate the 8th Fibonacci number and check if it is equal to 21."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a recursive Fibonacci function and checking if the 8th Fibonacci number is equal to 21.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.5795150995254517,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)\n\ndef g(numbers=[3, 10, 2, 8, 4, 5, 7]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    max_index = dp.index(max_length)\n    longest_subsequence = [numbers[max_index]]\n    for k in range(max_index - 1, -1, -1):\n        if numbers[k] < numbers[max_index] and dp[k] == dp[max_index] - 1:\n            longest_subsequence.insert(0, numbers[k])\n            max_index = k\n    return longest_subsequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Dynamic Programming",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)",
        "solution_func": "def g(numbers=[3, 10, 2, 8, 4, 5, 7]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    max_index = dp.index(max_length)\n    longest_subsequence = [numbers[max_index]]\n    for k in range(max_index - 1, -1, -1):\n        if numbers[k] < numbers[max_index] and dp[k] == dp[max_index] - 1:\n            longest_subsequence.insert(0, numbers[k])\n            max_index = k\n    return longest_subsequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the longest increasing subsequence in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a dynamic programming solution to find the longest increasing subsequence in a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3606463372707367,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(3, 7)))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(3, 7)))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated word concatenated with its reverse is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random word and checking if the concatenation of the word with its reverse is a palindrome. The solution function generates a random word and its reverse to satisfy the palindrome condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.4387996792793274,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(matrix: list) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))\n\ndef g() -> list:\n    import random\n    size = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    for i in range(size):\n        for j in range(i + 1, size):\n            matrix[j][i] = matrix[i][j]\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal. The function f() checks if the matrix is symmetric, and the function g() generates a random symmetric matrix. The topics involved in this puzzle are matrix manipulation, random number generation, and symmetry checking.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(matrix: list) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))",
        "solution_func": "def g() -> list:\n    import random\n    size = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    for i in range(size):\n        for j in range(i + 1, size):\n            matrix[j][i] = matrix[i][j]\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random square matrix and checking if it is symmetric along the main diagonal."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand matrix indexing, random number generation, and symmetry properties of matrices.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4588070213794708,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(area: float, threshold=10.0) -> bool:\n    return area > threshold\n\ndef g(side1=5, side2=12, side3=13) -> float:\n    s = (side1 + side2 + side3) / 2\n    area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3))\n    return area\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and importing modules (math).",
        "idx_generation": 56,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(sorted_list: List[int], target_sum=30) -> bool:\n    return sum(sorted_list[:3]) == target_sum\n\ndef g(numbers=[10, 20, 15, 5, 25, 30]):\n    sorted_list = sorted(numbers)\n    return sorted_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(area: float, threshold=10.0) -> bool:\n    return area > threshold",
        "solution_func": "def g(side1=5, side2=12, side3=13) -> float:\n    s = (side1 + side2 + side3) / 2\n    area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3))\n    return area",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the area of a triangle calculated by function g is greater than a given threshold value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of functions, mathematical calculations, and conditional statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5679888725280762,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Set\n\ndef f(nums: Set[int]) -> bool:\n    triplets = {(a, b, c) for a in nums for b in nums for c in nums if a**2 + b**2 == c**2}\n    return any(triplets)\n\ndef g():\n    return {3, 4, 5, 6, 8, 10}\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, set operations, and conditional logic.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import Set\n\ndef f(nums: Set[int]) -> bool:\n    triplets = {(a, b, c) for a in nums for b in nums for c in nums if a**2 + b**2 == c**2}\n    return any(triplets)",
        "solution_func": "def g():\n    return {3, 4, 5, 6, 8, 10}",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding Pythagorean triplets in a given set of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exist any Pythagorean triplets (a, b, c) in the given set of numbers such that a^2 + b^2 = c^2.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4888973832130432,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    target_word = \"listen\"\n    target_count = {char: target_word.count(char) for char in set(target_word)}\n    word_counts = [{char: word.count(char) for char in set(word)} for word in words]\n\n    return target_count in word_counts\n\ndef g():\n    return [\"enlist\", \"silent\", \"tinsel\", \"apple\", \"orange\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Set Operations",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    target_word = \"listen\"\n    target_count = {char: target_word.count(char) for char in set(target_word)}\n    word_counts = [{char: word.count(char) for char in set(word)} for word in words]\n\n    return target_count in word_counts",
        "solution_func": "def g():\n    return [\"enlist\", \"silent\", \"tinsel\", \"apple\", \"orange\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires checking if a list of words contains anagrams of a target word 'listen'."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves comparing the count of characters in the target word 'listen' with the count of characters in each word in a list of words to determine if any word in the list is an anagram of 'listen'.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3895275294780731,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(colors_drawn: List[str]) -> bool:\n    target_color = \"red\"\n    total_draws = len(colors_drawn)\n    red_draws = colors_drawn.count(target_color)\n    probability = red_draws / total_draws\n\n    return probability > 0.3\n\ndef g():\n    return [\"red\", \"blue\", \"red\", \"green\", \"red\", \"yellow\"]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics as it calculates the probability of drawing a specific color from a list of colors.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(colors_drawn: List[str]) -> bool:\n    target_color = \"red\"\n    total_draws = len(colors_drawn)\n    red_draws = colors_drawn.count(target_color)\n    probability = red_draws / total_draws\n\n    return probability > 0.3",
        "solution_func": "def g():\n    return [\"red\", \"blue\", \"red\", \"green\", \"red\", \"yellow\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that calculates the probability of a specific color being drawn from a list of colors, and the solution function provides a list of colors to check if the probability of drawing 'red' is greater than 0.3."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic list manipulation and probability calculation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5674458146095276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int], nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == len(subsequence)\n\ndef g(nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) -> List[int]:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    subsequence = []\n    for i in range(len(nums) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(nums[i])\n            max_length -= 1\n    return subsequence[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(common_elements: set, list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> bool:\n    return common_elements == set(list1) & set(list2)\n\ndef g(list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> set:\n    return set(list1) & set(list2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int], nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) -> bool:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) == len(subsequence)",
        "solution_func": "def g(nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) -> List[int]:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    subsequence = []\n    for i in range(len(nums) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(nums[i])\n            max_length -= 1\n    return subsequence[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest increasing subsequence in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f(subsequence: List[int], nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) checks if the input subsequence is the longest increasing subsequence in the default list of numbers. The function g(nums=[1, 3, 6, 7, 9, 4, 10, 5, 6]) returns the longest increasing subsequence in the default list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.35238078236579895,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sym_diff: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return sym_diff == set1 ^ set2\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> set:\n    return set1 ^ set2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and boolean logic.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(common_elements: set, list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> bool:\n    return common_elements == set(list1) & set(list2)\n\ndef g(list1=[1, 2, 3, 4, 5], list2=[3, 4, 5, 6, 7]) -> set:\n    return set(list1) & set(list2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sym_diff: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return sym_diff == set1 ^ set2",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> set:\n    return set1 ^ set2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the symmetric difference of two sets is equal to a predefined set, and g returns the symmetric difference of two sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of sets and symmetric difference in Python. It is a good exercise to test the understanding of set operations and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6265705227851868,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    def is_valid_sudoku_row(row):\n        seen = set()\n        for num in row:\n            if num != '.':\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_sudoku(matrix):\n        for row in matrix:\n            if not is_valid_sudoku_row(row):\n                return False\n        for col in range(9):\n            if not is_valid_sudoku_row([matrix[row][col] for row in range(9)]):\n                return False\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if not is_valid_sudoku_row([matrix[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]):\n                    return False\n        return True\n\n    return is_valid_sudoku(matrix)\n\ndef g() -> List[List[int]]:\n    sudoku_solution = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return sudoku_solution\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku solution, which requires understanding of matrix manipulation and validation. It also involves conditional logic and iteration over rows, columns, and subgrids of the Sudoku matrix.",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum, target_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index], target_sum) or can_partition(nums, index + 1, current_sum, target_sum)\n\n    return can_partition(nums, 0, 0, target_sum)\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    def is_valid_sudoku_row(row):\n        seen = set()\n        for num in row:\n            if num != '.':\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_sudoku(matrix):\n        for row in matrix:\n            if not is_valid_sudoku_row(row):\n                return False\n        for col in range(9):\n            if not is_valid_sudoku_row([matrix[row][col] for row in range(9)]):\n                return False\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if not is_valid_sudoku_row([matrix[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]):\n                    return False\n        return True\n\n    return is_valid_sudoku(matrix)",
        "solution_func": "def g() -> List[List[int]]:\n    sudoku_solution = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return sudoku_solution",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku solution is valid or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function to check the validity of a Sudoku solution by verifying the rows, columns, and 3x3 subgrids.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45452681183815,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text.isalnum()\n\ndef g() -> str:\n    import random\n    import string\n    length = random.randint(5, 10)\n    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and random generation of strings using the `random` and `string` modules in Python.",
        "idx_generation": 57,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text.isalnum()",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    length = random.randint(5, 10)\n    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a random string of alphanumeric characters and check if the string is alphanumeric."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the isalnum() method to check if a string contains only alphanumeric characters. The solution function g() generates a random string of alphanumeric characters and the puzzle function f() checks if the generated string is alphanumeric.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.464002788066864,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(binary: str, num=42) -> bool:\n    return binary == bin(num)[2:]\n\ndef g(num=42) -> str:\n    binary = ''\n    while num > 0:\n        binary = str(num % 2) + binary\n        num //= 2\n    return binary\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to Binary Operations, Mathematical Operations, and Conditional Logic.",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(binary: str, num=42) -> bool:\n    return binary == bin(num)[2:]",
        "solution_func": "def g(num=42) -> str:\n    binary = ''\n    while num > 0:\n        binary = str(num % 2) + binary\n        num //= 2\n    return binary",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if a binary representation of a number matches a given binary string, and g converts a number to its binary representation. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with binary representations of numbers and understanding how to convert a number to binary. It tests the student's understanding of binary operations and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6819002032279968,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(fib_num: int, n=8) -> bool:\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n\n    return fib_num == fibonacci_recursive(n)\n\ndef g(n=8) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n    return fibonacci(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations related to Fibonacci sequence.",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(fib_num: int, n=8) -> bool:\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n\n    return fib_num == fibonacci_recursive(n)",
        "solution_func": "def g(n=8) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n    return fibonacci(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, one to calculate the nth Fibonacci number using recursion and another to calculate the nth Fibonacci number using iteration. The challenge is to check if the two functions produce the same Fibonacci number for a given input n."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding and comparing recursive and iterative approaches to calculating Fibonacci numbers in Python. It tests the student's knowledge of recursion and iteration in programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.509787380695343,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        palindrome = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        if length % 2 == 0:\n            return palindrome + palindrome[::-1]\n        else:\n            return palindrome + random.choice(string.ascii_lowercase) + palindrome[::-1]\n\n    return generate_palindrome(5)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 57,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        palindrome = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        if length % 2 == 0:\n            return palindrome + palindrome[::-1]\n        else:\n            return palindrome + random.choice(string.ascii_lowercase) + palindrome[::-1]\n\n    return generate_palindrome(5)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and checking if it is a palindrome using the provided function f(). The solution function g() generates a palindrome string to test the palindrome check function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4166930317878723,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using a simple algorithm. It does not directly relate to any specific topic from the list provided.",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(num) that checks if a given number is a prime number. The solution function g() returns the number 17, and the puzzle is to verify if 17 is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to check for primality. The solution function returns a specific number (17) to test the primality check function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6407198905944824,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]\n\ndef g() -> str:\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]",
        "solution_func": "def g() -> str:\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(text: str) that checks if a given text is a palindrome after removing non-alphanumeric characters, and a function g() that returns the text 'level'. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes after cleaning the text and understanding function calls in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4784010350704193,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        complement = 10 - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    return [2, 8, 5, 3]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic to find if there are two numbers in the list that sum up to 10.",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        complement = 10 - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g() -> List[int]:\n    return [2, 8, 5, 3]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding if there are two numbers in a list that add up to 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there are two numbers in a list that add up to 10. The function f() checks for this condition, and the function g() provides a list of numbers to test this condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5238085389137268,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"level\") -> str:\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 57,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(nums: list[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(n=5, start=1, end=10):\n    return random.sample(range(start, end + 1), n)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> List[int]:\n    import random\n    nums = random.sample(range(1, 10), 9)\n    nums.append(random.choice(nums))\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"level\") -> str:\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle consists of two functions, f(s: str) -> bool which checks if a given string is a palindrome, and g(s='level') -> str which returns a string. The assert statement checks if the output of g() satisfies the condition of being a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6594554781913757,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: str) -> bool:\n    return result == result[::-1]\n\ndef g(input_str=\"racecar\") -> str:\n    return input_str + input_str[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 57,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int, n=5) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return result == factorial(n)\n\ndef g(n=5):\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n    return factorial(n)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1))\n\ndef g():\n    import random\n\n    length = random.randint(5, 10)\n    numbers = random.sample(range(1, 100), length)\n    numbers.sort()\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: str) -> bool:\n    return result == result[::-1]",
        "solution_func": "def g(input_str=\"racecar\") -> str:\n    return input_str + input_str[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that checks if a given string is a palindrome, and another function that generates a palindrome by appending the reverse of the string excluding the last character."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and checking for palindromes in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5316215753555298,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(sorted_list: list) -> bool:\n    return sorted_list == [0, 1, 2, 4, 8, 3, 5, 6, 9, 10]\n\ndef g(numbers=[1, 2, 3, 4, 5, 6, 8, 9, 10, 0]) -> list:\n    return sorted(numbers, key=lambda x: bin(x).count('1'))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list based on the count of set bits in the binary representation of each number. This requires knowledge of bitwise operations and sorting algorithms.",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(factorial_result: int) -> bool:\n    return factorial_result % 10 == 0\n\ndef g(number=5) -> int:\n    return math.factorial(number)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sorted_list: list) -> bool:\n    return sorted_list == [0, 1, 2, 4, 8, 3, 5, 6, 9, 10]",
        "solution_func": "def g(numbers=[1, 2, 3, 4, 5, 6, 8, 9, 10, 0]) -> list:\n    return sorted(numbers, key=lambda x: bin(x).count('1'))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires sorting a list of numbers based on the count of '1's in their binary representation to match a specific sorted list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of numbers based on a specific criteria and checking if the sorted list matches a predefined list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5712597370147705,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(area: float) -> bool:\n    return area == 4.5\n\ndef g(vertices=[(0, 0), (3, 0), (3, 3)]) -> float:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to calculate the area of a triangle given its vertices. The solution function uses mathematical operations and conditional logic to calculate the area. The puzzle also includes an assertion for validation.",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(factorial_result: int) -> bool:\n    return factorial_result % 10 == 0\n\ndef g(number=5) -> int:\n    return math.factorial(number)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(area: float) -> bool:\n    return area == 4.5",
        "solution_func": "def g(vertices=[(0, 0), (3, 0), (3, 3)]) -> float:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given set of vertices forms a triangle with area equal to 4.5 units."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to calculate the area of a triangle given its vertices and check if the area is equal to 4.5 units.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5727367997169495,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    # Generate a sample string to test for palindrome\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g():\n    # Generate a sample string to test for palindrome\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, checking for palindromes, and using list comprehensions in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.44360730051994324,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    import random\n\n    n = random.randint(3, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]  # Make the matrix symmetric\n\n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given matrix is symmetric along its diagonal by comparing elements across the diagonal. It also includes generating a random symmetric matrix as input for the function. The topics used in this puzzle are: Conditional Logic, Importing Modules (Itertools, etc.), and Pattern Recognition.",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    n = random.randint(3, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]  # Make the matrix symmetric\n\n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given square matrix is symmetric along its main diagonal."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(matrix) that checks if a square matrix is symmetric along its main diagonal. The solution function g() generates a random square matrix and makes it symmetric along the main diagonal. The assertion at the end verifies that the solution function g() satisfies the condition of the puzzle function f().",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3713734745979309,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sentence: str) -> bool:\n    sentence = sentence.lower().replace(\" \", \"\")\n    return sentence == sentence[::-1]\n\ndef g():\n    import random\n    import string\n\n    sentence = ''.join(random.choices(string.ascii_lowercase, k=10))\n    palindrome = sentence + sentence[::-1]\n    \n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sentence: str) -> bool:\n    sentence = sentence.lower().replace(\" \", \"\")\n    return sentence == sentence[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    sentence = ''.join(random.choices(string.ascii_lowercase, k=10))\n    palindrome = sentence + sentence[::-1]\n    \n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given sentence is a palindrome after removing spaces and converting to lowercase. The solution function g generates a random 10-character string, creates a palindrome by appending the reverse of the string, and returns it. The assertion checks if f returns True when applied to the output of g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, random string generation, and function testing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.43965935707092285,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g():\n    import random\n\n    numbers = random.choices(range(1, 10), k=5)\n    \n    return numbers + numbers[:2]  # Adding some duplicate elements\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for duplicates in a list of numbers generated randomly. It also involves using the `random` module in Python. The solution adds duplicate elements to the list to ensure that the condition for duplicates is met.",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return len(numbers) != len(set(numbers))",
        "solution_func": "def g():\n    import random\n\n    numbers = random.choices(range(1, 10), k=5)\n    \n    return numbers + numbers[:2]  # Adding some duplicate elements",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of random numbers, adding duplicate elements to the list, and checking if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand list manipulation, random number generation, and the concept of duplicates in a list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45147156715393066,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    even_sum = sum(num for num in nums if num % 2 == 0)\n    return even_sum % 2 == 0\n\ndef g() -> List[int]:\n    return [3, 8, 12, 5, 6, 10, 7]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, List Operations, and Conditional Logic.",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    even_sum = sum(num for num in nums if num % 2 == 0)\n    return even_sum % 2 == 0",
        "solution_func": "def g() -> List[int]:\n    return [3, 8, 12, 5, 6, 10, 7]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of integers, calculates the sum of even numbers in the list, and returns True if the sum is even. The solution function g returns a specific list of integers. The puzzle is considered solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with lists, conditional statements, and arithmetic operations in Python. It tests the understanding of list comprehension, summing elements, and checking for even numbers. The solution function g provides a list that satisfies the conditions of the puzzle.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5361559987068176,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (primality testing) and Importing Modules (random).",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is a prime number, and a function g() that returns a random prime number from a predefined list. The puzzle requires g() to return a prime number and f() to validate if the number returned by g() is indeed a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of prime numbers, loops, and conditional statements in Python. It tests the understanding of prime number generation and validation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5873399376869202,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(missing_num: int, sequence=[2, 4, 8, 10, 12, 14, 16, 18]) -> bool:\n    diff = (sequence[-1] - sequence[0]) // len(sequence)\n    return missing_num == sequence[0] + diff * (len(sequence) + 1)\n\ndef g(sequence=[2, 4, 8, 10, 12, 14, 16, 18]) -> int:\n    diff = (sequence[-1] - sequence[0]) // len(sequence)\n    return sequence[0] + diff * (len(sequence) + 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to find a missing number in a sequence.",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))\n\ndef g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])\n\nassert f(g()) == True\n",
            "\ndef f(max_product: int, numbers=[2, 5, 3, 7, 8, 4]) -> bool:\n    return max_product == max(numbers) * sorted(numbers)[-2]\n\ndef g(numbers=[2, 5, 3, 7, 8, 4]) -> int:\n    sorted_nums = sorted(numbers)\n    return sorted_nums[-1] * sorted_nums[-2]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(missing_num: int, sequence=[2, 4, 8, 10, 12, 14, 16, 18]) -> bool:\n    diff = (sequence[-1] - sequence[0]) // len(sequence)\n    return missing_num == sequence[0] + diff * (len(sequence) + 1)",
        "solution_func": "def g(sequence=[2, 4, 8, 10, 12, 14, 16, 18]) -> int:\n    diff = (sequence[-1] - sequence[0]) // len(sequence)\n    return sequence[0] + diff * (len(sequence) + 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a missing number fits a specific pattern in a given sequence, and a function g that generates a number based on the same pattern. The puzzle requires finding the missing number in the sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding the pattern in the sequence and using it to determine the missing number. The solution function g generates a number based on the same pattern to be checked by function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5632967948913574,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, pattern='xyx') -> bool:\n    return s == s[::-1]\ndef g(pattern='xyx'):\n    return pattern + pattern[-2::-1]\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str, pattern='xyx') -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(pattern='xyx'):\n    return pattern + pattern[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given string is a palindrome, and a function g that generates a specific pattern based on the input pattern. The assertion checks if the output of g satisfies the condition of f being True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6798854470252991,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List \ndef f(nums: List[int], start=1, end=100) -> bool:\n    return set(range(start, end+1)).issubset(set(nums))\ndef g(start=1, end=100):\n    return list(range(start, end+1))\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and list manipulation to check if a given list contains a specific range of numbers.",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List \ndef f(nums: List[int], start=1, end=100) -> bool:\n    return set(range(start, end+1)).issubset(set(nums))",
        "solution_func": "def g(start=1, end=100):\n    return list(range(start, end+1))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function f that checks if a given list of numbers contains all the numbers in a specified range. The solution function g generates a list of numbers within the specified range."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets, ranges, and list operations in Python. The solution function g generates a list of numbers within the specified range, and the function f checks if all numbers in that range are present in the input list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5375658273696899,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subseq_len: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    if not nums:\n        return False\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subseq_len\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 59,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subseq_len: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    if not nums:\n        return False\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subseq_len",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the longest increasing subsequence length of a given list of numbers matches a specified length, and g calculates the length of the longest increasing subsequence of the same list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming to find the longest increasing subsequence length. The solution function g calculates this length, and the puzzle function f checks if the calculated length matches the specified length.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4234654903411865,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(length=5):\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = length // 2\n    first_half = ''.join(random.choices(letters, k=half_length))\n    second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n    return first_half + second_half\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.), Probability and Statistics",
        "idx_generation": 59,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list, diff=3) -> bool:\n    return all(arr[i] - arr[i - 1] == diff for i in range(1, len(arr)))\ndef g(start=10, length=5):\n    return [start + i * 3 for i in range(length)]\nassert f(g()) == True\n",
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True"
        ],
        "problem_func": "import random\n\ndef f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(length=5):\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    half_length = length // 2\n    first_half = ''.join(random.choices(letters, k=half_length))\n    second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n    return first_half + second_half",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that generates a string of a specified length and checks if the string is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, random module, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.40005964040756226,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    s = re.sub(r'\\W+', '', s).lower()\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation using regular expressions and slicing",
        "idx_generation": 59,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) != len(set(nums))\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    numbers.append(random.choice(numbers))  # introducing a duplicate\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    s = re.sub(r'\\W+', '', s).lower()\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal, Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function to check if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using regular expressions to remove non-alphanumeric characters and checking if the resulting string is a palindrome. The solution function returns a specific string that is a palindrome after processing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4796372354030609,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    mid = random.choice(letters)\n    left = ''.join(random.choices(letters, k=random.randint(1, 5)))\n    right = left[::-1]\n    return left + mid + right\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and random generation of strings to check if they are palindromes.",
        "idx_generation": 59,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    mid = random.choice(letters)\n    left = ''.join(random.choices(letters, k=random.randint(1, 5)))\n    right = left[::-1]\n    return left + mid + right",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random string with a middle character and its mirrored left and right sides. The puzzle tests whether the generated string is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, and random generation in Python. It can be used to teach students about these concepts in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.38968056440353394,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    def generate_palindrome_string():\n        letters = string.ascii_lowercase\n        length = random.randint(3, 10)\n        half_length = length // 2\n        prefix = ''.join(random.choices(letters, k=half_length))\n        suffix = prefix[::-1] if length % 2 == 0 else prefix[:-1][::-1]\n        return prefix + suffix\n\n    return generate_palindrome_string()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
            "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    def generate_palindrome_string():\n        letters = string.ascii_lowercase\n        length = random.randint(3, 10)\n        half_length = length // 2\n        prefix = ''.join(random.choices(letters, k=half_length))\n        suffix = prefix[::-1] if length % 2 == 0 else prefix[:-1][::-1]\n        return prefix + suffix\n\n    return generate_palindrome_string()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that checks if a given string is a palindrome. The solution function g() generates a random palindrome string and checks if it satisfies the palindrome condition using f(g()).",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4281976521015167,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to write a function that removes non-alphanumeric characters from a string, converts it to lowercase, and then checks if the resulting string is a palindrome. The provided solution simply returns a specific string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.46270379424095154,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(sides: tuple) -> bool:\n    sides = sorted(sides)\n    return math.isclose((sides[0]**2 + sides[1]**2), sides[2]**2)\n\ndef g(side1=3, side2=4, side3=5):\n    return side1, side2, side3\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Mathematical Operations, Importing Modules (Itertools, etc.)",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(sides: tuple) -> bool:\n    sides = sorted(sides)\n    return math.isclose((sides[0]**2 + sides[1]**2), sides[2]**2)",
        "solution_func": "def g(side1=3, side2=4, side3=5):\n    return side1, side2, side3",
        "quality": [
            null
        ],
        "description": [
            "Given a tuple of sides of a triangle, the function f checks if the triangle is a right-angled triangle using the Pythagorean theorem. The function g returns a tuple of sides of a triangle."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a triangle is a right-angled triangle using the Pythagorean theorem. The solution function g returns a tuple of sides of a triangle. The assertion at the end checks if the solution function g satisfies the condition of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6383927464485168,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(smallest_prime_factor: int, num=91) -> bool:\n    if smallest_prime_factor == 0:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i == smallest_prime_factor\n    return False\n\ndef g(num=91) -> int:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i\n    return 0\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(palindrome: str) that checks if a given string is a palindrome by comparing it with its reverse. The solution function g() returns the string 'radar', which is a palindrome. The assert statement confirms that the solution function g() correctly identifies the palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6494163870811462,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(duplicate_list: List[int]) -> bool:\n    return len(set(duplicate_list)) != len(duplicate_list)\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 4, 5]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations to check for duplicates in a list.",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(smallest_prime_factor: int, num=91) -> bool:\n    if smallest_prime_factor == 0:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i == smallest_prime_factor\n    return False\n\ndef g(num=91) -> int:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return i\n    return 0\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(duplicate_list: List[int]) -> bool:\n    return len(set(duplicate_list)) != len(duplicate_list)",
        "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 4, 5]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a list contains duplicate elements, and a function g that returns a list with duplicate elements. The puzzle requires students to understand list manipulation and set operations in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for duplicates in a list using set operations and list comparison. It can be used to teach students about sets, lists, and boolean comparisons in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45676565170288086,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)\n\ndef g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves finding prime factors of a number and checking if they match a given set of prime factors. It also includes the use of sets, loops, and mathematical operations.",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(combinations_list: list, s='xyz') -> bool:\n    valid_combinations = []\n    for r in range(1, len(s)+1):\n        valid_combinations.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return set(combinations_list) == set(valid_combinations)\n\ndef g(s='xyz'):\n    combinations_list = []\n    for r in range(1, len(s)+1):\n        combinations_list.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return combinations_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)",
        "solution_func": "def g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if a set of prime factors of a given number matches a predefined set, and the second function calculates the prime factors of a given number. The goal is to ensure that the second function correctly calculates the prime factors of the number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime factorization and function implementation in Python. It tests the student's ability to define functions, handle loops, and work with sets in Python. This puzzle can be used to teach Python programming concepts related to functions and algorithmic challenges.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46067172288894653,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(similarity: float, set1={'apple', 'banana', 'cherry'}, set2={'banana', 'orange', 'kiwi'}) -> bool:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    jaccard_similarity = intersection / union if union > 0 else 0\n    return jaccard_similarity == similarity\n\ndef g(set1={'apple', 'banana', 'cherry'}, set2={'banana', 'orange', 'kiwi'}):\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    jaccard_similarity = intersection / union if union > 0 else 0\n    return jaccard_similarity\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Set Operations",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(combinations_list: list, s='xyz') -> bool:\n    valid_combinations = []\n    for r in range(1, len(s)+1):\n        valid_combinations.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return set(combinations_list) == set(valid_combinations)\n\ndef g(s='xyz'):\n    combinations_list = []\n    for r in range(1, len(s)+1):\n        combinations_list.extend([''.join(c) for c in itertools.combinations(s, r)])\n    return combinations_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(similarity: float, set1={'apple', 'banana', 'cherry'}, set2={'banana', 'orange', 'kiwi'}) -> bool:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    jaccard_similarity = intersection / union if union > 0 else 0\n    return jaccard_similarity == similarity",
        "solution_func": "def g(set1={'apple', 'banana', 'cherry'}, set2={'banana', 'orange', 'kiwi'}):\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    jaccard_similarity = intersection / union if union > 0 else 0\n    return jaccard_similarity",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the Jaccard similarity between two sets is equal to a given similarity value, and g calculates the Jaccard similarity between two sets. The assertion at the end checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding Jaccard similarity and set operations in Python. It requires students to implement a function to calculate Jaccard similarity and another function to check if the calculated similarity matches a given value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4905569851398468,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g():\n    word = \"racecar\"\n    return word + word[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(nth_fib: int, n=5) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == nth_fib\n\ndef g(n=5):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g():\n    word = \"racecar\"\n    return word + word[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome and then creating a solution function that generates a palindrome string to test the function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5816618800163269,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(dice_sum: int, threshold=3) -> bool:\n    expected_value = 3.5  # Expected value of a fair six-sided dice roll\n    return dice_sum > threshold\n\ndef g(num_rolls=100) -> int:\n    dice_sum = sum(random.randint(1, 6) for _ in range(num_rolls))\n    return dice_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics as it calculates the expected value of a fair six-sided dice roll and compares it to a threshold. It also includes importing modules (random) for generating random numbers.",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(colors_drawn: List[str]) -> bool:\n    target_color = \"red\"\n    total_draws = len(colors_drawn)\n    red_draws = colors_drawn.count(target_color)\n    probability = red_draws / total_draws\n\n    return probability > 0.3\n\ndef g():\n    return [\"red\", \"blue\", \"red\", \"green\", \"red\", \"yellow\"]\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(points: list) -> bool:\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) != 0\n\ndef g():\n    points = [(random.randint(1, 10), random.randint(1, 10)) for _ in range(3)]\n    return points\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(dice_sum: int, threshold=3) -> bool:\n    expected_value = 3.5  # Expected value of a fair six-sided dice roll\n    return dice_sum > threshold",
        "solution_func": "def g(num_rolls=100) -> int:\n    dice_sum = sum(random.randint(1, 6) for _ in range(num_rolls))\n    return dice_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a sum of dice rolls and checking if the sum is greater than a specified threshold."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate random numbers, calculate the sum of dice rolls, and compare the sum to a threshold value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5315239429473877,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int, nums=[3, 10, 2, 1, 20]) -> bool:\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subsequence_length\n\ndef g(nums=[3, 10, 2, 1, 20]):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\nfrom typing import Set\n\ndef f(nums: Set[int]) -> bool:\n    triplets = {(a, b, c) for a in nums for b in nums for c in nums if a**2 + b**2 == c**2}\n    return any(triplets)\n\ndef g():\n    return {3, 4, 5, 6, 8, 10}\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int, nums=[3, 10, 2, 1, 20]) -> bool:\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subsequence_length",
        "solution_func": "def g(nums=[3, 10, 2, 1, 20]):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the longest subsequence length of a given list of numbers matches a specified length, and g calculates the longest subsequence length of the same list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming to find the longest increasing subsequence in a list of numbers. The solution function g calculates the longest subsequence length, and the puzzle function f checks if the calculated length matches the specified length.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3684224486351013,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return set1.intersection(set2) == intersection\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\nfrom typing import Set\n\ndef f(nums: Set[int]) -> bool:\n    triplets = {(a, b, c) for a in nums for b in nums for c in nums if a**2 + b**2 == c**2}\n    return any(triplets)\n\ndef g():\n    return {3, 4, 5, 6, 8, 10}\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(intersection: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return set1.intersection(set2) == intersection",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}):\n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the intersection of two sets is equal to a given set, and g returns the intersection of two sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets and set operations in Python, specifically the intersection operation. It also requires understanding how to define functions and use assertions for testing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6183083057403564,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g():\n    return [3, 4, 5, 6, 8, 10]  # Example list potentially containing a Pythagorean triplet\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to check for Pythagorean triplets in a list of numbers.",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    for a in nums:\n        for b in nums:\n            for c in nums:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False",
        "solution_func": "def g():\n    return [3, 4, 5, 6, 8, 10]  # Example list potentially containing a Pythagorean triplet",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a Pythagorean triplet in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there exists a Pythagorean triplet (three numbers that satisfy the Pythagorean theorem) in a given list of integers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5061917304992676,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(palindrome_pattern: List[str]) -> bool:\n    return all(string == string[::-1] for string in palindrome_pattern)\n\ndef g():\n    return ['radar', 'level', 'stats', 'deified']  # List of strings following the palindrome pattern\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for palindrome patterns.",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\ndef f(palindrome_pattern: List[str]) -> bool:\n    return all(string == string[::-1] for string in palindrome_pattern)",
        "solution_func": "def g():\n    return ['radar', 'level', 'stats', 'deified']  # List of strings following the palindrome pattern",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of strings and checks if each string is a palindrome. The solution function g returns a list of strings that are palindromes."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes in a list of strings, which is a common programming concept. It provides a good exercise for understanding list comprehension and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4954788088798523,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))\n\ndef g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves permutations, sets, and random sampling. It also includes the use of the itertools module and assertion testing.",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))\n\ndef g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))",
        "solution_func": "def g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a list of random numbers and checking if the number of unique permutations of the list is equal to the number of distinct permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of generating permutations, sets, and checking for equality.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44045937061309814,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(length: int) -> bool:\n    return length == 4\n\ndef g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the length of the longest increasing subsequence in a list of numbers. It also includes list manipulation and comparison operations.",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(length: int) -> bool:\n    return length == 4",
        "solution_func": "def g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given length is equal to 4, and a function g that uses dynamic programming to find the length of the longest increasing subsequence in a list of numbers. The assertion checks if the length of the longest increasing subsequence is equal to 4."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a comparison of the length of the longest increasing subsequence in a list of numbers with the value 4. The solution function g uses dynamic programming to find this length.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4805208444595337,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(min_coins: int) -> bool:\n    return min_coins == 2\n\ndef g(amount=6) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    coins = [1, 3, 4]\n\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve the minimum coin change problem. It also includes topics such as algorithm optimization and mathematical operations.",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(min_coins: int) -> bool:\n    return min_coins == 2",
        "solution_func": "def g(amount=6) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    coins = [1, 3, 4]\n\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the minimum number of coins needed to make a given amount using a dynamic programming approach. The challenge is to implement a function that calculates the minimum number of coins required for a specific amount and another function that checks if the minimum number of coins is equal to 2."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a dynamic programming problem related to finding the minimum number of coins for a given amount. The solution function uses dynamic programming to calculate the minimum number of coins needed. The puzzle can be used to teach dynamic programming concepts in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.450521856546402,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom math import factorial\nfrom typing import List\n\ndef f(eulerian_count: int, n=4) -> bool:\n    def count_eulerian_circuits(n):\n        return factorial(n - 1)\n\n    return count_eulerian_circuits(n) == eulerian_count\n\ndef g(n=4) -> int:\n    return factorial(n - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from math import factorial\nfrom typing import List\n\ndef f(eulerian_count: int, n=4) -> bool:\n    def count_eulerian_circuits(n):\n        return factorial(n - 1)\n\n    return count_eulerian_circuits(n) == eulerian_count",
        "solution_func": "def g(n=4) -> int:\n    return factorial(n - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the number of Eulerian circuits in a complete graph with a given number of vertices, and checking if the calculated value matches the provided count."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Eulerian circuits, factorial calculation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5794740915298462,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Set Operations, Backtracking",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)",
        "solution_func": "def g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that generates all permutations of a given string and then checks if the generated permutations match a given list of strings."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion, backtracking, and set comparison in Python. It provides a hands-on practice for implementing a permutation algorithm and comparing sets of strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4184030592441559,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str, char='a') -> bool:\n    return s == s[::-1] and char in s\n\ndef g(char='a') -> str:\n    palindrome_half = 'abcde' + char + 'edcba'  # Example palindrome string with specified character\n    return palindrome_half + palindrome_half[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n",
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str, char='a') -> bool:\n    return s == s[::-1] and char in s",
        "solution_func": "def g(char='a') -> str:\n    palindrome_half = 'abcde' + char + 'edcba'  # Example palindrome string with specified character\n    return palindrome_half + palindrome_half[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given string is a palindrome and contains a specified character, and a function g that generates a palindrome string with the specified character. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5302079916000366,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Set Operations, Brute Force Search, and Conditional Logic.",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n",
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value",
        "quality": [
            null
        ],
        "description": [
            "Given a list of integers, the puzzle function f checks if there are two numbers in the list that sum up to a target value. The solution function g returns a pair of numbers that sum up to the target value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find a pair of numbers that sum up to a target value in a list. The solution function provides an example pair that satisfies the condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5273361802101135,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    sentence = ' '.join(words)\n    return sentence.endswith('.')  # Check if the concatenated words end with a period\n\ndef g() -> List[str]:\n    return ['This', 'is', 'a', 'valid', 'sentence', '.']  # Example list of words forming a valid sentence\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to concatenate words and check if the sentence ends with a period.",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n",
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    sentence = ' '.join(words)\n    return sentence.endswith('.')  # Check if the concatenated words end with a period",
        "solution_func": "def g() -> List[str]:\n    return ['This', 'is', 'a', 'valid', 'sentence', '.']  # Example list of words forming a valid sentence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires creating a function that checks if a list of words forms a valid sentence by checking if the concatenated words end with a period."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function that concatenates a list of words into a sentence and then checks if the sentence ends with a period. The solution function provides an example list of words that form a valid sentence.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.36718595027923584,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(smallest_divisible: int) -> bool:\n    return smallest_divisible == 2520\n\ndef g(n=10):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    result = 1\n    for i in range(2, n + 1):\n        result = lcm(result, i)\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Number Theory (factors, primes, etc.) and Mathematical Operations.",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(sum_combination: int) -> bool:\n    return sum_combination == 20\n\ndef g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(smallest_divisible: int) -> bool:\n    return smallest_divisible == 2520",
        "solution_func": "def g(n=10):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    result = 1\n    for i in range(2, n + 1):\n        result = lcm(result, i)\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the smallest number that is divisible by all numbers from 1 to a given input value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the least common multiple (LCM) of numbers from 1 to a given input value and checking if it equals a specific number (2520). The solution function calculates the LCM using a helper function for greatest common divisor (GCD).",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6018449664115906,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = numbers[0]\n    for num in numbers[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Mathematical Operations, Dynamic Programming, and Algorithm Optimization.",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(sum_combination: int) -> bool:\n    return sum_combination == 20\n\ndef g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int) -> bool:\n    return max_sum == 6",
        "solution_func": "def g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = numbers[0]\n    for num in numbers[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum sum of a subarray within a given list of numbers and checking if the maximum sum is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the maximum sum of a subarray using dynamic programming and comparing it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.47518134117126465,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 55\n\ndef g(n=10):\n    def multiply_matrices(a, b):\n        return [[a[0][0]*b[0][0] + a[0][1]*b[1][0], a[0][0]*b[0][1] + a[0][1]*b[1][1]],\n                [a[1][0]*b[0][0] + a[1][1]*b[1][0], a[1][0]*b[0][1] + a[1][1]*b[1][1]]]\n\n    def power_matrix(matrix, power):\n        result = [[1, 0], [0, 1]]\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply_matrices(result, matrix)\n            matrix = multiply_matrices(matrix, matrix)\n            power //= 2\n        return result\n\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    result_matrix = power_matrix(fibonacci_matrix, n-1)\n    return result_matrix[0][0]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves matrix multiplication and exponentiation, which falls under Mathematical Operations and Algorithm Optimization.",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
            "\ndef f(sum_combination: int) -> bool:\n    return sum_combination == 20\n\ndef g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 55",
        "solution_func": "def g(n=10):\n    def multiply_matrices(a, b):\n        return [[a[0][0]*b[0][0] + a[0][1]*b[1][0], a[0][0]*b[0][1] + a[0][1]*b[1][1]],\n                [a[1][0]*b[0][0] + a[1][1]*b[1][0], a[1][0]*b[0][1] + a[1][1]*b[1][1]]]\n\n    def power_matrix(matrix, power):\n        result = [[1, 0], [0, 1]]\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply_matrices(result, matrix)\n            matrix = multiply_matrices(matrix, matrix)\n            power //= 2\n        return result\n\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    result_matrix = power_matrix(fibonacci_matrix, n-1)\n    return result_matrix[0][0]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the 10th Fibonacci number is equal to 55 using matrix multiplication and exponentiation."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of matrix multiplication, exponentiation, and Fibonacci sequence to solve.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4968964457511902,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if grid[row][i] == num or grid[i][col] == num or grid[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if grid[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            grid[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            grid[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in grid)\n\ndef g(grid=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n           [6, 0, 0, 1, 9, 5, 0, 0, 0],\n           [0, 9, 8, 0, 0, 0, 0, 6, 0],\n           [8, 0, 0, 0, 6, 0, 0, 0, 3],\n           [4, 0, 0, 8, 0, 3, 0, 0, 1],\n           [7, 0, 0, 0, 2, 0, 0, 0, 6],\n           [0, 6, 0, 0, 0, 0, 2, 8, 0],\n           [0, 0, 0, 4, 1, 9, 0, 0, 5],\n           [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return grid\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(sequence: List[int]) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] + sequence[i+1] == sequence[i+2] for i in range(len(sequence) - 2))\n\ndef g(length=10):\n    fibonacci = [0, 1]\n    while len(fibonacci) < length:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n",
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if grid[row][i] == num or grid[i][col] == num or grid[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if grid[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            grid[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            grid[i][j] = 0\n                    return False\n        return True\n\n    solve_sudoku()\n    return all(all(cell != 0 for cell in row) for row in grid)",
        "solution_func": "def g(grid=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n           [6, 0, 0, 1, 9, 5, 0, 0, 0],\n           [0, 9, 8, 0, 0, 0, 0, 6, 0],\n           [8, 0, 0, 0, 6, 0, 0, 0, 3],\n           [4, 0, 0, 8, 0, 3, 0, 0, 1],\n           [7, 0, 0, 0, 2, 0, 0, 0, 6],\n           [0, 6, 0, 0, 0, 0, 2, 8, 0],\n           [0, 0, 0, 4, 1, 9, 0, 0, 5],\n           [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return grid",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver using a recursive backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion, backtracking, and nested loops to solve a Sudoku puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4407672882080078,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: float, num1=10, num2=5, op='/') -> bool:\n    try:\n        if op == '+':\n            return num1 + num2 == result\n        elif op == '-':\n            return num1 - num2 == result\n        elif op == '*':\n            return num1 * num2 == result\n        elif op == '/':\n            return num1 / num2 == result\n    except ZeroDivisionError:\n        return False\n\ndef g(num1=10, num2=5, op='/'):\n    try:\n        if op == '+':\n            return num1 + num2\n        elif op == '-':\n            return num1 - num2\n        elif op == '*':\n            return num1 * num2\n        elif op == '/':\n            return num1 / num2\n    except ZeroDivisionError:\n        return None\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and Exception Handling.",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)\n\ndef g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: float, num1=10, num2=5, op='/') -> bool:\n    try:\n        if op == '+':\n            return num1 + num2 == result\n        elif op == '-':\n            return num1 - num2 == result\n        elif op == '*':\n            return num1 * num2 == result\n        elif op == '/':\n            return num1 / num2 == result\n    except ZeroDivisionError:\n        return False",
        "solution_func": "def g(num1=10, num2=5, op='/'):\n    try:\n        if op == '+':\n            return num1 + num2\n        elif op == '-':\n            return num1 - num2\n        elif op == '*':\n            return num1 * num2\n        elif op == '/':\n            return num1 / num2\n    except ZeroDivisionError:\n        return None",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if a mathematical operation performed by g results in a given value without errors."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of basic arithmetic operations and error handling in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5735936164855957,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: set, set1={1, 2, 3}, set2={2, 3, 4}) -> bool:\n    return set1.symmetric_difference(set2) == result\n\ndef g(set1={1, 2, 3}, set2={2, 3, 4}):\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)\n\ndef g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(result: set, set1={1, 2, 3}, set2={2, 3, 4}) -> bool:\n    return set1.symmetric_difference(set2) == result",
        "solution_func": "def g(set1={1, 2, 3}, set2={2, 3, 4}):\n    return set1.symmetric_difference(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to define a function that checks if the symmetric difference of two sets matches a given result set."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding the symmetric_difference method in Python sets and implementing a function that returns True if the symmetric difference of two sets matches a given result set.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5599227547645569,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(result: float, num=16) -> bool:\n    try:\n        return math.isclose(math.sqrt(num), result)\n    except ValueError:\n        return False\n\ndef g(num=16):\n    try:\n        return math.sqrt(num)\n    except ValueError:\n        return None\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and exception handling.",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)\n\ndef g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "import math\n\ndef f(result: float, num=16) -> bool:\n    try:\n        return math.isclose(math.sqrt(num), result)\n    except ValueError:\n        return False",
        "solution_func": "def g(num=16):\n    try:\n        return math.sqrt(num)\n    except ValueError:\n        return None",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the square root of a given number is close to a given result, and g calculates the square root of a given number. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the math module in Python to calculate square roots and check for closeness. It also demonstrates the use of try-except blocks for error handling.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6809705495834351,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    letters = string.ascii_lowercase\n    half_length = random.randint(2, 6)\n    half_string = ''.join(random.choice(letters) for _ in range(half_length))\n    return half_string + half_string[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)\n\ndef g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    letters = string.ascii_lowercase\n    half_length = random.randint(2, 6)\n    half_string = ''.join(random.choice(letters) for _ in range(half_length))\n    return half_string + half_string[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a random string and its palindrome. The puzzle tests whether the generated string and its palindrome satisfy the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.40345922112464905,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Sorting and Ordering, Conditional Logic, List Operations",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n    \n    for row in board:\n        if not is_valid(row):\n            return False\n        \n    for col in range(9):\n        if not is_valid([board[i][col] for i in range(9)]):\n            return False\n        \n    for i in range(3):\n        for j in range(3):\n            subgrid = [board[x][y] for x in range(3*i, 3*i+3) for y in range(3*j, 3*j+3)]\n            if not is_valid(subgrid):\n                return False\n    return True\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(squares: List[List[int]], m=35, n=46, target=1610) -> bool:\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 35, n = 46, target = 1610):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False",
        "solution_func": "def g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that checks if there are overlapping intervals in a list of intervals."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of intervals based on the start time and then checking for any overlapping intervals.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5084567666053772,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man a plan a canal Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum, target_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index], target_sum) or can_partition(nums, index + 1, current_sum, target_sum)\n\n    return can_partition(nums, 0, 0, target_sum)\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(prime_pairs: List[List[int]], pattern=(2, 4, 6)) -> bool:\n    def check_pattern(pair, pattern):\n        return abs(pair[1] - pair[0]) in pattern\n\n    return any(check_pattern(pair, pattern) for pair in prime_pairs)\n\ndef g(limit=20, pattern=(2, 4, 6)):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, limit) if is_prime(num)]\n    prime_pairs = [[primes[i], primes[j]] for i in range(len(primes)) for j in range(i + 1, len(primes))]\n    return prime_pairs\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"A man a plan a canal Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function to check if a given string is a palindrome after removing spaces and converting to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a string is a palindrome after removing spaces and converting to lowercase.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5924205183982849,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int, nums=[1, 2, 3, 1]) -> bool:\n    def helper(nums):\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n        \n        return max(incl, excl)\n\n    return helper(nums) == max_sum\n\ndef g(nums=[1, 2, 3, 1]):\n    return sum(nums[::2]) if sum(nums[::2]) > sum(nums[1::2]) else sum(nums[1::2])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Dynamic Programming and Mathematical Operations.",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\ndef f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int, nums=[1, 2, 3, 1]) -> bool:\n    def helper(nums):\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n        \n        return max(incl, excl)\n\n    return helper(nums) == max_sum",
        "solution_func": "def g(nums=[1, 2, 3, 1]):\n    return sum(nums[::2]) if sum(nums[::2]) > sum(nums[1::2]) else sum(nums[1::2])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the maximum sum of a list of numbers can be achieved using a specific algorithm. The solution function g calculates the maximum sum of alternate elements in the list and returns it. The puzzle tests if the solution function g satisfies the condition defined in function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a dynamic programming algorithm to find the maximum sum of a list of numbers. The solution function g calculates the maximum sum of alternate elements in the list and compares it with the maximum sum calculated by the algorithm in function f. If the two sums match, the assertion passes.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4870098829269409,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Probability and Statistics, Importing Modules (Itertools, etc.)",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\ndef f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob",
        "solution_func": "def g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the probability of the sum of two dice rolls being equal to 7."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of probability calculations and list comprehensions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46905767917633057,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(ways: int, n=4) -> bool:\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways\n\ndef g(n=4):\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, recursion, and algorithm optimization.",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\ndef f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(ways: int, n=4) -> bool:\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways",
        "solution_func": "def g(n=4):\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the output of g satisfies a specific condition related to the Fibonacci sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Fibonacci sequence and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5953795313835144,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of words and checking if it is sorted correctly after shuffling. This involves concepts of sorting and ordering. Additionally, the use of the `random` module for shuffling the list falls under importing modules.",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(sorted_list: list) -> bool:\n    return sorted_list == sorted(sorted_list, reverse=True)\n\ndef g():\n    import random\n    random_list = random.sample(range(1, 100), 10)\n    return sorted(random_list, reverse=True)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)",
        "solution_func": "def g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a list of words is sorted in alphabetical order after shuffling it."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves shuffling a list of words and then checking if the words are sorted in alphabetical order.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45015591382980347,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(cards: List[str]) -> bool:\n    def is_valid_permutation(shuffled, original):\n        return all(card in original for card in shuffled) and len(shuffled) == len(original)\n\n    return is_valid_permutation(cards, ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] * 4)\n\ndef g():\n    cards = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] * 4\n    import random\n    shuffled_deck = random.sample(cards, k=len(cards))\n    return shuffled_deck\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves permutations and combinations to check if a list is a valid permutation of another list.",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(cards: List[str]) -> bool:\n    def is_valid_permutation(shuffled, original):\n        return all(card in original for card in shuffled) and len(shuffled) == len(original)\n\n    return is_valid_permutation(cards, ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] * 4)",
        "solution_func": "def g():\n    cards = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] * 4\n    import random\n    shuffled_deck = random.sample(cards, k=len(cards))\n    return shuffled_deck",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of cards is a valid permutation of a standard deck of cards."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation, permutations, and boolean functions in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4321495592594147,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(product: int, numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> bool:\n    return product == max(a * b for a in numbers for b in numbers if a != b)\n\ndef g(numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> int:\n    return max(a * b for a in numbers for b in numbers if a != b)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to find the maximum product of two numbers in a list.",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\ndef f(numbers: list[int]) -> bool:\n    for a in numbers:\n        for b in numbers:\n            for c in numbers:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g(size: int = 5) -> list[int]:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Sample numbers where a Pythagorean triplet exists\n    return numbers[:size]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(product: int, numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> bool:\n    return product == max(a * b for a in numbers for b in numbers if a != b)",
        "solution_func": "def g(numbers=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> int:\n    return max(a * b for a in numbers for b in numbers if a != b)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum product of two distinct numbers from a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given product is equal to the maximum product of two distinct numbers from a list. The solution function g finds the maximum product of two distinct numbers from the same list and returns it. The assertion at the end checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.635694146156311,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(target: int, numbers=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) -> bool:\n    return any(sum(comb) == target for r in range(1, len(numbers) + 1) for comb in combinations(numbers, r))\n\ndef g(target: int = 20, numbers=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) -> int:\n    return target\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves permutations and combinations to find a subset of numbers that sum up to a target value.",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\ndef f(numbers: list[int]) -> bool:\n    for a in numbers:\n        for b in numbers:\n            for c in numbers:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g(size: int = 5) -> list[int]:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Sample numbers where a Pythagorean triplet exists\n    return numbers[:size]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(target: int, numbers=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) -> bool:\n    return any(sum(comb) == target for r in range(1, len(numbers) + 1) for comb in combinations(numbers, r))",
        "solution_func": "def g(target: int = 20, numbers=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) -> int:\n    return target",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a combination of numbers from a given list that adds up to a target number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f checks if there exists a combination of numbers from the list that sums up to the target number. The function g simply returns the target number. The assertion checks if the function f with the output of function g as input returns True.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5208494067192078,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(length: int, sequence=[3, 4, 2, 8, 10, 5, 1]) -> bool:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis) == length\n\ndef g(sequence=[3, 4, 2, 8, 10, 5, 1]) -> int:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\ndef f(numbers: list[int]) -> bool:\n    for a in numbers:\n        for b in numbers:\n            for c in numbers:\n                if a**2 + b**2 == c**2:\n                    return True\n    return False\n\ndef g(size: int = 5) -> list[int]:\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Sample numbers where a Pythagorean triplet exists\n    return numbers[:size]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(length: int, sequence=[3, 4, 2, 8, 10, 5, 1]) -> bool:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis) == length",
        "solution_func": "def g(sequence=[3, 4, 2, 8, 10, 5, 1]) -> int:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given sequence of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding dynamic programming concepts to find the length of the longest increasing subsequence in a sequence of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4290151000022888,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g() -> str:\n    palindrome = \"racecar\"\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation to check if a word is a palindrome. It also includes conditional logic to compare the word with its reverse. The solution provides a hardcoded palindrome word to test the function.",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g() -> str:\n    palindrome = \"racecar\"\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that checks if a given word is a palindrome by comparing it with its reverse. The solution function g() returns the word 'racecar', which is a palindrome. The assert statement confirms that the solution function g() correctly identifies the palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6335045695304871,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(dice_faces: tuple) -> bool:\n    return sum(dice_faces) == 7\n\ndef g():\n    dice1 = random.randint(1, 6)\n    dice2 = 7 - dice1\n    return (dice1, dice2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves random number generation and checking the sum of the generated numbers.",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(colors_drawn: List[str]) -> bool:\n    target_color = \"red\"\n    total_draws = len(colors_drawn)\n    red_draws = colors_drawn.count(target_color)\n    probability = red_draws / total_draws\n\n    return probability > 0.3\n\ndef g():\n    return [\"red\", \"blue\", \"red\", \"green\", \"red\", \"yellow\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(dice_faces: tuple) -> bool:\n    return sum(dice_faces) == 7",
        "solution_func": "def g():\n    dice1 = random.randint(1, 6)\n    dice2 = 7 - dice1\n    return (dice1, dice2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating two random numbers between 1 and 6, and checking if their sum is equal to 7."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of random number generation, tuple manipulation, and comparison operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5808547735214233,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choices(letters, k=random.randint(5, 10)))  # Generate random palindrome string\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(colors_drawn: List[str]) -> bool:\n    target_color = \"red\"\n    total_draws = len(colors_drawn)\n    red_draws = colors_drawn.count(target_color)\n    probability = red_draws / total_draws\n\n    return probability > 0.3\n\ndef g():\n    return [\"red\", \"blue\", \"red\", \"green\", \"red\", \"yellow\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choices(letters, k=random.randint(5, 10)))  # Generate random palindrome string\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string and its reverse. The assertion checks if the generated string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding palindrome strings and string manipulation in Python. It provides a practical exercise to test the understanding of string reversal and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.427410751581192,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17  # A prime number to test the function f\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given number is a prime number or not.",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17  # A prime number to test the function f",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is a prime number, and a function g() that returns a specific number (17 in this case) to test the prime number function f. The puzzle requires students to understand prime number checking logic in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a basic prime number checking algorithm and requires students to understand how to test the function with a specific input to verify its correctness.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6153120994567871,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")  # Convert string to lowercase and remove spaces\n    return s == s[::-1]  # Check if the string is equal to its reverse\n\ndef g():\n    return \"Able was I saw Elba\"  # A palindrome string to test the function f\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")  # Convert string to lowercase and remove spaces\n    return s == s[::-1]  # Check if the string is equal to its reverse",
        "solution_func": "def g():\n    return \"Able was I saw Elba\"  # A palindrome string to test the function f",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome (reads the same forwards and backwards) after converting it to lowercase and removing spaces. The solution function g returns a specific palindrome string to test the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves testing a function that checks for palindromes in strings, which is a common programming concept. It provides a simple and clear example for students to understand and practice string manipulation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.508313000202179,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\") -> str:\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Conditional Logic are used in the problem f and solution g.",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\") -> str:\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.483577162027359,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    primes = [True] * (num + 1)\n    primes[0], primes[1] = False, False\n    for i in range(2, int(num**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, num + 1, i):\n                primes[j] = False\n    return primes[num]\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using the Sieve of Eratosthenes algorithm.",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    def find_permutations(nums):\n        return list(permutations(nums))\n\n    return len(find_permutations(nums)) == len(set(find_permutations(nums)))\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    primes = [True] * (num + 1)\n    primes[0], primes[1] = False, False\n    for i in range(2, int(num**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, num + 1, i):\n                primes[j] = False\n    return primes[num]",
        "solution_func": "def g(num=17):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is a prime number using the Sieve of Eratosthenes algorithm. The solution function g(num) simply returns a predefined number. The puzzle is to determine if the predefined number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and the Sieve of Eratosthenes algorithm. The student needs to recognize that the solution function returns a predefined number and the puzzle function checks if that number is prime.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6118754744529724,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that returns True if the word is a palindrome (reads the same forwards and backwards), and a function g() that returns the word 'radar'. The assert statement checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6371104717254639,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])\n\ndef g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Conditional Logic and Brute Force Search.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    return set(combinations_list) == {('a', 'b'), ('a', 'c'), ('b', 'c')}\n\ndef g(chars=['a', 'b', 'c'], length=2) -> List[str]:\n    return list(combinations(chars, length))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])",
        "solution_func": "def g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding if any pair of numbers in a list sums up to a target sum of 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for pairs of numbers in a list that add up to a specific target sum. The solution function simply returns the input list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4742017984390259,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Set\n\ndef f(sets_list: List[Set[int]], subset={2, 4}) -> bool:\n    # Check if the subset is present in any of the sets in the list\n    return any(subset.issubset(s) for s in sets_list)\n\ndef g(elements=[[1, 2, 3], [2, 4, 6], [3, 5, 7]]) -> List[Set[int]]:\n    # Generate sets of integers based on the input elements\n    return [set(nums) for nums in elements]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combinations_list: List[str]) -> bool:\n    return set(combinations_list) == {('a', 'b'), ('a', 'c'), ('b', 'c')}\n\ndef g(chars=['a', 'b', 'c'], length=2) -> List[str]:\n    return list(combinations(chars, length))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Set\n\ndef f(sets_list: List[Set[int]], subset={2, 4}) -> bool:\n    # Check if the subset is present in any of the sets in the list\n    return any(subset.issubset(s) for s in sets_list)",
        "solution_func": "def g(elements=[[1, 2, 3], [2, 4, 6], [3, 5, 7]]) -> List[Set[int]]:\n    # Generate sets of integers based on the input elements\n    return [set(nums) for nums in elements]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions: f checks if a specific subset is present in any of the sets in a list of sets, and g generates sets of integers based on input elements. The assertion checks if the subset {2, 4} is present in any of the sets generated by g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with sets, list comprehension, and checking subset presence. It is a good exercise to practice these concepts in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.42699605226516724,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(input_str: str) -> bool:\n    return input_str == input_str[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(intersection: set[int]) -> bool:\n    A = {1, 2, 3, 4, 5}\n    B = {3, 4, 5, 6, 7}\n    return intersection == A.intersection(B)\n\ndef g():\n    return {3, 4, 5}\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(input_str: str) -> bool:\n    return input_str == input_str[::-1]",
        "solution_func": "def g():\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome (reads the same forwards and backwards) by comparing the string with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f that checks if a given string is a palindrome, and a function g that returns the string 'level'. The assertion tests if the function f returns True when applied to the output of function g.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5912104845046997,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list[int]) -> bool:\n    return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of numbers is sorted in ascending order.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(intersection: set[int]) -> bool:\n    A = {1, 2, 3, 4, 5}\n    B = {3, 4, 5, 6, 7}\n    return intersection == A.intersection(B)\n\ndef g():\n    return {3, 4, 5}\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list[int]) -> bool:\n    return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of numbers is sorted in non-decreasing order, and a function g that returns a specific list of numbers. The puzzle is to ensure that function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, range function, and the all() function in Python. It also tests the ability to check if a list is sorted in non-decreasing order.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5932111740112305,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    word = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))\n\ndef g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    word = ''.join(random.choices(string.ascii_lowercase, k=5))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random 5-character string followed by its reverse. The puzzle requires g() to generate a palindrome string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.45243385434150696,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, total=55) -> bool:\n    return n == int((total * (total + 1) / 2) ** 2)\n\ndef g(total=55) -> int:\n    return int((total * (total + 1) / 2) ** 2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 65,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
            "\ndef f(s: int, n=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return s == sum(num for num in range(2, n) if is_prime(num))\n\ndef g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return sum(num for num in range(2, n) if is_prime(num))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int, total=55) -> bool:\n    return n == int((total * (total + 1) / 2) ** 2)",
        "solution_func": "def g(total=55) -> int:\n    return int((total * (total + 1) / 2) ** 2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(n) and g(), where f checks if a given integer n is equal to the square of the sum of numbers from 1 to a specified total, and g calculates the square of the sum of numbers from 1 to a specified total. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a mathematical calculation and comparison, which can be a good exercise for students to understand function composition and mathematical operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6417847275733948,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int], target_sum=6) -> bool:\n    def is_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def check_triangle(triplet):\n        return is_triangle(*triplet)\n\n    return any(check_triangle(triplet) for triplet in nums)\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    import itertools\n    return list(itertools.combinations(nums, 3))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as List Manipulation, Itertools Module, Combinations, and Conditional Logic.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, nums=[3, 10, 2, 1, 20]) -> bool:\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subsequence_length\n\ndef g(nums=[3, 10, 2, 1, 20]):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[str], target_permutation='abc') -> bool:\n    return target_permutation in permutations\n\ndef g(string='abc'):\n    import itertools\n    return [''.join(perm) for perm in itertools.permutations(string)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int], target_sum=6) -> bool:\n    def is_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def check_triangle(triplet):\n        return is_triangle(*triplet)\n\n    return any(check_triangle(triplet) for triplet in nums)",
        "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]):\n    import itertools\n    return list(itertools.combinations(nums, 3))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if there exists a triplet of numbers in a given list that can form a valid triangle."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand the concept of triangles and how to check if a triplet of numbers can form a valid triangle based on the triangle inequality theorem.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5126837491989136,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int) -> bool:\n    return longest_subsequence_length >= 3\n\ndef g(str1=\"abcde\", str2=\"ace\"):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the longest common subsequence between two strings.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int) -> bool:\n    return longest_subsequence_length >= 3",
        "solution_func": "def g(str1=\"abcde\", str2=\"ace\"):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest common subsequence between two given strings and checking if it is greater than or equal to 3."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming to find the longest common subsequence between two strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.46692347526550293,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g():\n    # Generate a palindrome string for testing\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n    return validate(root)\n\ndef g():\n    node1 = TreeNode(2)\n    node2 = TreeNode(1)\n    node3 = TreeNode(3)\n    node1.left = node2\n    node1.right = node3\n    return node1\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g():\n    # Generate a palindrome string for testing\n    return \"A man, a plan, a canal: Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function to check if a given string is a palindrome after removing non-alphanumeric characters and ignoring case. The solution generates a test string 'A man, a plan, a canal: Panama' and checks if it is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes in a case-insensitive manner after removing non-alphanumeric characters. The solution generates a test string and verifies if it is a palindrome according to the defined criteria.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.39928826689720154,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(s)\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and recursion to check if a given string is a palindrome.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(s)",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f(s: str) that checks if a given string is a palindrome using recursion. The solution function g() returns the string 'radar', and the puzzle is solved if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and checking for palindromes in strings. It is a suitable challenge for students learning Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4906761944293976,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    def swap_without_temp(nums):\n        nums[0] = nums[0] ^ nums[1]\n        nums[1] = nums[0] ^ nums[1]\n        nums[0] = nums[0] ^ nums[1]\n        return nums\n\n    return swap_without_temp(nums) == [7, 3]\n\ndef g():\n    return [3, 7]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Binary Operations (bitwise shifting, AND, OR) as it uses XOR bitwise operation to swap two numbers without using a temporary variable.",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    def swap_without_temp(nums):\n        nums[0] = nums[0] ^ nums[1]\n        nums[1] = nums[0] ^ nums[1]\n        nums[0] = nums[0] ^ nums[1]\n        return nums\n\n    return swap_without_temp(nums) == [7, 3]",
        "solution_func": "def g():\n    return [3, 7]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that swaps two elements in a list without using a temporary variable, and the solution checks if the swap function works correctly for a specific input list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves bitwise XOR operations to swap elements in a list without using a temporary variable. The solution function g returns a specific list to test the swap function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5258162021636963,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount\n\ndef g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, List Operations, and Brute Force Search.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount",
        "solution_func": "def g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if the sum of a list of coin denominations equals a target amount, and a function g that generates a list of coin denominations to reach the target amount. The solution g sorts the coin denominations in descending order and iterates through them to find the combination that equals the target amount."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to use lists, loops, and conditionals in Python to solve a coin denomination problem. It also requires understanding the concept of sorting and iterating through a list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4916479289531708,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(5, 10)))\n    return word + word[::-1]  # Generate a palindrome string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization, Importing Modules",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    import random\n\n    n = random.randint(3, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]  # Make the matrix symmetric\n\n    return matrix\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(5, 10)))\n    return word + word[::-1]  # Generate a palindrome string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string and checks if it satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.40386489033699036,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    import string\n    import random\n\n    letters = string.ascii_lowercase\n    n = random.randint(3, 8)\n    palindrome = ''.join(random.choice(letters) for _ in range(n))\n    return palindrome + palindrome[::-1]  # Generates a palindrome string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\ndef f(prob: float, total_balls=10) -> bool:\n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n-1)\n\n    def combinations(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n\n    red_balls = 3\n    favorable_outcomes = combinations(red_balls, 1)\n    total_outcomes = combinations(total_balls, 1)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g(total_balls=10):\n    return 3 / total_balls  # Probability of drawing a red ball from a bag of 10 balls with 3 red balls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    import string\n    import random\n\n    letters = string.ascii_lowercase\n    n = random.randint(3, 8)\n    palindrome = ''.join(random.choice(letters) for _ in range(n))\n    return palindrome + palindrome[::-1]  # Generates a palindrome string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a palindrome string using random letters. The assertion checks if the generated palindrome string is correctly identified as a palindrome by the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in strings and generating palindrome strings using random letters in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43528568744659424,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to find the maximum sum of a subarray. It also includes brute force search to iterate through the array elements. Additionally, it demonstrates algorithm optimization by using Kadane's algorithm for finding the maximum subarray sum.",
        "idx_generation": 66,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int) -> bool:\n    return max_sum == 6",
        "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum sum of a subarray within a given list of integers and checking if the maximum sum is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the maximum sum of a subarray using dynamic programming and comparing it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.4540327489376068,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int) -> bool:\n    return factorial == 120\n\ndef g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and recursion.",
        "idx_generation": 66,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(total_ways: int) -> bool:\n    return total_ways == 5  # Total number of ways to climb 4 steps with 1 or 2 steps at a time\n\ndef g(n=4):\n    def climb_stairs(n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n + 1):\n            third = first + second\n            first, second = second, third\n        return second\n\n    return climb_stairs(n)\n\nassert f(g()) == True\n",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int) -> bool:\n    return factorial == 120",
        "solution_func": "def g(n=5):\n    if n == 0:\n        return 1\n    return n * g(n - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a recursive function to calculate the factorial of a number and check if it equals 120."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a recursive factorial function and checking if it returns the correct value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.727540135383606,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    def has_cycle(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, rec_stack):\n                return True\n\n    return False\n\ndef g():\n    return [[1], [2], [0]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves graph theory and backtracking.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int, nums=[3, 2, 5, 10, 7]) -> bool:\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(nums=[3, 2, 5, 10, 7]):\n    incl = 0\n    excl = 0\n    for num in nums:\n        new_excl = max(incl, excl)\n        incl = excl + num\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    def has_cycle(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, rec_stack):\n                return True\n\n    return False",
        "solution_func": "def g():\n    return [[1], [2], [0]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking for cycles in a directed graph represented as an adjacency list using a depth-first search algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of graph theory concepts and depth-first search algorithm in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.2984275817871094,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list) -> bool:\n    numbers.sort()\n    a, b, c = numbers\n    return a**2 + b**2 == c**2\n\ndef g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            for c in range(b, 100):\n                if a**2 + b**2 == c**2:\n                    return [a, b, c]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list) -> bool:\n    numbers.sort()\n    a, b, c = numbers\n    return a**2 + b**2 == c**2",
        "solution_func": "def g():\n    for a in range(1, 100):\n        for b in range(a, 100):\n            for c in range(b, 100):\n                if a**2 + b**2 == c**2:\n                    return [a, b, c]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet (a, b, c) where a^2 + b^2 = c^2 within a certain range of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Pythagorean triplets and nested loops in Python to find the correct triplet that satisfies the condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5398808121681213,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"racecar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'racecar'. The assertion checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.666115939617157,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    factors = [i for i in range(1, n) if n % i == 0]\n    return sum(factors) == n\n\ndef g():\n    return 28\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves finding factors of a number and checking if the sum of factors is equal to the number itself.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    prime_candidate = 2\n    while True:\n        if all(prime_candidate % i != 0 for i in range(2, int(prime_candidate**0.5) + 1)):\n            return prime_candidate\n        prime_candidate += 1\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    factors = [i for i in range(1, n) if n % i == 0]\n    return sum(factors) == n",
        "solution_func": "def g():\n    return 28",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a number whose sum of factors equals the number itself."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is equal to the sum of its factors. The solution function returns the number 28, which is a perfect number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.700756311416626,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g():\n    import random\n\n    length = random.randint(5, 10)\n    random_numbers = [random.randint(1, 10) for _ in range(length)]\n    return random_numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations to check for duplicates in a list of numbers generated randomly.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))",
        "solution_func": "def g():\n    import random\n\n    length = random.randint(5, 10)\n    random_numbers = [random.randint(1, 10) for _ in range(length)]\n    return random_numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to generate a list of random numbers and check if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a list of random numbers and checking for duplicates using the set data structure in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.46758371591567993,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    if len(nums) <= 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g():\n    import random\n\n    start = random.randint(1, 5)\n    diff = random.randint(1, 5)\n    length = random.randint(3, 8)\n    arithmetic_seq = [start + diff*i for i in range(length)]\n    return arithmetic_seq\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Mathematical Operations, Conditional Logic, and List Operations.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    if len(nums) <= 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))",
        "solution_func": "def g():\n    import random\n\n    start = random.randint(1, 5)\n    diff = random.randint(1, 5)\n    length = random.randint(3, 8)\n    arithmetic_seq = [start + diff*i for i in range(length)]\n    return arithmetic_seq",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(nums: list) that checks if a given list of numbers forms an arithmetic sequence. Another function g() generates a random arithmetic sequence and the puzzle is to ensure that function f correctly identifies it as an arithmetic sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for an arithmetic sequence in a list of numbers and generating random arithmetic sequences using the g() function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.480844646692276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(is_prime) -> bool:\n    def is_prime_number(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return is_prime_number(is_prime)\n\ndef g(limit=30, num=17):\n    primes = [i for i in range(2, limit) if all(i % j != 0 for j in range(2, int(i ** 0.5) + 1))]\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, list comprehension, and assertion testing.",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(is_prime) -> bool:\n    def is_prime_number(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return is_prime_number(is_prime)",
        "solution_func": "def g(limit=30, num=17):\n    primes = [i for i in range(2, limit) if all(i % j != 0 for j in range(2, int(i ** 0.5) + 1))]\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to check if a given number is prime, and then using a list comprehension to find prime numbers up to a specified limit. The solution function returns a specific number and the puzzle checks if this number is prime."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, list comprehensions, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5496463179588318,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g(word=\"racecar\"):\n    return word\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g(word=\"racecar\"):\n    return word",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a word is a palindrome by comparing it to its reverse. The function g returns a default word 'racecar'. The assert statement checks if the function f applied to the result of function g returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6320989727973938,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int, num=5) -> bool:\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    \n    return factorial == recursive_factorial(num)\n\ndef g(num=5):\n    factorial = 1\n    for i in range(1, num + 1):\n        factorial *= i\n    return factorial\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations to calculate the factorial of a number. It also includes conditional logic to check if the calculated factorial matches the input factorial.",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\nimport math\n\ndef f(result: float, num=16) -> bool:\n    try:\n        return math.isclose(math.sqrt(num), result)\n    except ValueError:\n        return False\n\ndef g(num=16):\n    try:\n        return math.sqrt(num)\n    except ValueError:\n        return None\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int, num=5) -> bool:\n    def recursive_factorial(n):\n        if n == 0:\n            return 1\n        return n * recursive_factorial(n - 1)\n    \n    return factorial == recursive_factorial(num)",
        "solution_func": "def g(num=5):\n    factorial = 1\n    for i in range(1, num + 1):\n        factorial *= i\n    return factorial",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the factorial of a given number matches the factorial calculated using a recursive function. The solution function g calculates the factorial of a given number using a loop and returns the result."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding factorial calculation using recursion and loops in Python. It tests the student's knowledge of recursive functions and loops for factorial calculation.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5836822390556335,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Palindrome checking",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku_util(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku_util(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku_util(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n             [6, 0, 0, 1, 9, 5, 0, 0, 0],\n             [0, 9, 8, 0, 0, 0, 0, 6, 0],\n             [8, 0, 0, 0, 6, 0, 0, 0, 3],\n             [4, 0, 0, 8, 0, 3, 0, 0, 1],\n             [7, 0, 0, 0, 2, 0, 0, 0, 6],\n             [0, 6, 0, 0, 0, 0, 2, 8, 0],\n             [0, 0, 0, 4, 1, 9, 0, 0, 5],\n             [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4736838638782501,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking for prime numbers using a simple algorithm. It does not directly relate to any specific topic from the list provided.",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku_util(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku_util(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku_util(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n             [6, 0, 0, 1, 9, 5, 0, 0, 0],\n             [0, 9, 8, 0, 0, 0, 0, 6, 0],\n             [8, 0, 0, 0, 6, 0, 0, 0, 3],\n             [4, 0, 0, 8, 0, 3, 0, 0, 1],\n             [7, 0, 0, 0, 2, 0, 0, 0, 6],\n             [0, 6, 0, 0, 0, 0, 2, 8, 0],\n             [0, 0, 0, 4, 1, 9, 0, 0, 5],\n             [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=17):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "Given a number, function f(num) checks if the number is a prime number. Function g(num) returns a specific number (default is 17). The puzzle requires finding a number for g() such that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and finding a specific number that satisfies the condition for function f(g()).",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6602292060852051,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(5))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Importing Modules (Itertools, etc.), Pattern Recognition",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)\n\ndef g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(5))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(s) and g(), where f(s) checks if a given string is a palindrome after removing spaces and converting to lowercase, and g() generates a random 5-letter word followed by its reverse. The puzzle tests if the generated word satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, random generation, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4044523239135742,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Backtracking",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)",
        "solution_func": "def g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of permutations is valid, and a function g that generates permutations of a given list of numbers. The goal is to ensure that function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate permutations of a list of numbers and checking if those permutations are valid. It also requires knowledge of list manipulation and recursion in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.36214765906333923,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [3], 3: [4], 4: [1, 2]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path))) and len(path) == len(graph)\n\ndef g(graph={1: [2, 3], 2: [3], 3: [4], 4: [1, 2]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Backtracking, Graph Theory (paths, edges, vertices)",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path)))\n\ndef g(graph={1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(path: List[int], graph={1: [2, 3], 2: [3], 3: [4], 4: [1, 2]}) -> bool:\n    return len(path) == len(set(path)) == len(graph) and all(path[i] in graph[path[i - 1]] for i in range(1, len(path))) and len(path) == len(graph)",
        "solution_func": "def g(graph={1: [2, 3], 2: [3], 3: [4], 4: [1, 2]}):\n    def backtrack(curr_path):\n        if len(curr_path) == len(graph):\n            return curr_path\n        for neighbor in graph[curr_path[-1]]:\n            if neighbor not in curr_path:\n                new_path = backtrack(curr_path + [neighbor])\n                if new_path:\n                    return new_path\n        return []\n\n    return backtrack([1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a path in a graph such that each node is visited exactly once and the path forms a cycle. The puzzle checks if a given path satisfies these conditions in a specific graph structure."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of graph traversal and backtracking to find a valid path in the graph. The solution function uses backtracking to find a path that satisfies the conditions specified in the puzzle function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.2919369041919708,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not using a simple algorithm. It covers topics such as Number Theory (primes) and Conditional Logic.",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(ways: int, n=4) -> bool:\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways\n\ndef g(n=4):\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    num = 17\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that checks if a given number is a prime number. The solution function returns a specific number, and the puzzle checks if this number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a function to check for prime numbers and then verifying the correctness of the solution by checking if a specific number is prime.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5743455290794373,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef g():\n    num = 12321\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a number is a palindrome.",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(ways: int, n=4) -> bool:\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways\n\ndef g(n=4):\n    if n <= 1:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int) -> bool:\n    return str(num) == str(num)[::-1]",
        "solution_func": "def g():\n    num = 12321\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given number is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(num) that checks if a given number is a palindrome by comparing it with its reverse. The solution function g() returns a specific number (12321) and asserts that f(g()) is True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6780741214752197,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10\n\ndef g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Geometry and Coordinate Manipulation, as it calculates the distance between points in a 2D plane. It also includes Brute Force Search as it iterates through all pairs of points to find the minimum distance. Finally, it includes Conditional Logic as it checks if the minimum distance is less than 10.",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10",
        "solution_func": "def g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the minimum distance between a set of points and checking if it is less than 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that calculates the minimum distance between all pairs of points and then checks if this minimum distance is less than 10.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4707558751106262,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(words[i] <= words[i+1] for i in range(len(words)-1))\n\ndef g() -> List[str]:\n    return [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"orange\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering.",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n",
            "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(words: List[str]) -> bool:\n    return all(words[i] <= words[i+1] for i in range(len(words)-1))",
        "solution_func": "def g() -> List[str]:\n    return [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"orange\"]",
        "quality": [
            null
        ],
        "description": [
            "Given a list of words, the puzzle function f checks if the words are in alphabetical order. The solution function g returns a list of words in alphabetical order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list comprehension and the all() function in Python. The solution function provides an example list of words in alphabetical order.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4549427926540375,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_unit(unit):\n        unit = [num for num in unit if num != 0]\n        return len(set(unit)) == len(unit)\n\n    def is_valid_sudoku(board):\n        for row in board:\n            if not is_valid_unit(row):\n                return False\n\n        for col in zip(*board):\n            if not is_valid_unit(col):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not is_valid_unit(square):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Conditional Logic, Nested Functions, List Manipulation, Set Operations, and Algorithm Verification.",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_unit(unit):\n        unit = [num for num in unit if num != 0]\n        return len(set(unit)) == len(unit)\n\n    def is_valid_sudoku(board):\n        for row in board:\n            if not is_valid_unit(row):\n                return False\n\n        for col in zip(*board):\n            if not is_valid_unit(col):\n                return False\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not is_valid_unit(square):\n                    return False\n\n        return True\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of nested loops, list comprehensions, and set operations in Python. It also reinforces the concept of checking validity in a Sudoku board.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.511141836643219,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower()\n    s = ''.join(char for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    \n    def generate_palindrome_str(length):\n        letters = string.ascii_letters\n        half_length = length // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n    \n    length = random.randint(3, 10)\n    return generate_palindrome_str(length)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.), Probability and Statistics",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower()\n    s = ''.join(char for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    \n    def generate_palindrome_str(length):\n        letters = string.ascii_letters\n        half_length = length // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n    \n    length = random.randint(3, 10)\n    return generate_palindrome_str(length)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(s) checks if a given string is a palindrome after removing non-alphanumeric characters, and g() generates a random palindrome string of a random length between 3 and 10. The solution g() generates a palindrome string and f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated palindrome string is correctly identified as a palindrome by the function f(s). The solution function g() generates palindrome strings for testing.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.38068026304244995,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lst: list) -> bool:\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            return True\n    return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    num_duplicates = random.randint(2, 5)\n    return [start] * num_duplicates\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for duplicates in the list.",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lst: list) -> bool:\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            return True\n    return False",
        "solution_func": "def g() -> list:\n    import random\n    start = random.randint(1, 5)\n    num_duplicates = random.randint(2, 5)\n    return [start] * num_duplicates",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement two functions in Python. The first function f(lst) checks if there are any consecutive duplicate elements in a list. The second function g() generates a list with a random starting element and a random number of duplicates of that element. The puzzle is to ensure that the function f correctly identifies the presence of consecutive duplicates in the list generated by function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, loops, and random number generation in Python. It also tests the students' ability to write functions that work together to solve a specific problem.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.42459753155708313,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sum_even: int, numbers=[3, 7, 2, 9, 4, 6, 5, 8]) -> bool:\n    return sum_even == sum(num for num in numbers if num % 2 == 0)\n\ndef g(numbers=[3, 7, 2, 9, 4, 6, 5, 8]) -> int:\n    return sum(num for num in numbers if num % 2 == 0)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if the sum of even numbers in a list matches a given input.",
        "idx_generation": 68,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(sorted_list: List[int], values=[3, 7, 1, 9, 4, 2, 6, 5, 8]) -> bool:\n    return sorted_list == sorted(values)\ndef g(values=[3, 7, 1, 9, 4, 2, 6, 5, 8]):\n    return sorted(values)\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sum_even: int, numbers=[3, 7, 2, 9, 4, 6, 5, 8]) -> bool:\n    return sum_even == sum(num for num in numbers if num % 2 == 0)",
        "solution_func": "def g(numbers=[3, 7, 2, 9, 4, 6, 5, 8]) -> int:\n    return sum(num for num in numbers if num % 2 == 0)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f and g, where f checks if the sum of even numbers in a list equals a given value, and g calculates the sum of even numbers in a list. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, conditional statements, and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6067454218864441,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function that checks if a given string is a palindrome after removing non-alphanumeric characters, and a solution function that returns a specific string. The solution function is expected to return a palindrome string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5209650993347168,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    try:\n        cleaned_string = ''.join(char.lower() for char in string if char.isalnum())\n        return cleaned_string == cleaned_string[::-1]\n    except:\n        return False\n\ndef g() -> str:\n    import random\n    import string\n    alphanumeric_chars = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(5, 10)))\n    palindrome = alphanumeric_chars + alphanumeric_chars[::-1]\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Exception Handling",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    try:\n        cleaned_string = ''.join(char.lower() for char in string if char.isalnum())\n        return cleaned_string == cleaned_string[::-1]\n    except:\n        return False",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    alphanumeric_chars = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(5, 10)))\n    palindrome = alphanumeric_chars + alphanumeric_chars[::-1]\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(string: str) -> bool and g() -> str. Function f checks if a given string is a palindrome after removing non-alphanumeric characters, and function g generates a random palindrome string for testing. The assert statement at the end verifies the correctness of the solution."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated palindrome string is correctly identified as a palindrome after removing non-alphanumeric characters. This can be a good exercise to test string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4408208429813385,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(matrix: list) -> bool:\n    try:\n        return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    size = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    \n    for i in range(size):\n        for j in range(i + 1, size):\n            matrix[j][i] = matrix[i][j]\n    \n    return matrix\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves matrix manipulation and checking for symmetry. It also includes exception handling.",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(matrix: list) -> bool:\n    try:\n        return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(len(matrix)))\n    except:\n        return False",
        "solution_func": "def g() -> list:\n    import random\n    size = random.randint(2, 5)\n    matrix = [[random.randint(1, 10) for _ in range(size)] for _ in range(size)]\n    \n    for i in range(size):\n        for j in range(i + 1, size):\n            matrix[j][i] = matrix[i][j]\n    \n    return matrix",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(matrix) that checks if a given matrix is symmetric along its diagonal. The function g() generates a random square matrix and ensures it is symmetric along its diagonal."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding matrix symmetry and generating random matrices. It is suitable for teaching Python programming concepts related to matrices and loops.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4197046756744385,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(parens: str) -> bool:\n    def is_valid_parentheses(s):\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack\n\n    return is_valid_parentheses(parens)\n\ndef g(parens=\"({[]})\"):\n    return parens\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Conditional Logic and String Manipulation.",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    def is_perfect_square(num):\n        return num ** 0.5 == int(num ** 0.5)\n\n    for r in range(1, len(numbers) + 1):\n        for subset in combinations(numbers, r):\n            product = 1\n            for num in subset:\n                product *= num\n            if is_perfect_square(product):\n                return True\n    return False\n\ndef g(numbers=[2, 3, 5, 7, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(parens: str) -> bool:\n    def is_valid_parentheses(s):\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack\n\n    return is_valid_parentheses(parens)",
        "solution_func": "def g(parens=\"({[]})\"):\n    return parens",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string of parentheses is valid by matching opening and closing parentheses correctly."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of stacks and mappings in Python to validate a string of parentheses.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.2616156041622162,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g() -> str:\n    return \"racecar\"  # Example palindrome string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a given text is a palindrome. The solution function returns a hardcoded palindrome string 'racecar' and the puzzle function checks if the input text is equal to its reverse, indicating a palindrome.",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value\n\nassert f(g()) == True\n",
            "\ndef f(intersection: set) -> bool:\n    return any(intersection)\n\ndef g() -> set:\n    set1 = {1, 2, 3, 4, 5}\n    set2 = {4, 5, 6, 7, 8}\n    return set1.intersection(set2)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g() -> str:\n    return \"racecar\"  # Example palindrome string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(text: str) that returns True if the input string is a palindrome, and a function g() that returns a sample palindrome string. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.658027172088623,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(numbers: list) -> bool:\n    for triplet in itertools.combinations(numbers, 3):\n        if triplet[0]**2 + triplet[1]**2 == triplet[2]**2:\n            return True\n    return False\n\ndef g(size=5):\n    numbers = [i for i in range(1, size+1)]\n    for triplet in itertools.combinations(numbers, 3):\n        if triplet[0]**2 + triplet[1]**2 == triplet[2]**2:\n            return list(triplet)\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and importing modules (Itertools).",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(strings: list) -> bool:\n    return max(strings, key=len) == max(strings, key=len)\n\ndef g(size=3):\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 15))) for _ in range(size)]\n    return strings\n\nassert f(g()) == True\n",
            "\ndef f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n\ndef g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(numbers: list) -> bool:\n    for triplet in itertools.combinations(numbers, 3):\n        if triplet[0]**2 + triplet[1]**2 == triplet[2]**2:\n            return True\n    return False",
        "solution_func": "def g(size=5):\n    numbers = [i for i in range(1, size+1)]\n    for triplet in itertools.combinations(numbers, 3):\n        if triplet[0]**2 + triplet[1]**2 == triplet[2]**2:\n            return list(triplet)\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet from a list of numbers using itertools combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Pythagorean triplets and itertools combinations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4715598225593567,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g(length=5):\n    import random\n    letters = [chr(random.randint(97, 122)) for _ in range(length)]\n    return ''.join(letters) + ''.join(reversed(letters))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(strings: list) -> bool:\n    return max(strings, key=len) == max(strings, key=len)\n\ndef g(size=3):\n    strings = [''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(5, 15))) for _ in range(size)]\n    return strings\n\nassert f(g()) == True\n",
            "\ndef f(num: int, prime_check=True) -> bool:\n    if prime_check:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return num > 1 and all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))\n\ndef g(length=4):\n    import sympy\n    prime_num = sympy.prime(length)\n    return prime_num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g(length=5):\n    import random\n    letters = [chr(random.randint(97, 122)) for _ in range(length)]\n    return ''.join(letters) + ''.join(reversed(letters))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that checks if a given text is a palindrome, and then generate a random text of a specified length that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, generating random strings, and checking for palindromes.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4160073399543762,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1))\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list is sorted in ascending order.",
        "idx_generation": 69,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    return num\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1))",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of numbers is sorted in ascending order, and a function g that returns a specific list of numbers. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehension, the all() function, and indexing in Python. It also tests the ability to define functions and use them to check conditions.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5885176658630371,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(min_coins: int, amount=11, coins=[1, 3, 5, 7]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] == min_coins\n\ndef g(amount=11, coins=[1, 3, 5, 7]):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 69,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n",
            "\ndef f(ways: int) -> bool:\n    def climb_stairs(n, count):\n        if n <= 1:\n            return count == 1\n        return climb_stairs(n - 1, count + 1) or climb_stairs(n - 2, count + 1)\n\n    return climb_stairs(ways, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(min_coins: int, amount=11, coins=[1, 3, 5, 7]) -> bool:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] == min_coins",
        "solution_func": "def g(amount=11, coins=[1, 3, 5, 7]):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f calculates the minimum number of coins needed to make a specific amount using given coin denominations, and g calculates the minimum number of coins needed for a specific amount using the same coin denominations. The puzzle checks if the solution function g satisfies the condition of the challenge function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming and coin change problem concepts in Python. It tests the understanding of implementing a solution to find the minimum number of coins needed for a given amount using a specific set of coin denominations.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.450825572013855,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    palindrome = \"A man, a plan, a canal, Panama!\"\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result\n\ndef g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    palindrome = \"A man, a plan, a canal, Panama!\"\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of string manipulation, palindrome checking, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.4562780559062958,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 3:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g() -> List[int]:\n    start = 5\n    diff = 3\n    length = 7\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of numbers forms an arithmetic sequence with a common difference.",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(bitwise_and_result: int) -> bool:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return bitwise_and_result == result\n\ndef g() -> int:\n    binary_nums = [0b1010, 0b1111, 0b1100]\n    result = binary_nums[0]\n    for num in binary_nums[1:]:\n        result &= num\n    return result\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(nums):\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                return False\n        return True\n\n    return any(is_valid_permutation(perm) for perm in permutations)\n\ndef g():\n    def generate_permutations(nums):\n        def backtrack(perm, nums, result):\n            if not nums:\n                result.append(perm)\n                return\n            for i in range(len(nums)):\n                backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n        permutations = []\n        backtrack([], nums, permutations)\n        return permutations\n\n    return generate_permutations([1, 3, 5, 7])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 3:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True",
        "solution_func": "def g() -> List[int]:\n    start = 5\n    diff = 3\n    length = 7\n    return [start + diff*i for i in range(length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a list of integers follows an arithmetic sequence, and a function g that generates a list of integers in an arithmetic sequence. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of arithmetic sequences and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5361361503601074,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n\n    def generate_palindrome_string(length):\n        letters = string.ascii_lowercase\n        half_length = length // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    length = random.randint(5, 10)  # Generate random length for the palindrome string\n    return generate_palindrome_string(length)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 69,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if not nums:\n        return False\n    max_diff = max(nums) - min(nums)\n    return max_diff == max(nums) - min(nums)\n\ndef g() -> List[int]:\n    import random\n    return random.sample(range(1, 50), 5)\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n\n    def generate_palindrome_string(length):\n        letters = string.ascii_lowercase\n        half_length = length // 2\n        first_half = ''.join(random.choice(letters) for _ in range(half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    length = random.randint(5, 10)  # Generate random length for the palindrome string\n    return generate_palindrome_string(length)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome after removing spaces and converting to lowercase. The solution function g() generates a random palindrome string and returns it. The assertion checks if the generated palindrome string satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, random string generation, and function definition in Python. It can be used to teach Python programming to master's students in CS.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3814550042152405,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choice(letters) for _ in range(random.randint(1, 5))) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    return cleaned_text == cleaned_text[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choice(letters) for _ in range(random.randint(1, 5))) + random.choice(letters)\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write two functions: f(text: str) -> bool, which checks if a given text is a palindrome after removing non-alphanumeric characters and converting to lowercase, and g() -> str, which generates a random palindrome string. The assert statement at the end checks if the generated palindrome string is indeed a palindrome after applying function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, random string generation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3735784888267517,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nimport itertools\n\ndef f(permutations: List[str], target_permutation=\"abc\") -> bool:\n    return target_permutation in permutations\n\ndef g(target_permutation=\"abc\"):\n    return [''.join(permutation) for permutation in itertools.permutations(target_permutation)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Permutations and Combinations as it uses itertools.permutations to generate permutations of a target string and checks if a specific permutation is in the list of permutations.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nimport itertools\n\ndef f(permutations: List[str], target_permutation=\"abc\") -> bool:\n    return target_permutation in permutations",
        "solution_func": "def g(target_permutation=\"abc\"):\n    return [''.join(permutation) for permutation in itertools.permutations(target_permutation)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all permutations of a target string and checking if a specific target permutation is in the list of permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of generating permutations using itertools.permutations and checking if a specific permutation is in the list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4437493681907654,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_primes: int, limit=10) -> bool:\n    return sum_primes == 17\n\ndef g(limit=10):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return sum(num for num in range(2, limit) if is_prime(num))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations (checking for prime numbers) and conditional logic (checking if a number is prime).",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_primes: int, limit=10) -> bool:\n    return sum_primes == 17",
        "solution_func": "def g(limit=10):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return sum(num for num in range(2, limit) if is_prime(num))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the function g to find the sum of prime numbers up to a given limit, and the function f checks if the sum of prime numbers is equal to 17."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if the sum of prime numbers up to a given limit is equal to 17 using two functions, one to calculate the sum of prime numbers and the other to check the result.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6027750968933105,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nimport itertools\n\ndef f(combinations: List[List[int]], target_combination=[1, 2]) -> bool:\n    return target_combination in combinations\n\ndef g(target_combination=[1, 2]):\n    items = [1, 2, 3]\n    return [list(combination) for r in range(1, len(items) + 1) for combination in itertools.combinations(items, r)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves importing the itertools module, generating combinations, and checking if a target combination is in the list of combinations.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    unique_numbers = set(numbers)\n    return len(numbers) == len(unique_numbers)\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    random.shuffle(numbers)\n    return numbers\n\nassert f(g()) == True\n",
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nimport itertools\n\ndef f(combinations: List[List[int]], target_combination=[1, 2]) -> bool:\n    return target_combination in combinations",
        "solution_func": "def g(target_combination=[1, 2]):\n    items = [1, 2, 3]\n    return [list(combination) for r in range(1, len(items) + 1) for combination in itertools.combinations(items, r)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a target combination is present in a list of combinations, and a function g that generates all possible combinations of items from a given list. The assertion checks if the target combination is present in the generated combinations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list comprehensions, itertools combinations, and function return values in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.45741263031959534,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(lst: List[int]) -> bool:\n    return len(lst) != len(set(lst))\n\ndef g() -> List[int]:\n    import random\n    return random.choices(range(1, 10), k=5)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    largest = second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest != float('-inf')\n\ndef g() -> List[int]:\n    return [5, 2, 8, 10, 3, 6]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    word = ''.join(random.choice(string.ascii_lowercase) for _ in range(5))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a random 5-letter word followed by its reverse. The puzzle tests whether the generated word satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, and random generation in Python. It can be used to teach these concepts to master's students in CS.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.40579134225845337,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(triplet: List[int]) -> bool:\n    a, b, c = triplet\n    return a ** 2 + b ** 2 == c ** 2\n\ndef g(nums=[3, 4, 5, 6, 8, 10]):\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return [nums[i], nums[j], nums[k]]\n\n    return []\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic to check if a given triplet of numbers forms a Pythagorean triplet.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(longest_subseq_len: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    if not nums:\n        return False\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subseq_len\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(triplet: List[int]) -> bool:\n    a, b, c = triplet\n    return a ** 2 + b ** 2 == c ** 2",
        "solution_func": "def g(nums=[3, 4, 5, 6, 8, 10]):\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ** 2 + nums[j] ** 2 == nums[k] ** 2:\n                    return [nums[i], nums[j], nums[k]]\n\n    return []",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet from a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if a given list of numbers contains a Pythagorean triplet, where the sum of the squares of two numbers is equal to the square of the third number.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4882848560810089,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(substring: str) -> bool:\n    return substring == substring[::-1]\n\ndef g(s=\"babad\") -> str:\n    if len(s) < 2:\n        return s\n\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest_palindrome = \"\"\n\n    for i in range(len(s)):\n        palindrome1 = expand_around_center(i, i)\n        palindrome2 = expand_around_center(i, i + 1)\n\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n\n    return longest_palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and algorithm optimization.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return all(subsequence[i] < subsequence[i+1] for i in range(len(subsequence) - 1))\n\ndef g(numbers=[3, 10, 2, 1, 20]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    start_index = dp.index(max_length)\n    return numbers[start_index:start_index+max_length]\n\nassert f(g()) == True\n",
            "\ndef f(longest_subseq_len: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    if not nums:\n        return False\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) == longest_subseq_len\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(substring: str) -> bool:\n    return substring == substring[::-1]",
        "solution_func": "def g(s=\"babad\") -> str:\n    if len(s) < 2:\n        return s\n\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest_palindrome = \"\"\n\n    for i in range(len(s)):\n        palindrome1 = expand_around_center(i, i)\n        palindrome2 = expand_around_center(i, i + 1)\n\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n\n    return longest_palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(substring) checks if a given substring is a palindrome, and g(s) finds the longest palindrome substring in a given string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome and finding the longest palindrome substring within the string. The solution function g(s) uses an algorithm to find the longest palindrome substring by expanding around centers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.28676825761795044,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    # Check if the text is a palindrome (ignoring spaces and cases)\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]\n\ndef g(text=\"A man, a plan, a canal, Panama!\") -> str:\n    # Generate a string for testing palindrome\n    return text\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves String Manipulation and Conditional Logic.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10\n\ndef g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])\n\ndef g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    # Check if the text is a palindrome (ignoring spaces and cases)\n    clean_text = ''.join(char.lower() for char in text if char.isalnum())\n    return clean_text == clean_text[::-1]",
        "solution_func": "def g(text=\"A man, a plan, a canal, Panama!\") -> str:\n    # Generate a string for testing palindrome\n    return text",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that checks if a given text is a palindrome, ignoring spaces and cases. The solution function generates a test string and uses the implemented function to check if it is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with strings, manipulating text to remove spaces and cases, and implementing a palindrome-checking algorithm. It provides a practical exercise in string manipulation and algorithm implementation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3920845091342926,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(year: int) -> bool:\n    # Check if the year is a leap year based on the leap year rule\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef g(year=2024) -> int:\n    # Generate a year for leap year testing\n    return year\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Conditional Logic, Mathematical Operations",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10\n\ndef g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])\n\ndef g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(year: int) -> bool:\n    # Check if the year is a leap year based on the leap year rule\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)",
        "solution_func": "def g(year=2024) -> int:\n    # Generate a year for leap year testing\n    return year",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to check if a given year is a leap year and another function to generate a year for testing. The assertion checks if the generated year is indeed a leap year."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is about leap year checking in Python using a function f(year) to determine if a year is a leap year and another function g(year) to generate a year for testing. The assertion ensures that the generated year is correctly identified as a leap year.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5896554589271545,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)\n\ndef g(numbers=[3, 4, 2, 8, 10, 5, 1]):\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return []\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(dp)\n        max_index = dp.index(max_length)\n        result = [nums[max_index]]\n        for i in range(max_index - 1, -1, -1):\n            if nums[i] < nums[max_index] and dp[i] == max_length - 1:\n                result.append(nums[i])\n                max_length -= 1\n                max_index = i\n        return result[::-1]\n\n    return longest_increasing_subsequence(numbers)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Dynamic Programming",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    return subsequence == sorted(subsequence)",
        "solution_func": "def g(numbers=[3, 4, 2, 8, 10, 5, 1]):\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return []\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(dp)\n        max_index = dp.index(max_length)\n        result = [nums[max_index]]\n        for i in range(max_index - 1, -1, -1):\n            if nums[i] < nums[max_index] and dp[i] == max_length - 1:\n                result.append(nums[i])\n                max_length -= 1\n                max_index = i\n        return result[::-1]\n\n    return longest_increasing_subsequence(numbers)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if the output of a function g, which finds the longest increasing subsequence of a list of numbers, is a sorted subsequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f checks if a given subsequence is sorted. The function g finds the longest increasing subsequence of a list of numbers and returns it. The assertion at the end checks if the output of g is a sorted subsequence.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3157169222831726,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(solutions: List[List[List[int]]]) -> bool:\n    return len(solutions) > 0\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty_cell(board)\n        if not empty:\n            return [board]\n        row, col = empty\n        solutions = []\n        for num in range(1, 10):\n            if is_valid(board, row, col, num):\n                board[row][col] = num\n                solutions += solve_sudoku(board)\n                board[row][col] = 0\n        return solutions\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(solutions: List[List[List[int]]]) -> bool:\n    return len(solutions) > 0",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        empty = find_empty_cell(board)\n        if not empty:\n            return [board]\n        row, col = empty\n        solutions = []\n        for num in range(1, 10):\n            if is_valid(board, row, col, num):\n                board[row][col] = num\n                solutions += solve_sudoku(board)\n                board[row][col] = 0\n        return solutions\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku(board)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves solving a Sudoku puzzle using a recursive backtracking algorithm. The function f checks if there is at least one solution to the Sudoku puzzle, and the function g solves the Sudoku puzzle using a recursive backtracking approach."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a classic problem (Sudoku) and requires understanding of recursive backtracking algorithm. It can be a good challenge for master's students in CS to practice Python programming skills and algorithmic thinking.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.4465194344520569,
        "judgeLM-7b-abs_finetuning": 2.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return set(numbers) >= {2, 4, 6, 8}\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10, 12, 14]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations and conditional logic.",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List \ndef f(nums: List[int], start=1, end=100) -> bool:\n    return set(range(start, end+1)).issubset(set(nums))\ndef g(start=1, end=100):\n    return list(range(start, end+1))\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return set(numbers) >= {2, 4, 6, 8}",
        "solution_func": "def g() -> List[int]:\n    return [2, 4, 6, 8, 10, 12, 14]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given list of numbers contains all of the elements 2, 4, 6, and 8. The solution function g returns a list that includes these elements and additional numbers. The assertion checks if f applied to the output of g returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking set operations and list comparison in Python. It tests the understanding of sets and lists in Python programming.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5957818031311035,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(probabilities: List[float]) -> bool:\n    return round(sum(probabilities), 2) == 1.0\n\ndef g() -> List[float]:\n    return [0.25, 0.35, 0.4]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Probability and Statistics",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n",
            "\nfrom typing import List \ndef f(nums: List[int], start=1, end=100) -> bool:\n    return set(range(start, end+1)).issubset(set(nums))\ndef g(start=1, end=100):\n    return list(range(start, end+1))\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(probabilities: List[float]) -> bool:\n    return round(sum(probabilities), 2) == 1.0",
        "solution_func": "def g() -> List[float]:\n    return [0.25, 0.35, 0.4]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the sum of a list of probabilities is equal to 1.0 when rounded to 2 decimal places."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of list manipulation and floating-point arithmetic in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.529421329498291,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: float, num1=10, num2=2) -> bool:\n    try:\n        return result == num1 / num2\n    except ZeroDivisionError:\n        return False\n\ndef g(num1=10, num2=2):\n    if num2 == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero.\")\n    return num1 / num2\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and exception handling.",
        "idx_generation": 71,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
            "\nimport math\n\ndef f(prime_factors: set, num=30) -> bool:\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return prime_factors == get_prime_factors(num)\n\ndef g(num=30):\n    def get_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n = n // 2\n        for i in range(3, int(math.sqrt(n))+1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n = n // i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    return get_prime_factors(num)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: float, num1=10, num2=2) -> bool:\n    try:\n        return result == num1 / num2\n    except ZeroDivisionError:\n        return False",
        "solution_func": "def g(num1=10, num2=2):\n    if num2 == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero.\")\n    return num1 / num2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the result of dividing two numbers is equal to a given result, and g performs the division operation. The puzzle tests the handling of ZeroDivisionError."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a simple division operation and tests the handling of ZeroDivisionError. It can be used to teach students about error handling in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5731487274169922,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choices(letters, k=random.randint(5, 10)))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.), Probability and Statistics",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
            "\n\ndef f(numbers: list) -> bool:\n    return len(numbers) != len(set(numbers))\n\ndef g():\n    import random\n    return random.sample(range(1, 10), 5) + random.sample(range(1, 10), 5)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choices(letters, k=random.randint(5, 10)))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string concatenated with its reverse is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and checking if the concatenated string with its reverse is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45397090911865234,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(sudoku: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9 and all(num in range(1, 10) for num in row)\n\n    def is_valid_sudoku(sudoku):\n        for row in sudoku:\n            if not is_valid_row(row):\n                return False\n        return True\n\n    return is_valid_sudoku(sudoku)\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku solution, which requires understanding of list manipulation and conditional logic.",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sudoku: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9 and all(num in range(1, 10) for num in row)\n\n    def is_valid_sudoku(sudoku):\n        for row in sudoku:\n            if not is_valid_row(row):\n                return False\n        return True\n\n    return is_valid_sudoku(sudoku)",
        "solution_func": "def g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku puzzle is valid or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires implementing a function that checks the validity of a Sudoku puzzle by ensuring each row contains unique numbers from 1 to 9 and all numbers are within the range of 1 to 9. The solution provides a valid 9x9 Sudoku puzzle to test the validity function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.43959957361221313,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(progression: List[int]) -> bool:\n    if len(progression) < 3:\n        return False\n    diff = progression[1] - progression[0]\n    return all(progression[i] - progression[i-1] == diff for i in range(2, len(progression)))\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, List Operations, and Conditional Logic.",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(progression: List[int]) -> bool:\n    if len(progression) < 3:\n        return False\n    diff = progression[1] - progression[0]\n    return all(progression[i] - progression[i-1] == diff for i in range(2, len(progression)))",
        "solution_func": "def g():\n    return [1, 3, 5, 7, 9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given list of integers forms an arithmetic progression. The solution function g returns a specific list that forms an arithmetic progression."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list indexing, arithmetic progression, and list comprehension in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5471023321151733,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    if (i, num) in seen or (num, j) in seen or (i//3, j//3, num) in seen:\n                        return False\n                    seen.add((i, num))\n                    seen.add((num, j))\n                    seen.add((i//3, j//3, num))\n        return True\n\n    return is_valid_sudoku(board)\n\ndef g():\n    import random\n\n    def is_valid(board, row, col, num):\n        for x in range(9):\n            if board[row][x] == num or board[x][col] == num or board[3 * (row // 3) + x // 3][3 * (col // 3) + x % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in random.sample(\"123456789\", 9):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = '.'\n                    return False\n        return True\n\n    sudoku_board = [['.' for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Sudoku validation and solving using backtracking algorithm.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(numbers=[1, 2, 3]):\n    def backtrack(path, nums):\n        if not nums:\n            permutations.append(path.copy())\n            return\n        \n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(path, nums[:i] + nums[i+1:])\n            path.pop()\n\n    permutations = []\n    backtrack([], numbers)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != '.':\n                    if (i, num) in seen or (num, j) in seen or (i//3, j//3, num) in seen:\n                        return False\n                    seen.add((i, num))\n                    seen.add((num, j))\n                    seen.add((i//3, j//3, num))\n        return True\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g():\n    import random\n\n    def is_valid(board, row, col, num):\n        for x in range(9):\n            if board[row][x] == num or board[x][col] == num or board[3 * (row // 3) + x // 3][3 * (col // 3) + x % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in random.sample(\"123456789\", 9):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = '.'\n                    return False\n        return True\n\n    sudoku_board = [['.' for _ in range(9)] for _ in range(9)]\n    solve_sudoku(sudoku_board)\n    return sudoku_board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid or not, and providing a solution to solve a Sudoku puzzle using backtracking algorithm."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the validity of a Sudoku board using a specific algorithm and provides a solution to solve a Sudoku puzzle. It involves checking for valid entries in rows, columns, and subgrids. The solution uses a backtracking algorithm to fill in the Sudoku board.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4339599311351776,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)\n\ndef g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as Backtracking, Dynamic Programming, and Combinations.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(numbers=[1, 2, 3]):\n    def backtrack(path, nums):\n        if not nums:\n            permutations.append(path.copy())\n            return\n        \n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(path, nums[:i] + nums[i+1:])\n            path.pop()\n\n    permutations = []\n    backtrack([], numbers)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)",
        "solution_func": "def g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of combinations of coins can make up a specific amount using dynamic programming. The solution generates all possible combinations of coins to reach the target amount."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a dynamic programming approach to solve the coin change problem. The solution function g() uses backtracking to generate all possible combinations of coins that sum up to the target amount. The puzzle function f() then checks if each combination is a valid coin change using dynamic programming.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.2909383177757263,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int, nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves finding the maximum sum of a subarray within a given array, which falls under the topic of Dynamic Programming.",
        "idx_generation": 72,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 55\n\ndef g(n=10):\n    def multiply_matrices(a, b):\n        return [[a[0][0]*b[0][0] + a[0][1]*b[1][0], a[0][0]*b[0][1] + a[0][1]*b[1][1]],\n                [a[1][0]*b[0][0] + a[1][1]*b[1][0], a[1][0]*b[0][1] + a[1][1]*b[1][1]]]\n\n    def power_matrix(matrix, power):\n        result = [[1, 0], [0, 1]]\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply_matrices(result, matrix)\n            matrix = multiply_matrices(matrix, matrix)\n            power //= 2\n        return result\n\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    result_matrix = power_matrix(fibonacci_matrix, n-1)\n    return result_matrix[0][0]\n\nassert f(g()) == True\n",
            "\ndef f(sum_primes: int, n=10) -> bool:\n    return sum_primes == 17\n\ndef g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            prime_sum += i\n    return prime_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int, nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> bool:\n    return max_sum == 6",
        "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of a subarray within a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if the maximum sum of a subarray in a list of integers is equal to a specific value. The solution function g calculates the maximum sum of a subarray within the list of integers and returns it. The assertion at the end checks if the solution function g satisfies the condition of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.46812620759010315,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    return longest_subsequence_length == 4\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to find the longest increasing subsequence in a list of numbers.",
        "idx_generation": 72,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nth_fibonacci: int) -> bool:\n    return nth_fibonacci == 55\n\ndef g(n=10):\n    def multiply_matrices(a, b):\n        return [[a[0][0]*b[0][0] + a[0][1]*b[1][0], a[0][0]*b[0][1] + a[0][1]*b[1][1]],\n                [a[1][0]*b[0][0] + a[1][1]*b[1][0], a[1][0]*b[0][1] + a[1][1]*b[1][1]]]\n\n    def power_matrix(matrix, power):\n        result = [[1, 0], [0, 1]]\n        while power > 0:\n            if power % 2 == 1:\n                result = multiply_matrices(result, matrix)\n            matrix = multiply_matrices(matrix, matrix)\n            power //= 2\n        return result\n\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    result_matrix = power_matrix(fibonacci_matrix, n-1)\n    return result_matrix[0][0]\n\nassert f(g()) == True\n",
            "\ndef f(sum_primes: int, n=10) -> bool:\n    return sum_primes == 17\n\ndef g(n=10) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            prime_sum += i\n    return prime_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int, nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> bool:\n    return longest_subsequence_length == 4",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the length of the longest increasing subsequence in a given list of numbers and checking if it equals a specific value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a dynamic programming solution to find the length of the longest increasing subsequence in a list of numbers and then compare it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4919395446777344,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        def is_valid_row(board):\n            for row in board:\n                if not is_valid(row):\n                    return False\n            return True\n\n        def is_valid_column(board):\n            for col in zip(*board):\n                if not is_valid(col):\n                    return False\n            return True\n\n        def is_valid_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                    if not is_valid(box):\n                        return False\n            return True\n\n        def is_valid(nums):\n            seen = set()\n            for num in nums:\n                if num != '.':\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        return is_valid_row(board) and is_valid_column(board) and is_valid_box(board)\n\n    return is_valid_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n        [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n        ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n        [8, '.', '.', '.', 6, '.', '.', '.', 3],\n        [4, '.', '.', 8, '.', 3, '.', '.', 1],\n        [7, '.', '.', '.', 2, '.', '.', '.', 6],\n        ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n        ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n        ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking the validity of a Sudoku board, which requires knowledge of conditional logic, nested functions, and list manipulation.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def combination_sum(candidates, target):\n        def backtrack(remain, start, path):\n            if remain < 0:\n                return\n            if remain == 0:\n                result.append(path)\n                return\n            for i in range(start, len(candidates)):\n                backtrack(remain - candidates[i], i, path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(target, 0, [])\n        return result\n\n    return combination_sum([2, 3, 6, 7], 7) == result\n\ndef g():\n    return [[2, 2, 3], [7]]\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        def is_valid_row(board):\n            for row in board:\n                if not is_valid(row):\n                    return False\n            return True\n\n        def is_valid_column(board):\n            for col in zip(*board):\n                if not is_valid(col):\n                    return False\n            return True\n\n        def is_valid_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                    if not is_valid(box):\n                        return False\n            return True\n\n        def is_valid(nums):\n            seen = set()\n            for num in nums:\n                if num != '.':\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        return is_valid_row(board) and is_valid_column(board) and is_valid_box(board)\n\n    return is_valid_sudoku(board)",
        "solution_func": "def g():\n    return [\n        [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n        [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n        ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n        [8, '.', '.', '.', 6, '.', '.', '.', 3],\n        [4, '.', '.', 8, '.', 3, '.', '.', 1],\n        [7, '.', '.', '.', 2, '.', '.', '.', 6],\n        ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n        ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n        ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n    ]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given 9x9 Sudoku board is valid or not based on the rules of Sudoku. The function f(board: List[List[int]]) checks if the given board is a valid Sudoku board, and the function g() provides a sample 9x9 Sudoku board to test the validity."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing a function to check the validity of a Sudoku board, which can be a good exercise for students to practice working with nested lists and loops in Python. Additionally, it reinforces the concept of defining helper functions within a main function to break down the problem into smaller parts.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.38175901770591736,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"  # Example palindrome string\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combination: List[int], target_sum=10) -> bool:\n    return sum(combination) == target_sum\n\ndef g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    for r in range(1, len(numbers) + 1):\n        for comb in combinations(numbers, r):\n            if sum(comb) == target_sum:\n                return list(comb)\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"  # Example palindrome string",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a function f(s) that checks if a given string is a palindrome by comparing it with its reverse. The solution function g() returns a sample palindrome string 'radar' and asserts that f(g()) is True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6725443601608276,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(common_elements: set) -> bool:\n    return len(common_elements) > 0\n\ndef g():\n    list1 = [1, 2, 3, 4, 5]\n    list2 = [4, 5, 6, 7, 8]\n    return set(list1) & set(list2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations to find common elements between two lists and uses conditional logic to check if the common elements set is not empty.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combination: List[int], target_sum=10) -> bool:\n    return sum(combination) == target_sum\n\ndef g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    for r in range(1, len(numbers) + 1):\n        for comb in combinations(numbers, r):\n            if sum(comb) == target_sum:\n                return list(comb)\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(common_elements: set) -> bool:\n    return len(common_elements) > 0",
        "solution_func": "def g():\n    list1 = [1, 2, 3, 4, 5]\n    list2 = [4, 5, 6, 7, 8]\n    return set(list1) & set(list2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding common elements between two lists and checking if there are any common elements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if there are common elements between two lists and then verifying the correctness of the solution by checking if the function returns True when applied to the solution function.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5935245156288147,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(index=5):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    num = 2\n    while prime_count < index:\n        if is_prime(num):\n            prime_count += 1\n        num += 1\n    return num - 1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(index=5):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    num = 2\n    while prime_count < index:\n        if is_prime(num):\n            prime_count += 1\n        num += 1\n    return num - 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num) which checks if a number is prime, and g(index) which finds the nth prime number. The goal is to find the nth prime number using the g function and check if it is prime using the f function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, loops, and function composition in Python. It requires students to implement a function to find the nth prime number and check if it is prime.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5441453456878662,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g(input_str=\"racecar\"):\n    return input_str + input_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"racecar\"):\n    return input_str + input_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome after removing spaces and converting to lowercase, and a function g(input_str) that returns the input string concatenated with its reverse, the puzzle requires finding an input string that, when passed to g(), results in a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation, palindrome checking, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5025574564933777,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    return nums[0] ** 2 + nums[1] ** 2 == nums[2] ** 2\n\ndef g(a=3, b=4, c=5):\n    return [a, b, c]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a set of numbers form a Pythagorean triplet.",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    return nums[0] ** 2 + nums[1] ** 2 == nums[2] ** 2",
        "solution_func": "def g(a=3, b=4, c=5):\n    return [a, b, c]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of integers and checking if the square of the two smallest numbers is equal to the square of the largest number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of list sorting, list indexing, and basic arithmetic operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5842941403388977,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Number Theory (checking for prime numbers) and Importing Modules (using the random module).",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(nums: set) -> bool:\n    for a, b, c in combinations(nums, 3):\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g() -> set:\n    nums = set()\n    for i in range(1, 100):\n        nums.add(i)\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(lst: List[int]) -> bool:\n    return len(lst) != len(set(lst))\n\ndef g() -> List[int]:\n    import random\n    return random.choices(range(1, 10), k=5)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions: f(num) checks if a given number is a prime number, and g() randomly selects a prime number from a predefined list. The puzzle requires g() to return a prime number and f(g()) to evaluate to True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly selected prime number from a list is correctly identified as a prime number by the f(num) function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5988426208496094,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nimport math\n\ndef f(number: int) -> bool:\n    sum_factorial = sum(math.factorial(int(digit)) for digit in str(number))\n    return sum_factorial == number\n\ndef g(number: int = 145):\n    return number\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, string manipulation, and importing modules (math).",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(number: int) -> bool:\n    sum_factorial = sum(math.factorial(int(digit)) for digit in str(number))\n    return sum_factorial == number",
        "solution_func": "def g(number: int = 145):\n    return number",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a number whose sum of factorials of its digits is equal to the number itself."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate factorials of digits in a number and checking if the sum of these factorials equals the original number.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6235984563827515,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(nums: list) -> bool:\n    return nums == nums[::-1]\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as list manipulation and comparison.",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\n\nimport numpy as np\n\ndef f(nums: np.ndarray) -> bool:\n    sorted_nums = np.sort(nums)\n    median_original = np.median(nums)\n    median_sorted = np.median(sorted_nums)\n    return median_original == median_sorted\n\ndef g(size: int = 100):\n    return np.random.randint(1, 100, size=size)\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    return nums == nums[::-1]",
        "solution_func": "def g():\n    return [1, 2, 3, 2, 1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given list is a palindrome (reads the same forwards and backwards). The function f(nums) returns True if the list is a palindrome, and the function g() returns a specific list to test the palindrome check."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list slicing in Python and checking for palindromes. It is a simple and straightforward puzzle that can be used to teach basic list manipulation and comparison in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5551372170448303,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsets: List[List[int]]) -> bool:\n    return [1, 2] in subsets\n\ndef g(nums=[1, 2, 3]):\n    def generate_subsets(nums):\n        subsets = [[]]\n        for num in nums:\n            subsets += [subset + [num] for subset in subsets]\n        return subsets\n\n    return generate_subsets(nums)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves generating subsets of a list of numbers and checking if a specific subset is present in the generated subsets. This involves topics such as list manipulation, recursion, and conditional logic.",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsets: List[List[int]]) -> bool:\n    return [1, 2] in subsets",
        "solution_func": "def g(nums=[1, 2, 3]):\n    def generate_subsets(nums):\n        subsets = [[]]\n        for num in nums:\n            subsets += [subset + [num] for subset in subsets]\n        return subsets\n\n    return generate_subsets(nums)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that generates all possible subsets of a given list of numbers and then check if a specific subset is present in the generated subsets."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate subsets of a list using recursion and checking for a specific subset in the generated subsets.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3240079879760742,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return all(sum(perm) % 2 == 0 for perm in permutations)\n\ndef g(nums=[1, 2, 3, 4]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Backtracking, List Manipulation, and Conditional Logic.",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return all(sum(perm) % 2 == 0 for perm in permutations)",
        "solution_func": "def g(nums=[1, 2, 3, 4]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n\n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the sum of elements in each permutation of a list is even, and a function g that generates all permutations of a given list. The solution g generates all permutations of a list and the puzzle f checks if the sum of elements in each permutation is even."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding permutations, recursion, and list manipulation in Python. It can be used to teach students about generating permutations and checking conditions on each permutation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3567933440208435,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]\n\ndef g(input_str=\"A man, a plan, a canal: Panama\"):\n    return input_str\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef f(tasks: List[Tuple[str, str]]) -> bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for task1, task2 in tasks:\n        graph[task1].append(task2)\n        indegree[task2] += 1\n    \n    queue = [task for task in graph if indegree[task] == 0]\n    order = []\n    \n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n        for next_task in graph[task]:\n            indegree[next_task] -= 1\n            if indegree[next_task] == 0:\n                queue.append(next_task)\n    \n    return len(order) == len(graph)\n\ndef g():\n    return [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E')]\n\nassert f(g()) == True\n",
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    cleaned_str = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned_str == cleaned_str[::-1]",
        "solution_func": "def g(input_str=\"A man, a plan, a canal: Panama\"):\n    return input_str",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given string is a palindrome after removing non-alphanumeric characters, and a function g that returns a specific input string. The assertion checks if the function f returns True for the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle is about checking if a given string is a palindrome after removing non-alphanumeric characters. The solution function g simply returns a specific input string. The assertion tests if the function f correctly identifies the input string as a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5477924942970276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g():\n    return [[1, 4], [3, 6], [7, 10]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering, Conditional Logic",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    def has_cycle(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, rec_stack):\n                return True\n\n    return False\n\ndef g():\n    return [[1], [2], [0]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False",
        "solution_func": "def g():\n    return [[1, 4], [3, 6], [7, 10]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function that takes a list of intervals and checks if there are any overlapping intervals."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The function f sorts the intervals based on the start time and then iterates through the list to check for any overlapping intervals. If it finds any overlapping intervals, it returns True, otherwise it returns False.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4883475601673126,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku()\n\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    def has_cycle(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, rec_stack):\n                return True\n\n    return False\n\ndef g():\n    return [[1], [2], [0]]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku()",
        "solution_func": "def g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver using a recursive backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a recursive backtracking approach. The function should check the validity of numbers in each row, column, and subgrid to find the solution.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.42161163687705994,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Randomization, Importing Modules (Itertools, etc.)",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(random.randint(5, 10)))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random string and its palindrome. The puzzle tests whether the generated string and its palindrome satisfy the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation and palindrome checking in Python. It provides a practical application of string slicing and random generation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.40956220030784607,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list) -> bool:\n    if len(numbers) < 2:\n        return True\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))\n\ndef g(numbers=[2, 4, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a list of numbers forms an arithmetic sequence.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(tuples: list) -> bool:\n    nodes = set()\n    for t in tuples:\n        nodes.update(t)\n    return all((n1, n2) in tuples or (n2, n1) in tuples for n1, n2 in combinations(nodes, 2))\n\ndef g(tuples=[(1, 2), (1, 3), (2, 3)]):\n    return tuples\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(permutations: list, s='abc') -> bool:\n    valid_permutations = [''.join(p) for p in itertools.permutations(s)]\n    return set(permutations) == set(valid_permutations)\n\ndef g(s='abc'):\n    return [''.join(p) for p in itertools.permutations(s)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list) -> bool:\n    if len(numbers) < 2:\n        return True\n    diff = numbers[1] - numbers[0]\n    return all(numbers[i] - numbers[i-1] == diff for i in range(2, len(numbers)))",
        "solution_func": "def g(numbers=[2, 4, 6, 8, 10]):\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a list of numbers forms an arithmetic sequence, and a function g that returns a default list of numbers. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list manipulation, arithmetic sequences, and function return values in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5988435745239258,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g(number=17):\n    return number\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g(number=17):\n    return number",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(number) that checks if a given number is a prime number or not, and a function g(number) that returns a specific number (default is 17). The puzzle requires g to be modified to return a prime number for the assertion to pass."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.62783282995224,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, number=5) -> bool:\n    factorial = 1\n    for i in range(1, number + 1):\n        factorial *= i\n    return factorial == result\n\ndef g(number=5):\n    factorial = 1\n    for i in range(1, number + 1):\n        factorial *= i\n    return factorial\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations (calculating factorial), conditional logic (using assert statement), and function definition and calling.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int, number=5) -> bool:\n    factorial = 1\n    for i in range(1, number + 1):\n        factorial *= i\n    return factorial == result",
        "solution_func": "def g(number=5):\n    factorial = 1\n    for i in range(1, number + 1):\n        factorial *= i\n    return factorial",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the factorial of a given number matches a given result, and a function g that calculates the factorial of a given number. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of functions, loops, and factorial calculation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.668205201625824,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int, digit_sum=25) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return str(num) == str(num)[::-1] and is_prime(num) and sum(int(d) for d in str(num)) == digit_sum\n\ndef g(digit_sum=25):\n    num = 11\n    while True:\n        if str(num) == str(num)[::-1] and all(num % i != 0 for i in range(2, int(num**0.5) + 1)):\n            if sum(int(d) for d in str(num)) == digit_sum:\n                return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Mathematical Operations, Conditional Logic, Recursion, Brute Force Search, Number Theory (factors, primes, etc.)",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g()) == True",
            "from typing import List \ndef f(x: List[int], n=9909, s=88140438) -> bool:\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "def f(num: int, digit_sum=25) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return str(num) == str(num)[::-1] and is_prime(num) and sum(int(d) for d in str(num)) == digit_sum",
        "solution_func": "def g(digit_sum=25):\n    num = 11\n    while True:\n        if str(num) == str(num)[::-1] and all(num % i != 0 for i in range(2, int(num**0.5) + 1)):\n            if sum(int(d) for d in str(num)) == digit_sum:\n                return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a number that is a palindrome, a prime number, and has a specific digit sum. The solution function iterates through numbers to find the desired number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindrome, prime number, and digit sum properties of a number. The solution function iterates through numbers to find the desired number that satisfies all conditions.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.47637367248535156,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int, k=3) -> bool:\n    def sort_pattern(lst):\n        sorted_lst = sorted(lst)\n        return sorted_lst[::2] + sorted_lst[1::2]\n    \n    sorted_list = sort_pattern(list(range(1, n+1)))\n    return n in sorted_list[k-1::k]\n\ndef g(k=3):\n    return k * 2\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list and checking if a specific element is present in a specific position in the sorted list. It also involves function composition and assertion testing.",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g()) == True",
            "from typing import List \ndef f(x: List[int], n=9909, s=88140438) -> bool:\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int, k=3) -> bool:\n    def sort_pattern(lst):\n        sorted_lst = sorted(lst)\n        return sorted_lst[::2] + sorted_lst[1::2]\n    \n    sorted_list = sort_pattern(list(range(1, n+1)))\n    return n in sorted_list[k-1::k]",
        "solution_func": "def g(k=3):\n    return k * 2",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that sorts a list of numbers in a specific pattern and checks if a given number is in a certain position in the sorted list. The solution function g returns a value that is used as input to f, and the puzzle requires g to be called with a specific argument to return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list in a specific pattern and checking for a specific condition. The solution function g returns a value that is used as input to f to satisfy the condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6539080142974854,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(words: list) -> bool:\n    return all(sorted(word.lower()) == sorted(words[0].lower()) for word in words)\n\ndef g() -> list:\n    import random\n    words = ['listen', 'silent', 'enlist']\n    random.shuffle(words)\n    return words\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting operations.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\ndef f(lst: list) -> bool:\n    try:\n        expected_sequence = list(range(min(lst), max(lst) + 1))\n        return expected_sequence == sorted(lst)\n    except:\n        return False\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 5)\n    end = start + random.randint(2, 5)\n    return list(range(start, end + 1))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(words: list) -> bool:\n    return all(sorted(word.lower()) == sorted(words[0].lower()) for word in words)",
        "solution_func": "def g() -> list:\n    import random\n    words = ['listen', 'silent', 'enlist']\n    random.shuffle(words)\n    return words",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires a function f(words: list) that checks if all words in a list have the same characters (ignoring case sensitivity) as the first word in the list. The solution function g() generates a list of words, shuffles them, and returns the shuffled list. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves comparing sorted characters of words in a list and checking if they match the sorted characters of the first word in the list. The solution function shuffles a list of words and returns it. The assertion confirms that the solution function satisfies the condition of the puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4846864640712738,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom collections import Counter\n\ndef f(s: str) -> bool:\n    char_count = Counter(s)\n    odd_count = sum(count % 2 == 1 for count in char_count.values())\n    return odd_count <= 1\n\ndef g(s=\"radar\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from collections import Counter\n\ndef f(s: str) -> bool:\n    char_count = Counter(s)\n    odd_count = sum(count % 2 == 1 for count in char_count.values())\n    return odd_count <= 1",
        "solution_func": "def g(s=\"radar\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given string has at most one character with an odd count of occurrences."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to use the Counter class from the collections module in Python to count character occurrences in a string and then determine if the string has at most one character with an odd count of occurrences.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4433070421218872,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom math import gcd\n\ndef f(numbers: list) -> bool:\n    if len(numbers) < 2:\n        return False\n    gcd_val = numbers[0]\n    for i in range(1, len(numbers)):\n        gcd_val = gcd(gcd_val, numbers[i])\n    return gcd_val > 1\n\ndef g(numbers=[12, 18, 24, 36]):\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations (index 1) and Number Theory (index 18).",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from math import gcd\n\ndef f(numbers: list) -> bool:\n    if len(numbers) < 2:\n        return False\n    gcd_val = numbers[0]\n    for i in range(1, len(numbers)):\n        gcd_val = gcd(gcd_val, numbers[i])\n    return gcd_val > 1",
        "solution_func": "def g(numbers=[12, 18, 24, 36]):\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a function that calculates the greatest common divisor (GCD) of a list of numbers and checks if the GCD is greater than 1."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the math module's gcd function and checking if the calculated GCD is greater than 1.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5542270541191101,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=13):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(values: list) -> bool:\n    for combo in combinations(values, 3):\n        a, b, c = sorted(combo)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g(numbers=[3, 4, 5, 6, 8, 10]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=13):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g(num) that returns a specific number (default is 13). The puzzle requires g to be implemented in a way that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function implementation in Python. It requires students to implement a function g that returns a number for which f(num) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6173983216285706,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g():\n    import string\n    import random\n\n    letters = string.ascii_lowercase\n    word = ''.join(random.choice(letters) for _ in range(5))\n    palindrome = word + word[::-1]  # Creating a palindrome string\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic. The function f checks if a given text is a palindrome, and the function g generates a random palindrome string.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g():\n    import string\n    import random\n\n    letters = string.ascii_lowercase\n    word = ''.join(random.choice(letters) for _ in range(5))\n    palindrome = word + word[::-1]  # Creating a palindrome string\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(text: str) that checks if a given text is a palindrome, and a function g() that generates a random palindrome string. The assert statement checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in Python and generating random strings using the random and string modules.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4313347637653351,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    ratio = numbers[1] / numbers[0]\n    return all(numbers[i] / numbers[i-1] == ratio for i in range(2, len(numbers)))\n\ndef g():\n    import random\n\n    start = random.randint(1, 5)\n    ratio = random.randint(2, 5)\n    numbers = [start * ratio ** i for i in range(5)]  # Generating a geometric progression\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)\n\nassert f(g()) == True\n",
            "\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    return np.array_equal(matrix, matrix.T)\n\ndef g(n=3):\n    matrix = np.random.randint(0, 10, size=(n, n))\n    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T\n    return symmetric_matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int]) -> bool:\n    if len(numbers) < 3:\n        return False\n    ratio = numbers[1] / numbers[0]\n    return all(numbers[i] / numbers[i-1] == ratio for i in range(2, len(numbers)))",
        "solution_func": "def g():\n    import random\n\n    start = random.randint(1, 5)\n    ratio = random.randint(2, 5)\n    numbers = [start * ratio ** i for i in range(5)]  # Generating a geometric progression\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers forms a geometric progression."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand geometric progressions and implement a function to check if a list of numbers forms one.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.45637455582618713,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum == 4\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(num) that checks if a given number is a prime number or not, and a function g() that returns the number 17. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6455723643302917,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum == 4\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome (reads the same forwards and backwards) by comparing the word to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(word) that checks if a given word is a palindrome, and a function g() that returns the word 'radar'. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5793358683586121,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(fib_value: int, n=6) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == fib_value\n\ndef g(n=6):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and recursion to calculate the Fibonacci sequence. It also includes conditional logic to check if the calculated value matches the given Fibonacci value. Additionally, it demonstrates function definition and assertion testing in Python.",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: float, num1=10, num2=5, op='/') -> bool:\n    try:\n        if op == '+':\n            return num1 + num2 == result\n        elif op == '-':\n            return num1 - num2 == result\n        elif op == '*':\n            return num1 * num2 == result\n        elif op == '/':\n            return num1 / num2 == result\n    except ZeroDivisionError:\n        return False\n\ndef g(num1=10, num2=5, op='/'):\n    try:\n        if op == '+':\n            return num1 + num2\n        elif op == '-':\n            return num1 - num2\n        elif op == '*':\n            return num1 * num2\n        elif op == '/':\n            return num1 / num2\n    except ZeroDivisionError:\n        return None\n\nassert f(g()) == True\n",
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(fib_value: int, n=6) -> bool:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a == fib_value",
        "solution_func": "def g(n=6):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the output of g matches a Fibonacci number based on a given value of n."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of Fibonacci sequence generation and function composition in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5964481830596924,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(minimum_coins: int, amount=11, denominations=[1, 2, 5, 10]) -> bool:\n    return minimum_coins == 2\n\ndef g(amount=11, denominations=[1, 2, 5, 10]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Algorithm Optimization",
        "idx_generation": 75,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(minimum_coins: int, amount=11, denominations=[1, 2, 5, 10]) -> bool:\n    return minimum_coins == 2",
        "solution_func": "def g(amount=11, denominations=[1, 2, 5, 10]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the minimum number of coins needed to make a specific amount using given denominations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if the minimum number of coins required to make a specific amount is equal to 2. The solution function g uses dynamic programming to calculate the minimum number of coins needed to make the given amount using the provided denominations. The assertion at the end checks if the solution function g satisfies the condition of the puzzle function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5714349150657654,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(text: str) -> bool:\n    return text == text[::-1]\n\ndef g():\n    base = \"racecar\"\n    return base + base[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "def f(text: str) -> bool:\n    return text == text[::-1]",
        "solution_func": "def g():\n    base = \"racecar\"\n    return base + base[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given text is a palindrome (reads the same forwards and backwards) by comparing it to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(text: str) that checks if a given text is a palindrome. The solution function g() generates a palindrome by concatenating a base string with its reverse. The assert statement verifies that the solution function g() correctly solves the challenge defined by function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.600682258605957,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, target-9]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Set Operations, Brute Force Search, and Conditional Logic.",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    return all((numbers[i] == numbers[i-1] + numbers[i-2] for i in range(2, len(numbers))))\n\ndef g(length=8):\n    numbers = [0, 1]\n    while len(numbers) < length:\n        numbers.append(numbers[-1] + numbers[-2])\n    return numbers\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False",
        "solution_func": "def g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, target-9]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding two numbers in a list that add up to a target value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there are two numbers in a list that sum up to a given target value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5379452109336853,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(check_str: str) -> bool:\n    return check_str == check_str[::-1]\n\ndef g(length=10) -> str:\n    import random\n    import string\n    palindrome_str = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n    return palindrome_str + palindrome_str[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Importing Modules (Itertools, etc.)",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n",
            "\nimport math\nimport random\n\ndef f(factorial: int, n=5) -> bool:\n    return math.factorial(n) == factorial\n\ndef g(n=5) -> int:\n    return math.factorial(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(check_str: str) -> bool:\n    return check_str == check_str[::-1]",
        "solution_func": "def g(length=10) -> str:\n    import random\n    import string\n    palindrome_str = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n    return palindrome_str + palindrome_str[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two functions, f(check_str: str) -> bool and g(length=10) -> str. Function f checks if a given string is a palindrome, and function g generates a random palindrome string. The assert statement checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated palindrome string is correctly identified as a palindrome by the function f. This can be a good exercise to test understanding of string manipulation and comparison in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.5216113328933716,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport sympy\nimport random\n\ndef f(num: int) -> bool:\n    return sympy.isprime(num)\n\ndef g() -> int:\n    return sympy.randprime(10, 50)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a randomly generated number is a prime number using the sympy library.",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        parsed_num = int(num)\n        return parsed_num % 2 == 0\n    except ValueError:\n        return False\n\ndef g() -> str:\n    return \"42\"\n\nassert f(g()) == True\n",
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import sympy\nimport random\n\ndef f(num: int) -> bool:\n    return sympy.isprime(num)",
        "solution_func": "def g() -> int:\n    return sympy.randprime(10, 50)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random prime number between 10 and 50 using sympy library and checking if it is a prime number using sympy's isprime function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of prime numbers and the usage of sympy library in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.7288398742675781,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a word is a palindrome.",
        "idx_generation": 76,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    def bfs(start, end):\n        queue = [start]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            visited.add(node)\n            for neighbor in [(node[0] + 1, node[1]), (node[0] - 1, node[1]), (node[0], node[1] + 1), (node[0], node[1] - 1)]:\n                if neighbor[0] >= 0 and neighbor[0] < len(grid) and neighbor[1] >= 0 and neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0 and neighbor not in visited:\n                    queue.append(neighbor)\n        return False\n\n    start, end = (0, 0), (len(grid) - 1, len(grid[0]) - 1)\n    return bfs(start, end)\n\ndef g():\n    return [[0, 0, 0], [1, 1, 0], [0, 0, 0]]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"racecar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(word) that returns True if the word is a palindrome (reads the same forwards and backwards). The solution function g() returns the word 'racecar', and the assertion checks if f(g()) returns True.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6338632106781006,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves checking if a number is prime or not using a simple algorithm. It does not directly involve any of the listed topics.",
        "idx_generation": 76,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(pattern: List[int]) -> bool:\n    def check_pattern(nums):\n        if len(nums) < 3:\n            return False\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n        return True\n\n    return check_pattern(pattern)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    def bfs(start, end):\n        queue = [start]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            visited.add(node)\n            for neighbor in [(node[0] + 1, node[1]), (node[0] - 1, node[1]), (node[0], node[1] + 1), (node[0], node[1] - 1)]:\n                if neighbor[0] >= 0 and neighbor[0] < len(grid) and neighbor[1] >= 0 and neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0 and neighbor not in visited:\n                    queue.append(neighbor)\n        return False\n\n    start, end = (0, 0), (len(grid) - 1, len(grid[0]) - 1)\n    return bfs(start, end)\n\ndef g():\n    return [[0, 0, 0], [1, 1, 0], [0, 0, 0]]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function f(num: int) that checks if a given number is a prime number. The student also needs to define a function g() that returns a specific number, and the puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number and ensuring that the function g() returns a specific number that satisfies the condition of being a prime number. This puzzle can be used to teach students about prime numbers and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6383643746376038,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(n: int) -> bool:\n    return math.isqrt(n)**2 == n and str(n) == str(n)[::-1]\n\ndef g() -> int:\n    import random\n\n    def generate_palindrome_square():\n        num = random.randint(1, 100)\n        while True:\n            square = num**2\n            if str(square) == str(square)[::-1]:\n                return square\n            num += 1\n\n    return generate_palindrome_square()\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and mathematical operations to generate a palindrome square number.",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    return arr == sorted(arr)\n\ndef g(length=5) -> list:\n    import random\n    return sorted(random.sample(range(1, 20), length))\n\nassert f(g()) == True\n",
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(n: int) -> bool:\n    return math.isqrt(n)**2 == n and str(n) == str(n)[::-1]",
        "solution_func": "def g() -> int:\n    import random\n\n    def generate_palindrome_square():\n        num = random.randint(1, 100)\n        while True:\n            square = num**2\n            if str(square) == str(square)[::-1]:\n                return square\n            num += 1\n\n    return generate_palindrome_square()",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random number, finding its square, and checking if the square is a palindrome and a perfect square. The solution function generates random numbers, calculates their squares, and returns the first palindrome square found."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of generating random numbers, calculating squares, string manipulation, and conditional checks. It tests the student's understanding of functions, loops, and conditional statements in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5634157061576843,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(n: int) -> bool:\n    return math.factorial(n) % 10 == 0\n\ndef g() -> int:\n    import random\n\n    num = random.randint(1, 10)\n    while math.factorial(num) % 10 != 0:\n        num = random.randint(1, 10)\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, importing modules (math), and exception handling.",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    return arr == sorted(arr)\n\ndef g(length=5) -> list:\n    import random\n    return sorted(random.sample(range(1, 20), length))\n\nassert f(g()) == True\n",
            "\ndef f(num: int, threshold=10) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(num) and sum(int(d) for d in str(num)) > threshold\n\ndef g(threshold = 10):\n    import random\n\n    def generate_prime():\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        num = random.randint(2, 100)\n        while not is_prime(num):\n            num = random.randint(2, 100)\n        return num\n\n    return generate_prime()\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(n: int) -> bool:\n    return math.factorial(n) % 10 == 0",
        "solution_func": "def g() -> int:\n    import random\n\n    num = random.randint(1, 10)\n    while math.factorial(num) % 10 != 0:\n        num = random.randint(1, 10)\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random number between 1 and 10, calculating its factorial, and checking if the factorial ends with a 0. The solution repeatedly generates random numbers until it finds one whose factorial ends with a 0."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding factorials, modulo operation, random number generation, and loop iteration in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.602769672870636,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(target_value: int, sequence_length=100) -> bool:\n    random.seed(1)\n    sequence = [random.randint(1, 100) for _ in range(sequence_length)]\n    sorted_sequence = sorted(sequence)\n    median_index = len(sorted_sequence) // 2\n    median_value = sorted_sequence[median_index]\n    return abs(median_value - target_value) < 10\n\ndef g():\n    return 50\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a sequence of random numbers and finding the median value to check if it is within a certain range of a target value.",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(target_value: int, sequence_length=100) -> bool:\n    random.seed(1)\n    sequence = [random.randint(1, 100) for _ in range(sequence_length)]\n    sorted_sequence = sorted(sequence)\n    median_index = len(sorted_sequence) // 2\n    median_value = sorted_sequence[median_index]\n    return abs(median_value - target_value) < 10",
        "solution_func": "def g():\n    return 50",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random sequence of numbers, finding the median value, and checking if the absolute difference between the median value and a target value is less than 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of generating random sequences, sorting, finding the median, and comparison operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46868032217025757,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(total_arrangements: int, group_size=5) -> bool:\n    return total_arrangements == math.factorial(group_size)\n\ndef g():\n    return 120  # 5!\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and importing modules (math). It also touches on permutations and combinations.",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(total_arrangements: int, group_size=5) -> bool:\n    return total_arrangements == math.factorial(group_size)",
        "solution_func": "def g():\n    return 120  # 5!",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to determine if the factorial of a given group size is equal to a given total number of arrangements."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the math.factorial function to calculate the factorial of a group size and checking if it matches the total number of arrangements.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6432591080665588,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(expected_probability: float, sample_size=1000) -> bool:\n    random.seed(3)\n    num_heads = sum(random.choice(['H', 'T']) == 'H' for _ in range(sample_size))\n    probability_heads = num_heads / sample_size\n    return abs(probability_heads - expected_probability) < 0.05\n\ndef g():\n    return 0.5\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Probability and Statistics",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport random\n\ndef f(expected_value: float, sample_size=1000) -> bool:\n    random.seed(0)\n    total = sum(random.randint(1, 6) for _ in range(sample_size))\n    avg_value = total / sample_size\n    return abs(avg_value - expected_value) < 0.2\n\ndef g():\n    return 3.5\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(expected_probability: float, sample_size=1000) -> bool:\n    random.seed(3)\n    num_heads = sum(random.choice(['H', 'T']) == 'H' for _ in range(sample_size))\n    probability_heads = num_heads / sample_size\n    return abs(probability_heads - expected_probability) < 0.05",
        "solution_func": "def g():\n    return 0.5",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a sample of coin flips and calculating the probability of getting heads. The solution function returns a fixed probability value, and the puzzle function checks if the calculated probability is within a small margin of this expected value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic probability calculations and comparison. The solution function always returns 0.5, representing the expected probability of getting heads in a fair coin flip. The puzzle function checks if the calculated probability of getting heads in the sample is within 0.05 of this expected value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5492770075798035,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_word = ''.join(random.choice(letters) for _ in range(5))\n    return random_word + random_word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.), Pattern Recognition",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    if len(nums) < 2:\n        return True\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i-1] == diff for i in range(2, len(nums)))\n\ndef g(start: int = 1, diff: int = 3, size: int = 5) -> list:\n    return [start + diff * i for i in range(size)]\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    random_word = ''.join(random.choice(letters) for _ in range(5))\n    return random_word + random_word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(s) and g(), where f(s) checks if a given string is a palindrome after removing spaces and converting to lowercase, and g() generates a random 10-character string and checks if it is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, random generation, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.439236044883728,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\nimport random\nimport string\n\ndef g():\n    word = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 8)))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]\n\nimport random\nimport string",
        "solution_func": "def g():\n    word = ''.join(random.choices(string.ascii_lowercase, k=random.randint(3, 8)))\n    return word + word[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated word concatenated with its reverse is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random word and checking if the concatenation of the word with its reverse is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.45193982124328613,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_product: int, nums=[-2, 3, -4, -5]) -> bool:\n    max_ending_here = min_ending_here = max_product_so_far = nums[0]\n    for num in nums[1:]:\n        max_temp = max_ending_here\n        max_ending_here = max(num, num * max_ending_here, num * min_ending_here)\n        min_ending_here = min(num, num * max_temp, num * min_ending_here)\n        max_product_so_far = max(max_product_so_far, max_ending_here)\n    return max_product_so_far == max_product\n\ndef g(nums=[-2, 3, -4, -5]) -> int:\n    max_ending_here = min_ending_here = max_product_so_far = nums[0]\n    for num in nums[1:]:\n        max_temp = max_ending_here\n        max_ending_here = max(num, num * max_ending_here, num * min_ending_here)\n        min_ending_here = min(num, num * max_temp, num * min_ending_here)\n        max_product_so_far = max(max_product_so_far, max_ending_here)\n    return max_product_so_far\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\nfrom typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum\n\ndef g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\nassert f(g()) == True\n",
            "\n\ndef f(area: float) -> bool:\n    return area == 4.5\n\ndef g(vertices=[(0, 0), (3, 0), (3, 3)]) -> float:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_product: int, nums=[-2, 3, -4, -5]) -> bool:\n    max_ending_here = min_ending_here = max_product_so_far = nums[0]\n    for num in nums[1:]:\n        max_temp = max_ending_here\n        max_ending_here = max(num, num * max_ending_here, num * min_ending_here)\n        min_ending_here = min(num, num * max_temp, num * min_ending_here)\n        max_product_so_far = max(max_product_so_far, max_ending_here)\n    return max_product_so_far == max_product",
        "solution_func": "def g(nums=[-2, 3, -4, -5]) -> int:\n    max_ending_here = min_ending_here = max_product_so_far = nums[0]\n    for num in nums[1:]:\n        max_temp = max_ending_here\n        max_ending_here = max(num, num * max_ending_here, num * min_ending_here)\n        min_ending_here = min(num, num * max_temp, num * min_ending_here)\n        max_product_so_far = max(max_product_so_far, max_ending_here)\n    return max_product_so_far",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the maximum product of a subarray in a given list of integers matches a specified value, and g calculates the maximum product of a subarray in a given list of integers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of subarrays and maximum product calculations. It can be used to teach Python programming to master's students in CS.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.35007229447364807,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_product = max(max_product, nums[i] * nums[j])\n    return True\n\ndef g():\n    import random\n    \n    nums = random.sample(range(-10, 10), 5)\n    return nums\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, brute force search, and importing modules (random).",
        "idx_generation": 77,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]]) -> bool:\n    return all(tuples[i][1] <= tuples[i+1][1] for i in range(len(tuples) - 1))\n\ndef g():\n    import random\n    random_tuples = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(5)]\n    return sorted(random_tuples, key=lambda x: x[1])\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_product = max(max_product, nums[i] * nums[j])\n    return True",
        "solution_func": "def g():\n    import random\n    \n    nums = random.sample(range(-10, 10), 5)\n    return nums",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that takes a list of integers and checks if there exists a pair of integers in the list whose product is the maximum among all pairs."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves finding the maximum product of pairs of integers in a given list. The solution function generates a list of random integers and checks if the implemented function returns True for that list.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3899989426136017,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters) + ''.join(random.choices(letters, k=5)) + random.choice(letters)\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome, and a function g that generates a random palindrome string. The assertion checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5016708970069885,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_prime_factors: int, num=30) -> bool:\n    def prime_factors(n):\n        i = 2\n        factors = set()\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n\n    prime_factors_set = prime_factors(num)\n    return sum(prime_factors_set) == sum_prime_factors\n\ndef g(num=30) -> int:\n    def prime_factors(n):\n        i = 2\n        factors = set()\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n\n    prime_factors_set = prime_factors(num)\n    return sum(prime_factors_set)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Number Theory (factors, primes, etc.) and Set Operations.",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    def swap_without_temp(nums):\n        nums[0] = nums[0] ^ nums[1]\n        nums[1] = nums[0] ^ nums[1]\n        nums[0] = nums[0] ^ nums[1]\n        return nums\n\n    return swap_without_temp(nums) == [7, 3]\n\ndef g():\n    return [3, 7]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_prime_factors: int, num=30) -> bool:\n    def prime_factors(n):\n        i = 2\n        factors = set()\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n\n    prime_factors_set = prime_factors(num)\n    return sum(prime_factors_set) == sum_prime_factors",
        "solution_func": "def g(num=30) -> int:\n    def prime_factors(n):\n        i = 2\n        factors = set()\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n\n    prime_factors_set = prime_factors(num)\n    return sum(prime_factors_set)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if the sum of prime factors of a given number is equal to a specified sum, and the second function calculates the sum of prime factors of a given number. The puzzle is to ensure that the second function correctly solves the challenge defined by the first function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime factors, sets, and function composition in Python. It provides a practical exercise in implementing and testing functions that deal with prime factorization and set operations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49023377895355225,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(xor_result: int, set1={1, 2, 3, 4}, set2={3, 4, 5, 6}) -> bool:\n    result = set1.symmetric_difference(set2)\n    return xor_result == sum(result)\n\ndef g(set1={1, 2, 3, 4}, set2={3, 4, 5, 6}) -> int:\n    result = set1.symmetric_difference(set2)\n    return sum(result)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and bitwise XOR operation.",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    def swap_without_temp(nums):\n        nums[0] = nums[0] ^ nums[1]\n        nums[1] = nums[0] ^ nums[1]\n        nums[0] = nums[0] ^ nums[1]\n        return nums\n\n    return swap_without_temp(nums) == [7, 3]\n\ndef g():\n    return [3, 7]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(xor_result: int, set1={1, 2, 3, 4}, set2={3, 4, 5, 6}) -> bool:\n    result = set1.symmetric_difference(set2)\n    return xor_result == sum(result)",
        "solution_func": "def g(set1={1, 2, 3, 4}, set2={3, 4, 5, 6}) -> int:\n    result = set1.symmetric_difference(set2)\n    return sum(result)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the XOR result of symmetric difference of two sets is equal to the sum of the symmetric difference, and g calculates the sum of the symmetric difference of two sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of sets, symmetric difference, XOR operation, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5751827955245972,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    return str(n) == str(n)[::-1]\n\ndef g() -> int:\n    import random\n    num = random.randint(10, 999)\n    return int(str(num) + str(num)[::-1])\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and random number generation.",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import random\n    return random.choice([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\n\nassert f(g()) == True\n",
            "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "def f(n: int) -> bool:\n    return str(n) == str(n)[::-1]",
        "solution_func": "def g() -> int:\n    import random\n    num = random.randint(10, 999)\n    return int(str(num) + str(num)[::-1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f(n) that checks if a given integer is a palindrome, and a function g() that generates a random integer and appends its reverse to it. The puzzle requires g() to generate a palindrome number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, random number generation, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5289641618728638,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(strings: List[str]) -> bool:\n    pattern = 'xyx'  # Example pattern to check\n    for string in strings:\n        if pattern in string:\n            return True\n    return False\n\ndef g() -> List[str]:\n    base_patterns = ['xy', 'yx']  # Base patterns\n    generated_strings = []\n    for i in range(1, 6):\n        for j in range(2):\n            generated_strings.append(base_patterns[j] * i)\n    return generated_strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Pattern Recognition, Conditional Logic",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    pattern = [1, 2, 1, 2, 1, 2]  # Example pattern to check\n    if len(nums) < len(pattern):\n        return False\n    ptr = 0\n    for num in nums:\n        if num == pattern[ptr]:\n            ptr += 1\n            if ptr == len(pattern):\n                return True\n    return False\n\ndef g():\n    def generate_pattern():\n        pattern = [1, 2]  # Base pattern\n        while True:\n            yield from pattern\n            pattern.append(pattern[-1] + 1)\n            pattern.append(pattern[-1] + 1)\n\n    pattern_generator = generate_pattern()\n    return [next(pattern_generator) for _ in range(15)]  # Generate a list with the unique pattern\n\nassert f(g()) == True\n",
            "\nfrom itertools import permutations\n\ndef f(permutation: tuple) -> bool:\n    pattern = ('a', 'b', 'c')\n    for perm in permutation:\n        if any(perm[i:i+3] == pattern for i in range(len(perm) - 2)):\n            return True\n    return False\n\ndef g() -> tuple:\n    word = 'abcde'\n    return permutations(word)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(strings: List[str]) -> bool:\n    pattern = 'xyx'  # Example pattern to check\n    for string in strings:\n        if pattern in string:\n            return True\n    return False",
        "solution_func": "def g() -> List[str]:\n    base_patterns = ['xy', 'yx']  # Base patterns\n    generated_strings = []\n    for i in range(1, 6):\n        for j in range(2):\n            generated_strings.append(base_patterns[j] * i)\n    return generated_strings",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires checking if any string in a list of strings contains the pattern 'xyx'. The solution generates a list of strings based on the base patterns 'xy' and 'yx'."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for a specific pattern in a list of strings and generating strings based on certain patterns. The solution function generates strings based on the given base patterns and the puzzle function checks if any of these generated strings contain the specified pattern.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4390875995159149,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(missing_num: int) -> bool:\n    return missing_num == 8\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 9]):\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return total_sum - sum(nums)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to find a missing number in a list.",
        "idx_generation": 77,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(missing_num: int) -> bool:\n    return missing_num == 8",
        "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 9]):\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    return total_sum - sum(nums)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the missing number in a list of integers to make the sum of all numbers equal to a specific value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the missing number in a list of integers to satisfy a specific condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5683861970901489,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    import string\n    palindrome_length = random.randint(5, 10)\n    palindrome = ''.join(random.choice(string.ascii_lowercase) for _ in range(palindrome_length))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Dict\n\ndef f(min_spanning_tree_weight: int, graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}) -> bool:\n    return min_spanning_tree_weight == 3\n\ndef g(graph={0: {1: 2, 2: 3}, 1: {0: 2, 2: 1}, 2: {0: 3, 1: 1}}):\n    min_spanning_tree_weight = 0\n    visited = set()\n    visited.add(0)\n    while len(visited) < len(graph):\n        min_weight = float('inf')\n        min_edge = None\n        for node in visited:\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited and weight < min_weight:\n                    min_weight = weight\n                    min_edge = (node, neighbor)\n        if min_edge:\n            visited.add(min_edge[1])\n            min_spanning_tree_weight += min_weight\n    return min_spanning_tree_weight\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    import string\n    palindrome_length = random.randint(5, 10)\n    palindrome = ''.join(random.choice(string.ascii_lowercase) for _ in range(palindrome_length))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s: str) that checks if a given string is a palindrome, and a function g() that generates a random palindrome string. The puzzle tests whether the generated palindrome string is correctly identified as a palindrome by the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding palindrome strings and string manipulation in Python. It tests the student's ability to generate random strings and check for palindromes using slicing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4529050290584564,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    import sympy\n\n    prime = sympy.randprime(10, 100)\n    return prime\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to Number Theory (primality testing) and Importing Modules (Sympy).",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int, m=2) -> bool:\n    return n % m == 0 and n & (n - 1) == 0\n\ndef g(m=2) -> int:\n    import random\n\n    def generate_number():\n        num = random.randint(1, 100) * m\n        while num & (num - 1) != 0:\n            num = random.randint(1, 100) * m\n        return num\n\n    return generate_number()\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    def swap_without_temp(nums):\n        nums[0] = nums[0] ^ nums[1]\n        nums[1] = nums[0] ^ nums[1]\n        nums[0] = nums[0] ^ nums[1]\n        return nums\n\n    return swap_without_temp(nums) == [7, 3]\n\ndef g():\n    return [3, 7]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    import sympy\n\n    prime = sympy.randprime(10, 100)\n    return prime",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given number is a prime number, and a function g() that generates a random prime number between 10 and 100 using the sympy library. The puzzle requires students to understand prime number checking and random prime number generation in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a basic algorithmic challenge related to prime numbers and random number generation in Python. It can be used to teach students about prime number checking and the sympy library for generating random prime numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6221967935562134,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves a Sudoku board validation algorithm, which requires knowledge of conditional logic, set operations, and algorithm optimization.",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int, nums=[1, 2, 3, 1]) -> bool:\n    def helper(nums):\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n        \n        return max(incl, excl)\n\n    return helper(nums) == max_sum\n\ndef g(nums=[1, 2, 3, 1]):\n    return sum(nums[::2]) if sum(nums[::2]) > sum(nums[1::2]) else sum(nums[1::2])\n\nassert f(g()) == True\n",
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True"
        ],
        "problem_func": "def f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks if a given Sudoku board is valid or not, and a function g that returns a Sudoku board. The goal is to ensure that the Sudoku board returned by g is valid according to the rules of Sudoku."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a classic Sudoku validation problem where the f function checks if the given Sudoku board is valid or not. The g function returns a Sudoku board, and the goal is to ensure that the Sudoku board returned by g is valid according to the rules of Sudoku. The puzzle provides a good exercise for students to understand Sudoku rules and validation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4734150469303131,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Set\n\ndef f(result: Set[int], set1={1, 3, 5, 7, 9}, set2={2, 4, 5, 7, 8}) -> bool:\n    return result == set1.symmetric_difference(set2)\n\ndef g(set1={1, 3, 5, 7, 9}, set2={2, 4, 5, 7, 8}) -> Set[int]:\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves set operations and conditional logic.",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True"
        ],
        "problem_func": "from typing import Set\n\ndef f(result: Set[int], set1={1, 3, 5, 7, 9}, set2={2, 4, 5, 7, 8}) -> bool:\n    return result == set1.symmetric_difference(set2)",
        "solution_func": "def g(set1={1, 3, 5, 7, 9}, set2={2, 4, 5, 7, 8}) -> Set[int]:\n    return set1.symmetric_difference(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, f and g, where f checks if the input set is the symmetric difference of two predefined sets, and g returns the symmetric difference of two predefined sets. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves working with sets and the symmetric difference operation in Python. It is a good exercise to practice set operations and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5816439986228943,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(symmetric_diff: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return symmetric_diff == set1.symmetric_difference(set2)\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> set:\n    return set1.symmetric_difference(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and assertion testing.",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(max_xor: int, nums=[3, 10, 5, 25, 2, 8], target=28) -> bool:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor == max_xor_val\n\ndef g(nums=[3, 10, 5, 25, 2, 8], target=28) -> int:\n    max_xor_val = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        candidate = max_xor_val | (1 << i)\n        \n        for prefix in prefixes:\n            if prefix ^ candidate in prefixes:\n                max_xor_val = candidate\n                break\n    \n    return max_xor_val\n\nassert f(g()) == True\n",
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(symmetric_diff: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> bool:\n    return symmetric_diff == set1.symmetric_difference(set2)",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7}) -> set:\n    return set1.symmetric_difference(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where f checks if the input set is the symmetric difference of two given sets, and g returns the symmetric difference of two given sets. The assert statement checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of sets and symmetric difference in Python, which are important for students to understand. It also tests the students' understanding of function composition and assertion testing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5869900584220886,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(result: float, num=16) -> bool:\n    try:\n        return math.isclose(math.sqrt(num), result)\n    except ValueError:\n        return False\n\ndef g(num=16):\n    try:\n        return math.sqrt(num)\n    except ValueError:\n        return None\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(matrix: List[List[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(i, len(matrix)))\ndef g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g():\n    return \"level\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a given string is a palindrome. The solution function g returns the string 'level', which is a palindrome. The assertion confirms that the solution function g correctly solves the challenge defined by function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6551326513290405,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    triplets = combinations(numbers, 3)\n    for triplet in triplets:\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    return [3, 4, 5, 6, 8]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and importing modules (Itertools).",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(result: float, num=16) -> bool:\n    try:\n        return math.isclose(math.sqrt(num), result)\n    except ValueError:\n        return False\n\ndef g(num=16):\n    try:\n        return math.sqrt(num)\n    except ValueError:\n        return None\n\nassert f(g()) == True\n",
            "\nfrom typing import List\ndef f(matrix: List[List[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i in range(len(matrix)) for j in range(i, len(matrix)))\ndef g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(numbers: list) -> bool:\n    triplets = combinations(numbers, 3)\n    for triplet in triplets:\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False",
        "solution_func": "def g():\n    return [3, 4, 5, 6, 8]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet from a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires checking if there exists a Pythagorean triplet (a, b, c) in the list of numbers such that a^2 + b^2 = c^2.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5072588920593262,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int) -> bool:\n    return factorial == 120\n\ndef g(number=5) -> int:\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and recursion.",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(area: float) -> bool:\n    return area == 4.5\n\ndef g(vertices=[(0, 0), (3, 0), (3, 3)]) -> float:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int) -> bool:\n    return factorial == 120",
        "solution_func": "def g(number=5) -> int:\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to calculate the factorial of a number and checking if the factorial of 5 is equal to 120."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of recursion and factorial calculation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.70209801197052,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(max_product: int, nums=[-2, 3, -4, 5, -6]) -> bool:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result == max_product\n\ndef g(nums=[-2, 3, -4, 5, -6]) -> int:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, dynamic programming, and conditional logic.",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(length: int, sequence=[3, 4, 2, 8, 10, 5, 1]) -> bool:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis) == length\n\ndef g(sequence=[3, 4, 2, 8, 10, 5, 1]) -> int:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_product: int, nums=[-2, 3, -4, 5, -6]) -> bool:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result == max_product",
        "solution_func": "def g(nums=[-2, 3, -4, 5, -6]) -> int:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the maximum product of a given list of numbers matches a specified value, and g calculates the maximum product of the list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to calculate the maximum product of a list of numbers and ensuring that the solution function g returns the correct maximum product. It tests the understanding of list manipulation and mathematical operations in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4191047251224518,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(ways: int, n=4) -> bool:\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways\n\ndef g(n=4) -> int:\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, recursion, and conditional logic.",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(length: int, sequence=[3, 4, 2, 8, 10, 5, 1]) -> bool:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis) == length\n\ndef g(sequence=[3, 4, 2, 8, 10, 5, 1]) -> int:\n    lis = [1] * len(sequence)\n    for i in range(1, len(sequence)):\n        for j in range(0, i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)\n\nassert f(g()) == True\n",
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(ways: int, n=4) -> bool:\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b == ways",
        "solution_func": "def g(n=4) -> int:\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if a given number of ways can be achieved using a specific algorithm, and g calculates the number of ways using the same algorithm. The puzzle tests the correctness of the algorithm implemented in function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves Fibonacci sequence calculation and checking if a specific number of ways can be achieved using the Fibonacci sequence. The solution function g calculates the Fibonacci sequence up to a given number, and the puzzle function f checks if the calculated Fibonacci number matches the expected number of ways.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5948446393013,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(result: int, operation='+', threshold=50) -> bool:\n    if operation == '+':\n        return result > threshold\n    elif operation == '-':\n        return result < threshold\n    else:\n        return False\n\ndef g(operation='+', threshold=50):\n    num = random.randint(1, 100)\n    if operation == '+':\n        return num + threshold\n    elif operation == '-':\n        return num - threshold\n    else:\n        return None\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "def f(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537) -> bool:\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 247586288427023352, b = 372021520735824432, lower_bound = 1709054537):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g()) == True",
            "\ndef f(result: float, num1=10, num2=5, op='/') -> bool:\n    try:\n        if op == '+':\n            return num1 + num2 == result\n        elif op == '-':\n            return num1 - num2 == result\n        elif op == '*':\n            return num1 * num2 == result\n        elif op == '/':\n            return num1 / num2 == result\n    except ZeroDivisionError:\n        return False\n\ndef g(num1=10, num2=5, op='/'):\n    try:\n        if op == '+':\n            return num1 + num2\n        elif op == '-':\n            return num1 - num2\n        elif op == '*':\n            return num1 * num2\n        elif op == '/':\n            return num1 / num2\n    except ZeroDivisionError:\n        return None\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(result: int, operation='+', threshold=50) -> bool:\n    if operation == '+':\n        return result > threshold\n    elif operation == '-':\n        return result < threshold\n    else:\n        return False",
        "solution_func": "def g(operation='+', threshold=50):\n    num = random.randint(1, 100)\n    if operation == '+':\n        return num + threshold\n    elif operation == '-':\n        return num - threshold\n    else:\n        return None",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f and g, where f checks if the result of g meets a certain condition based on the operation and threshold values provided."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of function calls, conditional statements, and comparison operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5798441171646118,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport sympy\n\ndef f(number: int) -> bool:\n    return sympy.isprime(number)\n\ndef g() -> int:\n    return sympy.randprime(1, 100)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, importing modules, and assertion testing.",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import sympy\n\ndef f(number: int) -> bool:\n    return sympy.isprime(number)",
        "solution_func": "def g() -> int:\n    return sympy.randprime(1, 100)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating a random prime number between 1 and 100 using the sympy library and checking if the generated number is a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of prime numbers and the sympy library in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.7332026362419128,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(factorial: int) -> bool:\n    return factorial % 10 == 0\n\ndef g(number=5) -> int:\n    return math.factorial(number)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves checking if the factorial of a number ends with 0.",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(factorial: int) -> bool:\n    return factorial % 10 == 0",
        "solution_func": "def g(number=5) -> int:\n    return math.factorial(number)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the factorial of a given number is divisible by 10, and a function g that calculates the factorial of a number. The assertion checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic understanding of functions, factorial calculation, and modulo operation in Python. It can be used to teach Python programming concepts to master's students in CS.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6710935235023499,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters)\n    palindrome += ''.join(random.choices(letters, k=5))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(subset: set, predefined_set={1, 2, 3, 4, 5, 6, 7, 8, 9}) -> bool:\n    return subset.issubset(predefined_set)\n\ndef g() -> set:\n    import random\n    return set(random.sample(range(1, 10), k=5))\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(area: float, radius=5) -> bool:\n    return math.isclose(area, math.pi * radius**2)\n\ndef g(radius=5) -> float:\n    return math.pi * radius**2\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = random.choice(letters)\n    palindrome += ''.join(random.choices(letters, k=5))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a given string is a palindrome and generating a random string to test this function. The solution function generates a random string and its palindrome to test the palindrome check function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48693373799324036,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(words: list) -> bool:\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return len(set(sorted_words)) == 1\n\ndef g():\n    return [\"listen\", \"silent\", \"enlist\", \"tinsel\"]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations to check if a list of words are anagrams of each other.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(words: list) -> bool:\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return len(set(sorted_words)) == 1",
        "solution_func": "def g():\n    return [\"listen\", \"silent\", \"enlist\", \"tinsel\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires checking if a list of words are anagrams of each other."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting each word in a list and checking if all the sorted words are the same, indicating that the original words are anagrams of each other.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.46435272693634033,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False\n\ndef g():\n    return [3, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, conditional logic, and brute force search.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    return True\n    return False",
        "solution_func": "def g():\n    return [3, 4, 5, 6, 8, 10]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a Pythagorean triplet in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if there exists a Pythagorean triplet (three numbers that satisfy the Pythagorean theorem) in a given list of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4772006571292877,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check if a word is a palindrome.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome (reads the same forwards and backwards) by comparing the word to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function f(word) that returns True if the input word is a palindrome, and a function g() that returns the word 'radar'. The assertion checks if f(g()) returns True, indicating that 'radar' is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5793375372886658,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] == s[-1]:\n            return is_palindrome(s[1:-1])\n        else:\n            return False\n\n    return is_palindrome(s)\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and recursion to check if a given string is a palindrome.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(numbers):\n            return False\n        # Include the current number in the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]):\n            return True\n        # Exclude the current number from the subset\n        if subset_sum(numbers, target_sum, index + 1, current_sum):\n            return True\n        return False\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g(target_sum=10):\n    return [i % 5 for i in range(1, 11)]\n\nassert f(g()) == True\n",
            "\ndef f(n: int, target=50) -> bool:\n    seen = set()\n    for num in n:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr=[10, 20, 30, 40]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        if s[0] == s[-1]:\n            return is_palindrome(s[1:-1])\n        else:\n            return False\n\n    return is_palindrome(s)",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function that checks if a given string is a palindrome. The solution function returns a specific palindrome string and asserts that the defined function correctly identifies it as a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and string manipulation to check for palindromes in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5054689049720764,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, target-9]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])\n\ndef g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6734426617622375,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g(s=\"A man a plan a canal Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))\n\ndef g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man a plan a canal Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome after removing spaces and converting all characters to lowercase."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a string is a palindrome after removing spaces and converting all characters to lowercase. The solution function simply returns a specific string.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5510347485542297,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import combinations\n\ndef f(chars: list, word=\"cat\") -> bool:\n    for r in range(1, len(chars)+1):\n        for subset in combinations(chars, r):\n            if \"\".join(subset) == word:\n                return True\n    return False\n\ndef g(chars=['c', 'a', 't', 's', 'r']):\n    return chars\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and permutations and combinations.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))\n\ndef g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import combinations\n\ndef f(chars: list, word=\"cat\") -> bool:\n    for r in range(1, len(chars)+1):\n        for subset in combinations(chars, r):\n            if \"\".join(subset) == word:\n                return True\n    return False",
        "solution_func": "def g(chars=['c', 'a', 't', 's', 'r']):\n    return chars",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a subset of characters from a given list that forms a specific word 'cat'."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using the itertools combinations function to generate all possible subsets of characters from the given list and checking if any subset forms the word 'cat'. The solution function simply returns the list of characters provided.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.41897574067115784,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom itertools import product\n\ndef f(binary_strings: list) -> bool:\n    for string in binary_strings:\n        if all(string[i] != string[i + 1] for i in range(len(string) - 1)):\n            return True\n    return False\n\ndef g(length=3):\n    return [''.join(seq) for seq in product('01', repeat=length)]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and importing modules (Itertools). It generates binary strings of a specified length and checks if there exists a string where consecutive characters are different.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(nums: List[int]) -> bool:\n    unique_perms = set(permutations(nums))\n    return len(unique_perms) == len(set(unique_perms))\n\ndef g():\n    import random\n\n    random_nums = random.sample(range(1, 6), 3)\n    return random_nums\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(n: int, target=100) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 30, 40, 50]):\n    return arr\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from itertools import product\n\ndef f(binary_strings: list) -> bool:\n    for string in binary_strings:\n        if all(string[i] != string[i + 1] for i in range(len(string) - 1)):\n            return True\n    return False",
        "solution_func": "def g(length=3):\n    return [''.join(seq) for seq in product('01', repeat=length)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all possible binary strings of a given length and checking if any of them have alternating characters (0 and 1) in the string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate binary strings using itertools.product and check for alternating characters in the strings.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3075287640094757,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(prob: float) -> bool:\n    deck = list(itertools.product(range(1, 14), ['Hearts', 'Diamonds', 'Clubs', 'Spades']))\n    straight_flushes = sum(1 for hand in itertools.combinations(deck, 5) if is_straight_flush(hand))\n    total_hands = len(list(itertools.combinations(deck, 5)))\n    return straight_flushes / total_hands == prob\n\ndef g():\n    return 36 / 2598960\n\ndef is_straight_flush(hand):\n    values = [card[0] for card in hand]\n    suits = [card[1] for card in hand]\n    return len(set(suits)) == 1 and max(values) - min(values) == 4 and len(set(values)) == 5\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Probability and Statistics",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
            "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True"
        ],
        "problem_func": "import itertools\n\ndef f(prob: float) -> bool:\n    deck = list(itertools.product(range(1, 14), ['Hearts', 'Diamonds', 'Clubs', 'Spades']))\n    straight_flushes = sum(1 for hand in itertools.combinations(deck, 5) if is_straight_flush(hand))\n    total_hands = len(list(itertools.combinations(deck, 5)))\n    return straight_flushes / total_hands == prob",
        "solution_func": "def g():\n    return 36 / 2598960\n\ndef is_straight_flush(hand):\n    values = [card[0] for card in hand]\n    suits = [card[1] for card in hand]\n    return len(set(suits)) == 1 and max(values) - min(values) == 4 and len(set(values)) == 5",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the probability of getting a straight flush in a 5-card poker hand from a standard deck of cards."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle uses itertools to generate all possible 5-card hands from a deck of cards and checks if each hand is a straight flush. The solution g() calculates the probability of getting a straight flush in a 5-card hand. The puzzle f(prob) compares the actual probability with the calculated probability.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.48912543058395386,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr: List[int]) -> bool:\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n\n    def check_rows(board):\n        return all(is_valid(row) for row in board)\n\n    def check_columns(board):\n        return all(is_valid([board[i][j] for i in range(9)]) for j in range(9))\n\n    def check_subgrids(board):\n        return all(is_valid([board[i + m][j + n] for i in range(3) for j in range(3)]) for m in range(0, 9, 3) for n in range(0, 9, 3))\n\n    return check_rows(board) and check_columns(board) and check_subgrids(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Sudoku validation, which includes checking rows, columns, and subgrids for valid entries. This requires knowledge of list manipulation, iteration, and set operations.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr: List[int]) -> bool:\n        arr = [i for i in arr if i != 0]\n        return len(arr) == len(set(arr))\n\n    def check_rows(board):\n        return all(is_valid(row) for row in board)\n\n    def check_columns(board):\n        return all(is_valid([board[i][j] for i in range(9)]) for j in range(9))\n\n    def check_subgrids(board):\n        return all(is_valid([board[i + m][j + n] for i in range(3) for j in range(3)]) for m in range(0, 9, 3) for n in range(0, 9, 3))\n\n    return check_rows(board) and check_columns(board) and check_subgrids(board)",
        "solution_func": "def g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given Sudoku board is valid by ensuring that each row, column, and subgrid contains unique numbers from 1 to 9."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of nested loops, list comprehensions, and boolean logic in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.39395254850387573,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid_move(row, col, num):\n        for i in range(9):\n            if grid[row][i] == num or grid[i][col] == num or grid[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if grid[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(i, j, num):\n                            grid[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            grid[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku()\n\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a Sudoku puzzle using backtracking algorithm.",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True"
        ],
        "problem_func": "from typing import List\ndef f(grid: List[List[int]]) -> bool:\n    def is_valid_move(row, col, num):\n        for i in range(9):\n            if grid[row][i] == num or grid[i][col] == num or grid[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku():\n        for i in range(9):\n            for j in range(9):\n                if grid[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid_move(i, j, num):\n                            grid[i][j] = num\n                            if solve_sudoku():\n                                return True\n                            grid[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku()",
        "solution_func": "def g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves implementing a Sudoku solver using a recursive backtracking algorithm in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires the student to implement a function that solves a Sudoku puzzle using a recursive backtracking approach. The solution function initializes a Sudoku grid and the puzzle function checks if the solution is correct by solving the Sudoku puzzle.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4149523675441742,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory (primes).",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g(num=17):\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number or not, and a function g(num) that returns a specific number (default is 17). The goal is to ensure that f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of prime numbers and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.633959949016571,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g(word=\"radar\"):\n    return word\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves String Manipulation and Conditional Logic.",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(intervals: List[List[int]]) -> bool:\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\ndef g(intervals=[[1, 3], [2, 6], [5, 8], [9, 12]]):\n    return intervals\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g(word=\"radar\"):\n    return word",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given word is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that checks if a word is a palindrome by comparing it to its reverse. The function g returns a default word 'radar'. The assert statement checks if the function f applied to the output of function g returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6261258125305176,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_product: int, numbers=[2, 3, 5, 7]) -> bool:\n    return max_product == 35\n\ndef g(numbers=[2, 3, 5, 7]) -> int:\n    max_product = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            max_product = max(max_product, numbers[i]*numbers[j])\n    return max_product\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and brute force search.",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount\n\ndef g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used\n\nassert f(g()) == True\n",
            "\n\ndef f(area: float) -> bool:\n    return area == 4.5\n\ndef g(vertices=[(0, 0), (3, 0), (3, 3)]) -> float:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_product: int, numbers=[2, 3, 5, 7]) -> bool:\n    return max_product == 35",
        "solution_func": "def g(numbers=[2, 3, 5, 7]) -> int:\n    max_product = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            max_product = max(max_product, numbers[i]*numbers[j])\n    return max_product",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum product of two numbers in a given list and checking if it equals a specific value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to find the maximum product of two numbers in a list and compare it to a specific value.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5607740879058838,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(sorted_points: list) -> bool:\n    return sorted_points == [(0, 0), (1, 1), (2, 2), (3, 4), (4, 3)]\n\ndef g(points=[(3, 4), (1, 1), (4, 3), (0, 0), (2, 2)]) -> list:\n    return sorted(points, key=lambda p: math.sqrt(p[0]**2 + p[1]**2))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of points based on their distance from the origin using the Euclidean distance formula. The solution uses the `sorted` function with a custom key function to achieve this. The puzzle also includes an assertion to check if the solution satisfies the condition defined in function `f`.",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(sorted_list: list) -> bool:\n    return sorted_list == [0, 1, 2, 4, 8, 3, 5, 6, 9, 10]\n\ndef g(numbers=[1, 2, 3, 4, 5, 6, 8, 9, 10, 0]) -> list:\n    return sorted(numbers, key=lambda x: bin(x).count('1'))\n\nassert f(g()) == True\n",
            "\ndef f(set_bits: int, num=23) -> bool:\n    return set_bits == bin(num).count('1')\n\ndef g(num=23) -> int:\n    return bin(num).count('1')\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(sorted_points: list) -> bool:\n    return sorted_points == [(0, 0), (1, 1), (2, 2), (3, 4), (4, 3)]",
        "solution_func": "def g(points=[(3, 4), (1, 1), (4, 3), (0, 0), (2, 2)]) -> list:\n    return sorted(points, key=lambda p: math.sqrt(p[0]**2 + p[1]**2))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves sorting a list of points based on their distance from the origin and checking if the sorted list matches a specific order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand sorting lists using a custom key function and comparing lists for equality.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5459844470024109,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport cmath\n\ndef f(result: complex, a=2, b=1, c=5) -> bool:\n    equation_result = (-b + cmath.sqrt(b**2 - 4*a*c)) / (2*a)\n    return abs(equation_result - result) < 1e-6\n\ndef g(a=2, b=1, c=5):\n    equation_result = (-b + cmath.sqrt(b**2 - 4*a*c)) / (2*a)\n    return equation_result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, importing modules (cmath), and conditional logic.",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\nimport random\n\ndef f(expected_probability: float, sample_size=1000) -> bool:\n    random.seed(3)\n    num_heads = sum(random.choice(['H', 'T']) == 'H' for _ in range(sample_size))\n    probability_heads = num_heads / sample_size\n    return abs(probability_heads - expected_probability) < 0.05\n\ndef g():\n    return 0.5\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import cmath\n\ndef f(result: complex, a=2, b=1, c=5) -> bool:\n    equation_result = (-b + cmath.sqrt(b**2 - 4*a*c)) / (2*a)\n    return abs(equation_result - result) < 1e-6",
        "solution_func": "def g(a=2, b=1, c=5):\n    equation_result = (-b + cmath.sqrt(b**2 - 4*a*c)) / (2*a)\n    return equation_result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the result of a quadratic equation matches a given complex number within a small margin of error, and a function g that calculates the result of the quadratic equation."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding complex numbers, quadratic equations, and comparison of floating-point numbers with a tolerance.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6144176125526428,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport random\n\ndef f(return_probability: float, num_steps=1000) -> bool:\n    position = 0\n    return_count = 0\n    for _ in range(num_steps):\n        position += random.choice([-1, 1])\n        if position == 0:\n            return_count += 1\n    probability = return_count / num_steps\n    return abs(probability - return_probability) < 0.1\n\ndef g(num_steps=1000):\n    position = 0\n    return_count = 0\n    for _ in range(num_steps):\n        position += random.choice([-1, 1])\n        if position == 0:\n            return_count += 1\n    return_probability = return_count / num_steps\n    return return_probability\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics as it deals with calculating the probability of a certain event happening. It also involves importing modules (random) for generating random numbers.",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
            "\nimport random\n\ndef f(expected_probability: float, sample_size=1000) -> bool:\n    random.seed(3)\n    num_heads = sum(random.choice(['H', 'T']) == 'H' for _ in range(sample_size))\n    probability_heads = num_heads / sample_size\n    return abs(probability_heads - expected_probability) < 0.05\n\ndef g():\n    return 0.5\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(return_probability: float, num_steps=1000) -> bool:\n    position = 0\n    return_count = 0\n    for _ in range(num_steps):\n        position += random.choice([-1, 1])\n        if position == 0:\n            return_count += 1\n    probability = return_count / num_steps\n    return abs(probability - return_probability) < 0.1",
        "solution_func": "def g(num_steps=1000):\n    position = 0\n    return_count = 0\n    for _ in range(num_steps):\n        position += random.choice([-1, 1])\n        if position == 0:\n            return_count += 1\n    return_probability = return_count / num_steps\n    return return_probability",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, f and g. Function f calculates the probability of returning to the starting position after a certain number of steps in a random walk, and function g calculates the actual probability of returning to the starting position after the same number of steps. The puzzle checks if the difference between the calculated and expected probabilities is less than 0.1."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a random walk simulation and probability calculation, which can be a good exercise for students to understand probability concepts and practice Python programming skills. The solution function g correctly calculates the probability of returning to the starting position after a random walk, and the puzzle function f checks if this probability is within a certain threshold.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.46050041913986206,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def subset_sum(nums, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(nums):\n            return False\n\n        include = subset_sum(nums, target_sum, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target_sum, index + 1, current_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target_sum, 0, 0)\n\ndef g():\n    return [2, 4, 5, 6, 7, 8]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    def can_jump(nums):\n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\n    return can_jump(nums)\n\ndef g(nums = [2, 3, 1, 1, 4]):\n    return nums\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6713931560516357,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection_set: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7, 8}) -> bool:\n    target_set = {3, 4, 5}\n    return intersection_set == target_set\n\ndef g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7, 8}):\n    return set1.intersection(set2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(max_sum: int, arr=[3, 2, 7, 10, 5]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(arr=[3, 2, 7, 10, 5]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(intersection_set: set, set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7, 8}) -> bool:\n    target_set = {3, 4, 5}\n    return intersection_set == target_set",
        "solution_func": "def g(set1={1, 2, 3, 4, 5}, set2={3, 4, 5, 6, 7, 8}):\n    return set1.intersection(set2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining two sets and a function to check if the intersection of the two sets is equal to a target set."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding sets and set operations in Python, specifically the intersection operation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5483905076980591,
        "judgeLM-7b-abs_finetuning": 7.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(max_sum: int, arr=[3, 2, 5, 10, 7, 8]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(arr=[3, 2, 5, 10, 7, 8]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve the maximum sum subsequence problem.",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(longest_subsequence_length: int, numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]) -> bool:\n    return longest_subsequence_length == 6\n\ndef g(numbers=[10, 22, 9, 33, 21, 50, 41, 60, 80]):\n    if not numbers:\n        return 0\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
            "\ndef f(max_sum: int, arr=[3, 2, 7, 10, 5]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum\n\ndef g(arr=[3, 2, 7, 10, 5]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_sum: int, arr=[3, 2, 5, 10, 7, 8]) -> bool:\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl) == max_sum",
        "solution_func": "def g(arr=[3, 2, 5, 10, 7, 8]):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions, f and g, where f checks if the maximum sum of a subsequence in an array matches a given value, and g calculates the maximum sum of a subsequence in the array."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves dynamic programming concepts and requires understanding of how to calculate the maximum sum of a subsequence in an array. It can be used to teach students about dynamic programming and algorithmic problem-solving in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.48627418279647827,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: int) -> bool:\n    return str(palindrome) == str(palindrome)[::-1]\n\ndef g() -> int:\n    for num in range(1000, 10000):\n        if str(num) == str(num)[::-1]:\n            return num\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for palindrome numbers.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 3:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g() -> List[int]:\n    start = 5\n    diff = 3\n    length = 7\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: int) -> bool:\n    return str(palindrome) == str(palindrome)[::-1]",
        "solution_func": "def g() -> int:\n    for num in range(1000, 10000):\n        if str(num) == str(num)[::-1]:\n            return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if there is a palindrome number between 1000 and 9999."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(palindrome) that checks if a given number is a palindrome. The function g() iterates through numbers between 1000 and 9999 to find the first palindrome number. The assertion at the end verifies that the solution g() returns a palindrome number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.548410952091217,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str) -> bool:\n    palindrome = ''.join(char.lower() for char in palindrome if char.isalnum())\n    return palindrome == palindrome[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to check for a palindrome.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 3:\n        return True\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g() -> List[int]:\n    start = 5\n    diff = 3\n    length = 7\n    return [start + diff*i for i in range(length)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: str) -> bool:\n    palindrome = ''.join(char.lower() for char in palindrome if char.isalnum())\n    return palindrome == palindrome[::-1]",
        "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal, Panama!\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f that checks if a string is a palindrome after removing non-alphanumeric characters, and a function g that returns a specific string, determine if the string returned by g is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a specific string is a palindrome after removing non-alphanumeric characters. The solution function g returns a specific string, and the puzzle function f checks if this string is a palindrome. The assertion at the end confirms the correctness of the solution.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5399506092071533,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    return str(n) == str(n)[::-1]\n\ndef g():\n    num = 101\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
            "\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    primes = [True] * (num + 1)\n    primes[0], primes[1] = False, False\n    for i in range(2, int(num**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, num + 1, i):\n                primes[j] = False\n    return primes[num]\n\ndef g(num=17):\n    return num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    return str(n) == str(n)[::-1]",
        "solution_func": "def g():\n    num = 101\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given integer is a palindrome, and a function g() that iterates through numbers starting from 101 until it finds a palindrome number. The assertion checks if the solution returned by g() satisfies the condition of f()."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromic numbers in Python using string manipulation and iteration. It also tests the ability to define functions and use assertions for validation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6399800181388855,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    length = random.randint(3, 7)\n    half_length = length // 2\n\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[-2::-1])\n\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to generate a palindrome and check if it is indeed a palindrome.",
        "idx_generation": 82,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    import random\n\n    n = random.randint(3, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]  # Make the matrix symmetric\n\n    return matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    length = random.randint(3, 7)\n    half_length = length // 2\n\n    palindrome_half = ''.join(random.choice(letters) for _ in range(half_length))\n    palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[-2::-1])\n\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a random string and checking if it is a palindrome by comparing it with its reverse. The solution function generates a random palindrome string and returns it.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4065937101840973,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime = random.randint(2, 100)\n    while not is_prime(prime):\n        prime = random.randint(2, 100)\n\n    return prime\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for prime numbers using a brute force search algorithm. It also includes the use of random number generation and a while loop to find a prime number.",
        "idx_generation": 82,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(num: int) -> bool:\n    try:\n        if num < 0 or num > 100:\n            raise ValueError(\"Number out of range\")\n        elif num % 2 != 0:\n            raise ValueError(\"Number must be even\")\n        else:\n            return True\n    except ValueError:\n        return False\ndef g():\n    import random\n    num = random.randint(-10, 110)\n    if num % 2 != 0:\n        num += 1\n    return num\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    import random\n\n    n = random.randint(3, 5)\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            matrix[j][i] = matrix[i][j]  # Make the matrix symmetric\n\n    return matrix\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime = random.randint(2, 100)\n    while not is_prime(prime):\n        prime = random.randint(2, 100)\n\n    return prime",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(number) that checks if a given number is prime, and a function g() that generates a random prime number between 2 and 100. The puzzle requires ensuring that the generated random prime number satisfies the condition of being prime according to the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to check for primality. It also requires generating random numbers and validating them as prime. This puzzle can be used to teach Python programming concepts related to prime numbers and function implementation.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5028099417686462,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(n: int) -> bool:\n    return str(n) == str(n)[::-1]\n\ndef g():\n    import random\n    num = random.randint(10, 99)\n    return int(str(num) + str(num)[::-1])\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
            "\nfrom math import factorial\n\ndef f(result: int) -> bool:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(sum(int(digit) for digit in str(result)))\n\ndef g(number=5) -> int:\n    return factorial(number)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(n: int) -> bool:\n    return str(n) == str(n)[::-1]",
        "solution_func": "def g():\n    import random\n    num = random.randint(10, 99)\n    return int(str(num) + str(num)[::-1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(n) that checks if a given integer is a palindrome, and a function g() that generates a random two-digit number and appends its reverse to it. The puzzle requires g() to return a number that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, random number generation, and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5280457139015198,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(length: int) -> bool:\n    target_length = 4\n    return length == target_length\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to find the length of the longest increasing subsequence in a list of numbers. It also includes conditional logic to check if the length of the longest increasing subsequence is equal to a target length.",
        "idx_generation": 82,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(sum_combination: int) -> bool:\n    return sum_combination == 20\n\ndef g(numbers=[5, 4, 10, 6, 8, 3]):\n    def backtrack(index, path, current_sum):\n        nonlocal sum_combination\n        if current_sum == 20:\n            sum_combination = 20\n            return\n        if current_sum > 20 or index == len(numbers):\n            return\n\n        path.append(numbers[index])\n        backtrack(index + 1, path, current_sum + numbers[index])\n        path.pop()\n        backtrack(index + 1, path, current_sum)\n\n    sum_combination = 0\n    backtrack(0, [], 0)\n    return sum_combination\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_move(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku_util(board):\n        empty_cell = find_empty_cell(board)\n        if not empty_cell:\n            return True\n\n        row, col = empty_cell\n        for num in range(1, 10):\n            if is_valid_move(board, row, col, num):\n                board[row][col] = num\n                if solve_sudoku_util(board):\n                    return True\n                board[row][col] = 0\n\n        return False\n\n    def find_empty_cell(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    return (i, j)\n        return None\n\n    return solve_sudoku_util(board)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n             [6, 0, 0, 1, 9, 5, 0, 0, 0],\n             [0, 9, 8, 0, 0, 0, 0, 6, 0],\n             [8, 0, 0, 0, 6, 0, 0, 0, 3],\n             [4, 0, 0, 8, 0, 3, 0, 0, 1],\n             [7, 0, 0, 0, 2, 0, 0, 0, 6],\n             [0, 6, 0, 0, 0, 0, 2, 8, 0],\n             [0, 0, 0, 4, 1, 9, 0, 0, 5],\n             [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(length: int) -> bool:\n    target_length = 4\n    return length == target_length",
        "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python. The first function f(length) checks if the input length is equal to a target length of 4. The second function g(nums) implements a dynamic programming algorithm to find the length of the longest increasing subsequence in a list of numbers. The assertion checks if the output of g satisfies the condition of f, returning True if it does."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves a dynamic programming problem to find the length of the longest increasing subsequence, which may be too complex for master's students in CS who are learning Python. It requires understanding of dynamic programming concepts and may not be suitable for beginners.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.46886467933654785,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(s=\"racecar\") -> str:\n    return s[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount\n\ndef g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used\n\nassert f(g()) == True\n",
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(s=\"racecar\") -> str:\n    return s[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if a given string is a palindrome and the second function returns the reverse of a default string. The assertion checks if the second function correctly solves the challenge of the first function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding string manipulation in Python, specifically reversing a string and checking for palindromes.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6447626352310181,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sequence: list) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] == sequence[i - 1] + sequence[i - 2] for i in range(2, len(sequence)))\n\ndef g() -> list:\n    fibonacci = [0, 1]\n    while len(fibonacci) < 5:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a given sequence follows the Fibonacci sequence pattern. The solution generates the Fibonacci sequence and checks if it satisfies the pattern defined in the puzzle.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount\n\ndef g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used\n\nassert f(g()) == True\n",
            "\ndef f(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 17\n    while True:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            return num\n        num += 1\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sequence: list) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] == sequence[i - 1] + sequence[i - 2] for i in range(2, len(sequence)))",
        "solution_func": "def g() -> list:\n    fibonacci = [0, 1]\n    while len(fibonacci) < 5:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given list of numbers forms a Fibonacci sequence of length 5 or more."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Fibonacci sequence and list manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5106589198112488,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g():\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        first_half = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    return generate_palindrome(random.randint(3, 10))\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic. The function f checks if a given string is a palindrome by removing spaces and comparing it with its reverse. The function g generates a random palindrome string of a random length using string manipulation and conditional logic.",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom itertools import combinations\n\ndef f(n: list, target=1000) -> bool:\n    for r in range(1, len(n)+1):\n        for subset in combinations(n, r):\n            if r == 1 and subset[0] == target:  # Handling single element case\n                return True\n            product = 1\n            for num in subset:\n                product *= num\n            if product == target:\n                return True\n    return False\n\ndef g(arr=[10, 20, 25, 40, 50]):\n    return arr\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]",
        "solution_func": "def g():\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        first_half = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        second_half = first_half[::-1] if length % 2 == 0 else first_half[:-1][::-1]\n        return first_half + second_half\n\n    return generate_palindrome(random.randint(3, 10))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome after removing spaces and converting to lowercase. The solution function g() generates a random palindrome string of a random length and checks if it satisfies the palindrome condition."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves string manipulation, random generation, and palindrome checking in Python. It can be used to teach concepts like string operations, functions, and condition checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.3681824207305908,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    import random\n    n = random.randint(5, 10)\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + i*diff for i in range(n)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of numbers forms an arithmetic sequence with a common difference. It also includes generating random lists of numbers to test the function. The topics used in this puzzle are: List Operations, Random Number Generation, Arithmetic Operations, and Looping.",
        "idx_generation": 83,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(target_value: int, sequence_length=100) -> bool:\n    random.seed(1)\n    sequence = [random.randint(1, 100) for _ in range(sequence_length)]\n    sorted_sequence = sorted(sequence)\n    median_index = len(sorted_sequence) // 2\n    median_value = sorted_sequence[median_index]\n    return abs(median_value - target_value) < 10\n\ndef g():\n    return 50\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    if len(nums) < 2:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True",
        "solution_func": "def g():\n    import random\n    n = random.randint(5, 10)\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + i*diff for i in range(n)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(nums) and g(), where f checks if a list of numbers follows an arithmetic sequence and g generates a random list of numbers to test with f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a randomly generated list of numbers follows an arithmetic sequence. The solution function g generates a random list of numbers to test with the condition in function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5270448327064514,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result, n=3) -> bool:\n    return str(result) == str(result)[::-1]\n\ndef g(n=3):\n    max_palindrome = 0\n    for i in range(10**(n-1), 10**n):\n        for j in range(10**(n-1), 10**n):\n            product = i * j\n            if str(product) == str(product)[::-1] and product > max_palindrome:\n                max_palindrome = product\n    return max_palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for palindromes and brute force search to find the maximum palindrome product of two n-digit numbers.",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, target-9]\n\nassert f(g()) == True\n",
            "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result, n=3) -> bool:\n    return str(result) == str(result)[::-1]",
        "solution_func": "def g(n=3):\n    max_palindrome = 0\n    for i in range(10**(n-1), 10**n):\n        for j in range(10**(n-1), 10**n):\n            product = i * j\n            if str(product) == str(product)[::-1] and product > max_palindrome:\n                max_palindrome = product\n    return max_palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given number is a palindrome, and a function g that finds the largest palindrome product of two n-digit numbers. The assertion checks if the largest palindrome product found by g satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of palindrome numbers, string manipulation, loops, and conditional statements in Python. It provides a practical application of these concepts by finding the largest palindrome product of two n-digit numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5604357719421387,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport re\n\ndef f(s: str) -> bool:\n    cleaned_s = re.sub('[\\W_]', '', s).lower()\n    return cleaned_s == cleaned_s[::-1]\n\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and pattern recognition.",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True"
        ],
        "problem_func": "import re\n\ndef f(s: str) -> bool:\n    cleaned_s = re.sub('[\\W_]', '', s).lower()\n    return cleaned_s == cleaned_s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal, Panama!\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "Given a string, the puzzle checks if the string is a palindrome after removing all non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after removing all non-alphanumeric characters and ignoring case.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4979747533798218,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(subsequence: list) -> bool:\n    return len(subsequence) > 2\n\ndef g(numbers=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(0, i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    \n    subsequence = []\n    for i in range(len(numbers) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(numbers[i])\n            max_length -= 1\n    return subsequence[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the longest increasing subsequence in a list of numbers.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(subsequence: list) -> bool:\n    return len(subsequence) > 2",
        "solution_func": "def g(numbers=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(numbers)\n    for i in range(1, len(numbers)):\n        for j in range(0, i):\n            if numbers[i] > numbers[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    \n    subsequence = []\n    for i in range(len(numbers) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(numbers[i])\n            max_length -= 1\n    return subsequence[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest increasing subsequence in a given list of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(subsequence) that checks if the length of the subsequence is greater than 2, and a function g(numbers) that finds the longest increasing subsequence in the given list of numbers. The solution g() returns the longest increasing subsequence of the input list of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4342655539512634,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    cleaned_string = ''.join(char.lower() for char in string if char.isalnum())\n    return cleaned_string == cleaned_string[::-1]\n\ndef g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choice(letters) for _ in range(7))\n    return palindrome + palindrome[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to check if a string is a palindrome. It also includes importing modules for generating random strings.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    cleaned_string = ''.join(char.lower() for char in string if char.isalnum())\n    return cleaned_string == cleaned_string[::-1]",
        "solution_func": "def g():\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = ''.join(random.choice(letters) for _ in range(7))\n    return palindrome + palindrome[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if a given string is a palindrome after removing non-alphanumeric characters, and a function g that generates a random palindrome string. The assert statement checks if function f returns True when applied to the output of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of string manipulation, palindrome checking, list comprehensions, and random string generation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.47811031341552734,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(intersection: list) -> bool:\n    return len(intersection) > 0\n\ndef g(arr1=[1, 3, 4, 6, 9], arr2=[2, 4, 6, 8, 9]):\n    intersection = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] == arr2[j]:\n            intersection.append(arr1[i])\n            i += 1\n            j += 1\n        elif arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n    return intersection\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and comparison operations to find the intersection of two lists.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(arr: list) -> bool:\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum > 0\n\ndef g(numbers=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return numbers\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n\ndef g():\n    import random\n\n    numbers = random.sample(range(1, 20), 7)\n    # Bubble Sort Algorithm\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(intersection: list) -> bool:\n    return len(intersection) > 0",
        "solution_func": "def g(arr1=[1, 3, 4, 6, 9], arr2=[2, 4, 6, 8, 9]):\n    intersection = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] == arr2[j]:\n            intersection.append(arr1[i])\n            i += 1\n            j += 1\n        elif arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n    return intersection",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing two functions: f checks if the intersection of two lists is non-empty, and g finds the intersection of two input lists. The solution g returns the intersection of the input lists, and f checks if the intersection is non-empty."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding list intersections and implementing the logic to find the intersection of two lists. It tests the student's knowledge of list manipulation and comparison operations in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4345959722995758,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(perm: str, word='abc') -> bool:\n    perms = [''.join(p) for p in itertools.permutations(word)]\n    return perm in perms\n\ndef g(word='abc'):\n    return word\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves permutations and combinations using the itertools module in Python. It also includes string manipulation to check if a given permutation exists in a list of permutations of a word.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(area: float, vertices=[(0, 0), (4, 0), (0, 3)]) -> bool:\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2 - area) < 1e-6\n\ndef g(vertices=[(0, 0), (4, 0), (0, 3)]):\n    x, y = zip(*vertices)\n    return abs(sum(x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(len(vertices) - 1)) / 2)\n\nassert f(g()) == True\n",
            "\n\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    eigenvalues = np.linalg.eigvals(matrix)\n    sum_eigenvalues = np.sum(eigenvalues)\n    trace_matrix = np.trace(matrix)\n    return np.isclose(sum_eigenvalues, trace_matrix)\n\ndef g(size: int = 3):\n    return np.random.randint(1, 10, size=(size, size))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(perm: str, word='abc') -> bool:\n    perms = [''.join(p) for p in itertools.permutations(word)]\n    return perm in perms",
        "solution_func": "def g(word='abc'):\n    return word",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given permutation is present in all possible permutations of a given word."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate permutations of a word using itertools and check if a specific permutation is present in the generated permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5009498000144958,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    # Generate a palindrome string for testing\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_row(row):\n        return len(set(row)) == 9\n\n    def is_valid_column(board, col):\n        return len(set(board[i][col] for i in range(9))) == 9\n\n    def is_valid_square(board, row, col):\n        square = [board[r][c] for r in range(row, row + 3) for c in range(col, col + 3)]\n        return len(set(square)) == 9\n\n    for i in range(9):\n        if not is_valid_row(board[i]):\n            return False\n        if not is_valid_column(board, i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_square(board, i, j):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    # Generate a valid Sudoku board\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    # Generate a palindrome string for testing\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(s) that checks if a given string is a palindrome, and a function g() that generates a palindrome string for testing. The assertion checks if the generated palindrome string is correctly identified as a palindrome by the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6016539931297302,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(is_palindrome: bool) -> bool:\n    def is_valid_palindrome(s):\n        s = ''.join(char.lower() for char in s if char.isalnum())\n        return s == s[::-1]\n\n    return is_valid_palindrome(is_palindrome)\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(ip_addresses: List[str]) -> bool:\n    def is_valid(segment):\n        if segment[0] == '0':\n            return len(segment) == 1\n        return 0 <= int(segment) <= 255\n\n    def restore_ip_addresses(s):\n        def backtrack(start, path):\n            if len(path) == 4:\n                if start == len(s):\n                    ip_addresses.append('.'.join(path))\n                return\n            for size in range(1, 4):\n                if start + size <= len(s):\n                    segment = s[start:start + size]\n                    if is_valid(segment):\n                        backtrack(start + size, path + [segment])\n\n        ip_addresses = []\n        backtrack(0, [])\n        return ip_addresses\n\n    return restore_ip_addresses(\"25525511135\") == ip_addresses\n\ndef g():\n    return [\"255.255.11.135\", \"255.255.111.35\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(is_palindrome: bool) -> bool:\n    def is_valid_palindrome(s):\n        s = ''.join(char.lower() for char in s if char.isalnum())\n        return s == s[::-1]\n\n    return is_valid_palindrome(is_palindrome)",
        "solution_func": "def g():\n    return \"A man, a plan, a canal: Panama\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that checks if a given string is a palindrome after removing non-alphanumeric characters and ignoring case. The solution function g returns a specific string that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes, manipulating strings, and using string methods in Python. It is a good puzzle to teach students about string manipulation and palindrome checking in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4717283844947815,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    triplets = combinations(numbers, 3)\n    for triplet in triplets:\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    return [3, 4, 5, 6, 8]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6714013814926147,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and Number Theory (primes).",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(nums: list) -> bool:\n    for triplet in itertools.combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    nums = [3, 4, 5, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
            "\nfrom itertools import combinations\n\ndef f(numbers: list) -> bool:\n    triplets = combinations(numbers, 3)\n    for triplet in triplets:\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            return True\n    return False\n\ndef g():\n    return [3, 4, 5, 6, 8]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g():\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g() that returns the number 17. The puzzle tests whether the function f correctly identifies 17 as a prime number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given number is a prime number using a function f, and then testing this function with the number 17 using function g. The puzzle is suitable for teaching concepts of prime numbers and function testing in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6228509545326233,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(num_ways: int, steps=4) -> bool:\n    if steps <= 1:\n        return steps == num_ways\n    a, b = 1, 2\n    for _ in range(2, steps):\n        a, b = b, a + b\n    return b == num_ways\n\ndef g(steps=4) -> int:\n    if steps <= 1:\n        return steps\n    a, b = 1, 2\n    for _ in range(2, steps):\n        a, b = b, a + b\n    return b\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, recursion, and conditional logic.",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
            "\n\nfrom typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum\n\ndef g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(num_ways: int, steps=4) -> bool:\n    if steps <= 1:\n        return steps == num_ways\n    a, b = 1, 2\n    for _ in range(2, steps):\n        a, b = b, a + b\n    return b == num_ways",
        "solution_func": "def g(steps=4) -> int:\n    if steps <= 1:\n        return steps\n    a, b = 1, 2\n    for _ in range(2, steps):\n        a, b = b, a + b\n    return b",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(num_ways: int, steps=4) and g(steps=4), where f checks if a given number of ways can be achieved in a specific number of steps using the Fibonacci sequence, and g calculates the number of ways to reach a certain step in the Fibonacci sequence."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding Fibonacci sequence and how to check if a specific number of ways can be achieved within a certain number of steps. The solution function g calculates the number of ways to reach a specific step in the Fibonacci sequence, and the puzzle function f checks if the calculated number of ways matches the input.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.597843587398529,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport heapq\n\ndef f(shortest_path: int, graph={1: {2: 1, 3: 2}, 2: {3: 1, 4: 5}, 3: {4: 2}, 4: {}}) -> bool:\n    distances = {node: float('inf') for node in graph}\n    distances[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[len(graph)] == shortest_path\n\ndef g(graph={1: {2: 1, 3: 2}, 2: {3: 1, 4: 5}, 3: {4: 2}, 4: {}}) -> int:\n    distances = {node: float('inf') for node in graph}\n    distances[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[len(graph)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "Graph Theory (paths, edges, vertices)",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
            "\n\nfrom typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum\n\ndef g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import heapq\n\ndef f(shortest_path: int, graph={1: {2: 1, 3: 2}, 2: {3: 1, 4: 5}, 3: {4: 2}, 4: {}}) -> bool:\n    distances = {node: float('inf') for node in graph}\n    distances[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[len(graph)] == shortest_path",
        "solution_func": "def g(graph={1: {2: 1, 3: 2}, 2: {3: 1, 4: 5}, 3: {4: 2}, 4: {}}) -> int:\n    distances = {node: float('inf') for node in graph}\n    distances[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances[len(graph)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the shortest path in a graph using Dijkstra's algorithm. The puzzle function f checks if the shortest path length matches a given value, and the solution function g calculates the shortest path length."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves implementing Dijkstra's algorithm for finding the shortest path in a graph. The solution function g correctly calculates the shortest path length, and the puzzle function f checks if this length matches a given value.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.35681602358818054,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(permutations: list, elements=[1, 2, 3]) -> bool:\n    return set(permutations) == set(itertools.permutations(elements))\n\ndef g(elements=[1, 2, 3]) -> list:\n    return list(itertools.permutations(elements))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    num = random.randint(2, 100)\n    while not is_prime(num):\n        num = random.randint(2, 100)\n    return num\n\nassert f(g()) == True\n",
            "\n\nfrom typing import List\n\ndef f(max_sum: int, nums=[4, 1, 2, 8, 5]) -> bool:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude) == max_sum\n\ndef g(nums=[4, 1, 2, 8, 5]) -> int:\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(permutations: list, elements=[1, 2, 3]) -> bool:\n    return set(permutations) == set(itertools.permutations(elements))",
        "solution_func": "def g(elements=[1, 2, 3]) -> list:\n    return list(itertools.permutations(elements))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all possible permutations of a given list of elements and checking if the generated permutations match a predefined set of permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to understand how to generate permutations using itertools in Python and compare them to a predefined set of permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.498909592628479,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequences: List[List[int]]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence(subsequences[0]) == len(subsequences[0])\n\ndef g():\n    def find_subsequences(nums, index, path, subsequences):\n        if len(path) > 1:\n            subsequences.append(path[:])\n        for i in range(index, len(nums)):\n            if not path or nums[i] > path[-1]:\n                path.append(nums[i])\n                find_subsequences(nums, i + 1, path, subsequences)\n                path.pop()\n\n    nums = [1, 3, 2, 4, 7, 6]\n    subsequences = []\n    find_subsequences(nums, 0, [], subsequences)\n    return subsequences\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, Recursion",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)\n\ndef g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequences: List[List[int]]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence(subsequences[0]) == len(subsequences[0])",
        "solution_func": "def g():\n    def find_subsequences(nums, index, path, subsequences):\n        if len(path) > 1:\n            subsequences.append(path[:])\n        for i in range(index, len(nums)):\n            if not path or nums[i] > path[-1]:\n                path.append(nums[i])\n                find_subsequences(nums, i + 1, path, subsequences)\n                path.pop()\n\n    nums = [1, 3, 2, 4, 7, 6]\n    subsequences = []\n    find_subsequences(nums, 0, [], subsequences)\n    return subsequences",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest increasing subsequence in a list of numbers and checking if it matches the original list length."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of dynamic programming to find the longest increasing subsequence and recursion to generate all subsequences of a list of numbers.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.31163784861564636,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(parentheses: List[str]) -> bool:\n    def generate_parentheses(n):\n        def backtrack(s, open_count, close_count):\n            if len(s) == 2 * n:\n                parentheses.append(s)\n                return\n            if open_count < n:\n                backtrack(s + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(s + ')', open_count, close_count + 1)\n\n        parentheses = []\n        backtrack(\"\", 0, 0)\n        return parentheses\n\n    return set(generate_parentheses(2)) == set(parentheses)\n\ndef g():\n    return [\"(())\", \"()()\"]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "explanation_emb": "The puzzle involves backtracking to generate valid parentheses combinations and then comparing them using sets. It also includes the use of recursion and conditional logic.",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)\n\ndef g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(result: List[str]) -> bool:\n    def permute(s):\n        def backtrack(path, s):\n            if not s:\n                result.append(path)\n            for i in range(len(s)):\n                backtrack(path + s[i], s[:i] + s[i+1:])\n\n        result = []\n        backtrack(\"\", s)\n        return result\n\n    return set(permute(\"abc\")) == set(result)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(parentheses: List[str]) -> bool:\n    def generate_parentheses(n):\n        def backtrack(s, open_count, close_count):\n            if len(s) == 2 * n:\n                parentheses.append(s)\n                return\n            if open_count < n:\n                backtrack(s + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(s + ')', open_count, close_count + 1)\n\n        parentheses = []\n        backtrack(\"\", 0, 0)\n        return parentheses\n\n    return set(generate_parentheses(2)) == set(parentheses)",
        "solution_func": "def g():\n    return [\"(())\", \"()()\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires implementing a function that generates all possible valid combinations of parentheses for a given number n, and then checking if the generated combinations match a given list of parentheses."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves recursion and backtracking to generate all possible valid combinations of parentheses. The solution function g() returns a list of valid parentheses combinations, and the puzzle function f() checks if the generated combinations match the input list of parentheses.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.3877132833003998,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to check for palindrome, which falls under the topic of String Manipulation.",
        "idx_generation": 84,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "\nimport math\n\ndef f(factorial: int) -> bool:\n    return factorial % 10 == 0\n\ndef g(number=5) -> int:\n    return math.factorial(number)\n\nassert f(g()) == True\n",
            "\nimport math\n\ndef f(total_arrangements: int, group_size=5) -> bool:\n    return total_arrangements == math.factorial(group_size)\n\ndef g():\n    return 120  # 5!\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(palindrome: str) -> bool:\n    return palindrome == palindrome[::-1]",
        "solution_func": "def g() -> str:\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome and providing a string to test this function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6494203209877014,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid_sudoku(board):\n        def is_valid_row(board):\n            for row in board:\n                if not is_valid(row):\n                    return False\n            return True\n\n        def is_valid_column(board):\n            for col in zip(*board):\n                if not is_valid(col):\n                    return False\n            return True\n\n        def is_valid_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                    if not is_valid(box):\n                        return False\n            return True\n\n        def is_valid(nums):\n            seen = set()\n            for num in nums:\n                if num != '.':\n                    if num in seen:\n                        return False\n                    seen.add(num)\n            return True\n\n        return is_valid_row(board) and is_valid_column(board) and is_valid_box(board)\n\n    return is_valid_sudoku(board)\n\ndef g():\n    return [\n        [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n        [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n        ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n        [8, '.', '.', '.', 6, '.', '.', '.', 3],\n        [4, '.', '.', 8, '.', 3, '.', '.', 1],\n        [7, '.', '.', '.', 2, '.', '.', '.', 6],\n        ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n        ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n        ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n    ]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import combinations\n\ndef f(combination: List[int], target_sum=10) -> bool:\n    return sum(combination) == target_sum\n\ndef g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    for r in range(1, len(numbers) + 1):\n        for comb in combinations(numbers, r):\n            if sum(comb) == target_sum:\n                return list(comb)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assert statement checks if f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6713970303535461,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(card_drawn: str) -> bool:\n    def check_probability(cards, card):\n        total_cards = len(cards)\n        occurrences = cards.count(card)\n        probability = occurrences / total_cards\n        return probability > 0.1  # Checking if probability is greater than 10%\n\n    return check_probability(card_drawn, 'Ace of Spades')\n\ndef g():\n    import random\n\n    deck = ['Ace of Spades', 'King of Hearts', 'Queen of Diamonds', 'Jack of Clubs']\n    random.shuffle(deck)\n    return deck\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Probability and Statistics, Importing Modules (Itertools, etc.)",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\ndef f(segments: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n    vertices = set()\n    for seg in segments:\n        vertices.add(seg[0])\n        vertices.add(seg[1])\n    \n    adj_list = {v: [] for v in vertices}\n    for seg in segments:\n        adj_list[seg[0]].append(seg[1])\n        adj_list[seg[1]].append(seg[0])\n    \n    visited = set()\n    stack = [segments[0][0]]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return all(v in visited for v in vertices)\n\ndef g():\n    return [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)), ((0, 1), (0, 0))]\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(dice_rolls: List[int]) -> bool:\n    def is_uniform_distribution(rolls):\n        return all(roll in rolls for roll in range(1, 7))\n\n    return is_uniform_distribution(dice_rolls)\n\ndef g():\n    import random\n\n    rolls = [random.randint(1, 6) for _ in range(100)]\n    return rolls\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(card_drawn: str) -> bool:\n    def check_probability(cards, card):\n        total_cards = len(cards)\n        occurrences = cards.count(card)\n        probability = occurrences / total_cards\n        return probability > 0.1  # Checking if probability is greater than 10%\n\n    return check_probability(card_drawn, 'Ace of Spades')",
        "solution_func": "def g():\n    import random\n\n    deck = ['Ace of Spades', 'King of Hearts', 'Queen of Diamonds', 'Jack of Clubs']\n    random.shuffle(deck)\n    return deck",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that checks the probability of drawing a specific card from a shuffled deck, and a function g that shuffles a deck of cards and returns it. The goal is to determine if the probability of drawing the 'Ace of Spades' card is greater than 10% after shuffling the deck."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves probability calculations and shuffling of a deck of cards in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.573086678981781,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    # Generate a random prime number\n    num = 17\n    return num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.)",
        "idx_generation": 85,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
            "\ndef f(sequence: list) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] == sequence[i - 1] + sequence[i - 2] for i in range(2, len(sequence)))\n\ndef g() -> list:\n    fibonacci = [0, 1]\n    while len(fibonacci) < 5:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    # Generate a random prime number\n    num = 17\n    return num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(num) that checks if a given number is a prime number, and a function g() that generates a random prime number. The assertion checks if the generated number is indeed a prime number."
        ],
        "is_valid": [
            false
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers and implementing a function to check for primality. The solution function g() generates a specific prime number (17 in this case) which may not be random. This puzzle may not be suitable for teaching as it does not require the student to generate a random prime number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5638203620910645,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g() -> str:\n    # Generate a palindrome string\n    palindrome = \"radar\"\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 85,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
            "\ndef f(sequence: list) -> bool:\n    if len(sequence) < 3:\n        return False\n    return all(sequence[i] == sequence[i - 1] + sequence[i - 2] for i in range(2, len(sequence)))\n\ndef g() -> list:\n    fibonacci = [0, 1]\n    while len(fibonacci) < 5:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g() -> str:\n    # Generate a palindrome string\n    palindrome = \"radar\"\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function that checks if a given string is a palindrome, and then generate a palindrome string using another function. The assertion checks if the generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding palindrome strings and string manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5578104853630066,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(num_arrangements: int) -> bool:\n    return num_arrangements == math.factorial(5)\n\ndef g(objects=['A', 'B', 'C', 'D', 'E']) -> int:\n    return math.factorial(len(objects))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and importing modules (math). It also involves permutations and combinations.",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(dice_sum: int, threshold=3) -> bool:\n    expected_value = 3.5  # Expected value of a fair six-sided dice roll\n    return dice_sum > threshold\n\ndef g(num_rolls=100) -> int:\n    dice_sum = sum(random.randint(1, 6) for _ in range(num_rolls))\n    return dice_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(num_arrangements: int) -> bool:\n    return num_arrangements == math.factorial(5)",
        "solution_func": "def g(objects=['A', 'B', 'C', 'D', 'E']) -> int:\n    return math.factorial(len(objects))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to determine if the number of arrangements of a given set of objects is equal to the factorial of 5."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the factorial of the length of a list of objects and checking if it is equal to the factorial of 5.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5693603754043579,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(area: float) -> bool:\n    return math.isclose(area, 6.0, rel_tol=1e-9)\n\ndef g(side1=3, side2=4, side3=5) -> float:\n    s = (side1 + side2 + side3) / 2\n    area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3))\n    return area\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ],
        "explanation_emb": "Number Theory (factors, primes, etc.), Geometry and Coordinate Manipulation, Mathematical Operations, Importing Modules (Itertools, etc.)",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(dice_sum: int, threshold=3) -> bool:\n    expected_value = 3.5  # Expected value of a fair six-sided dice roll\n    return dice_sum > threshold\n\ndef g(num_rolls=100) -> int:\n    dice_sum = sum(random.randint(1, 6) for _ in range(num_rolls))\n    return dice_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(area: float) -> bool:\n    return math.isclose(area, 6.0, rel_tol=1e-9)",
        "solution_func": "def g(side1=3, side2=4, side3=5) -> float:\n    s = (side1 + side2 + side3) / 2\n    area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3))\n    return area",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the area of a triangle with sides 3, 4, and 5 is approximately equal to 6.0 using the isclose function from the math module."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of calculating the area of a triangle and using the isclose function for floating-point comparison in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5866538286209106,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(volume: float) -> bool:\n    return math.isclose(volume, 36.0 * math.pi, rel_tol=1e-9)\n\ndef g(radius=3) -> float:\n    volume = (4/3) * math.pi * math.pow(radius, 3)\n    return volume\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and importing modules (math). It also includes conditional logic to check if two values are close to each other within a specified tolerance.",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport itertools\n\ndef f(prob: float) -> bool:\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes == prob\n\ndef g():\n    outcomes = list(itertools.product(range(1, 7), repeat=2))\n    favorable_outcomes = sum(1 for outcome in outcomes if sum(outcome) == 7)\n    total_outcomes = len(outcomes)\n    return favorable_outcomes / total_outcomes\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(dice_sum: int, threshold=3) -> bool:\n    expected_value = 3.5  # Expected value of a fair six-sided dice roll\n    return dice_sum > threshold\n\ndef g(num_rolls=100) -> int:\n    dice_sum = sum(random.randint(1, 6) for _ in range(num_rolls))\n    return dice_sum\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(volume: float) -> bool:\n    return math.isclose(volume, 36.0 * math.pi, rel_tol=1e-9)",
        "solution_func": "def g(radius=3) -> float:\n    volume = (4/3) * math.pi * math.pow(radius, 3)\n    return volume",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if the volume of a sphere with a given radius is close to a specific value using a mathematical formula and a tolerance level."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the student's understanding of mathematical calculations, function composition, and the use of the math module in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6374362111091614,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())  # Removing spaces and considering only alphanumeric characters\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation is used to remove spaces and consider only alphanumeric characters. Conditional logic is used to check if the modified string is a palindrome. ",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(tree: TreeNode) -> bool:\n    def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if not node:\n            return True\n\n        if not (min_val < node.val < max_val):\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(tree)\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
            "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    def is_symmetric(left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n\n    return is_symmetric(root.left, root.right)\n\ndef g():\n    # Construct a symmetric binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())  # Removing spaces and considering only alphanumeric characters\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"A man, a plan, a canal: Panama\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f(s) that checks if a string is a palindrome after removing spaces and considering only alphanumeric characters, and a function g() that returns a specific string, determine if the string returned by g() is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a specific string is a palindrome after removing spaces and considering only alphanumeric characters. The solution function g() returns a specific string, and the puzzle function f(s) checks if this string is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.48644253611564636,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence(subsequence) == len(subsequence)\n\ndef g():\n    nums = [3, 10, 2, 1, 20]\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n    subsequence = []\n    for i in range(len(nums) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(nums[i])\n            max_length -= 1\n    subsequence.reverse()\n\n    return subsequence\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming, List Operations",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n",
            "\n\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)\n\ndef g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(subsequence: List[int]) -> bool:\n    def longest_increasing_subsequence(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence(subsequence) == len(subsequence)",
        "solution_func": "def g():\n    nums = [3, 10, 2, 1, 20]\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n    subsequence = []\n    for i in range(len(nums) - 1, -1, -1):\n        if dp[i] == max_length:\n            subsequence.append(nums[i])\n            max_length -= 1\n    subsequence.reverse()\n\n    return subsequence",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest increasing subsequence in a given list of integers and checking if the length of the subsequence is equal to the length of the original list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding dynamic programming to find the longest increasing subsequence and comparing its length with the length of the original list.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.30956733226776123,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(unique_paths: int) -> bool:\n    def count_unique_paths(m, n):\n        dp = [[1] * n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    return count_unique_paths(3, 3) == unique_paths\n\ndef g():\n    m, n = 3, 3\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves dynamic programming to solve the unique paths problem. It also includes recursion in the form of a nested function. Additionally, it requires knowledge of conditional logic and mathematical operations to implement the algorithm correctly.",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(result: List[List[int]]) -> bool:\n    def permute(nums):\n        def backtrack(path, nums):\n            if not nums:\n                result.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i + 1:])\n\n        result = []\n        backtrack([], nums)\n        return result\n\n    return permute([1, 2, 3]) == result\n\ndef g():\n    return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\nassert f(g()) == True\n",
            "\n\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    def is_valid_coin_change(coins, amount):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n\n    return all(is_valid_coin_change(comb, sum(comb)) for comb in combinations)\n\ndef g(coins=[1, 2, 5], amount=5):\n    def backtrack(start, path, total):\n        if total == amount:\n            combinations.append(path.copy())\n            return\n        if total > amount:\n            return\n\n        for i in range(start, len(coins)):\n            path.append(coins[i])\n            backtrack(i, path, total + coins[i])\n            path.pop()\n\n    combinations = []\n    backtrack(0, [], 0)\n    return combinations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(unique_paths: int) -> bool:\n    def count_unique_paths(m, n):\n        dp = [[1] * n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    return count_unique_paths(3, 3) == unique_paths",
        "solution_func": "def g():\n    m, n = 3, 3\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the output of a function g matches a specific condition related to counting unique paths in a grid."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle tests the understanding of nested functions, dynamic programming, and function composition in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5233693718910217,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g(index=5):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = [num for num in range(2, index**2) if is_prime(num)]\n    return prime_numbers[index]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves topics related to prime numbers, mathematical operations, loops, and functions.",
        "idx_generation": 86,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(combinations: List[List[int]], target_combination=[1, 2]) -> bool:\n    return target_combination in combinations\n\ndef g(target_combination=[1, 2]):\n    items = [1, 2, 3]\n    return [list(combination) for r in range(1, len(items) + 1) for combination in itertools.combinations(items, r)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g(index=5):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = [num for num in range(2, index**2) if is_prime(num)]\n    return prime_numbers[index]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f(number) that checks if a given number is a prime number, and a function g(index) that returns the prime number at the specified index in a list of prime numbers up to index^2. The puzzle requires students to understand prime numbers and function composition in Python."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a common programming concept of checking for prime numbers and using list comprehension to generate a list of prime numbers. It also requires understanding function composition and how to assert the correctness of the solution.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4241383373737335,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(string: str) -> bool:\n    return string == string[::-1]\n\ndef g(length=5):\n    palindromes = [str(num) + str(num)[::-1] for num in range(10**(length-1), 10**length)]\n    return palindromes[0]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 86,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom itertools import product\n\ndef f(matrix: list[list[int]]) -> bool:\n    return all(matrix[i][j] == matrix[j][i] for i, j in product(range(len(matrix)), repeat=2))\n\ndef g(size=3):\n    symmetric_matrix = [[i+j for j in range(size)] for i in range(size)]\n    return symmetric_matrix\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nimport itertools\n\ndef f(combinations: List[List[int]], target_combination=[1, 2]) -> bool:\n    return target_combination in combinations\n\ndef g(target_combination=[1, 2]):\n    items = [1, 2, 3]\n    return [list(combination) for r in range(1, len(items) + 1) for combination in itertools.combinations(items, r)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(string: str) -> bool:\n    return string == string[::-1]",
        "solution_func": "def g(length=5):\n    palindromes = [str(num) + str(num)[::-1] for num in range(10**(length-1), 10**length)]\n    return palindromes[0]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a generated palindrome string is indeed a palindrome by comparing it to its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome and generating a palindrome string using a specific algorithm. The solution function generates a palindrome string and the puzzle function checks if it is a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5057332515716553,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(moves: list) -> bool:\n    def is_valid_move(move):\n        return move[0] == 0 or move[1] == 0\n\n    current_position = (0, 0)\n    for move in moves:\n        new_position = (current_position[0] + move[0], current_position[1] + move[1])\n        if not is_valid_move(move) or new_position[0] < 0 or new_position[1] < 0:\n            return False\n        current_position = new_position\n\n    return True\n\ndef g(board_size=8):\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    return moves\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves conditional logic and geometry and coordinate manipulation.",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "def f(moves: list) -> bool:\n    def is_valid_move(move):\n        return move[0] == 0 or move[1] == 0\n\n    current_position = (0, 0)\n    for move in moves:\n        new_position = (current_position[0] + move[0], current_position[1] + move[1])\n        if not is_valid_move(move) or new_position[0] < 0 or new_position[1] < 0:\n            return False\n        current_position = new_position\n\n    return True",
        "solution_func": "def g(board_size=8):\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    return moves",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of moves as input and checks if the moves are valid to stay within a board of given size. The solution function g generates a list of moves to navigate within an 8x8 board."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking the validity of moves within a board and ensuring the position stays within bounds. The solution function generates a list of moves to navigate within the board.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.48671799898147583,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g():\n    return \"radar\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f(s) that returns True if the input string is a palindrome, and a function g() that returns the string 'radar'. The assertion checks if the function f(g()) returns True.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 4,
        "yes_finetuning_deepseek-1.3b": 0.6713919639587402,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(maze: list) -> bool:\n    def is_valid_move(maze, row, col):\n        return 0 <= row < len(maze) and 0 <= col < len(maze[0]) and maze[row][col] == 1\n\n    def solve_maze_util(maze, row, col):\n        if row == len(maze) - 1 and col == len(maze[0]) - 1:\n            return True\n\n        if is_valid_move(maze, row, col):\n            maze[row][col] = 0\n            if solve_maze_util(maze, row + 1, col) or solve_maze_util(maze, row, col + 1):\n                return True\n            maze[row][col] = 1\n\n        return False\n\n    return solve_maze_util(maze, 0, 0)\n\ndef g():\n    maze = [[1, 0, 1, 1],\n            [1, 1, 1, 0],\n            [0, 1, 1, 1],\n            [1, 0, 1, 1]]\n    return maze\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Backtracking",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True"
        ],
        "problem_func": "def f(maze: list) -> bool:\n    def is_valid_move(maze, row, col):\n        return 0 <= row < len(maze) and 0 <= col < len(maze[0]) and maze[row][col] == 1\n\n    def solve_maze_util(maze, row, col):\n        if row == len(maze) - 1 and col == len(maze[0]) - 1:\n            return True\n\n        if is_valid_move(maze, row, col):\n            maze[row][col] = 0\n            if solve_maze_util(maze, row + 1, col) or solve_maze_util(maze, row, col + 1):\n                return True\n            maze[row][col] = 1\n\n        return False\n\n    return solve_maze_util(maze, 0, 0)",
        "solution_func": "def g():\n    maze = [[1, 0, 1, 1],\n            [1, 1, 1, 0],\n            [0, 1, 1, 1],\n            [1, 0, 1, 1]]\n    return maze",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves a function f that takes a maze represented as a list of lists and checks if there is a valid path from the top-left corner to the bottom-right corner by moving only to adjacent cells with a value of 1. The solution function g generates a specific maze and checks if the function f correctly identifies a valid path in that maze."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves solving a maze traversal problem using recursion and backtracking. It tests the student's understanding of recursion, conditional statements, and list manipulation in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4011342525482178,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(numbers: list) -> bool:\n    ratio = numbers[1] / numbers[0]\n    return all(numbers[i] / numbers[i - 1] == ratio for i in range(2, len(numbers)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    ratio = random.randint(2, 5)\n    return [start * ratio**i for i in range(4)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, List Operations, and Random Number Generation.",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g() -> str:\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    word = ''.join(random.choice(letters) for _ in range(5))\n    return word + word[::-1]\n\nassert f(g()) == True\n",
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(numbers: list) -> bool:\n    ratio = numbers[1] / numbers[0]\n    return all(numbers[i] / numbers[i - 1] == ratio for i in range(2, len(numbers)))",
        "solution_func": "def g() -> list:\n    import random\n    start = random.randint(1, 10)\n    ratio = random.randint(2, 5)\n    return [start * ratio**i for i in range(4)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement two functions: f(numbers) checks if the input list follows a geometric progression, and g() generates a list of numbers in a geometric progression. The assert statement at the end checks if the generated list satisfies the condition of f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding geometric progressions and implementing a function to check if a list of numbers forms a geometric progression. The solution function g() generates a list of numbers in a geometric progression to test the condition in f().",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.4877595007419586,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(nums: list) -> bool:\n    return nums == nums[::-1]\n\ndef g() -> list:\n    import random\n    nums = random.sample(range(1, 10), 4)\n    return nums + nums[::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 86,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(nums: list) -> bool:\n    diff = nums[1] - nums[0]\n    return all(nums[i] - nums[i - 1] == diff for i in range(2, len(nums)))\n\ndef g() -> list:\n    import random\n    start = random.randint(1, 10)\n    diff = random.randint(1, 10)\n    return [start + i * diff for i in range(5)]\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return nums[n // 2] == (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2] == nums[n // 2]\n\ndef g() -> List[int]:\n    import random\n\n    numbers = random.sample(range(1, 100), 5)\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(nums: list) -> bool:\n    return nums == nums[::-1]",
        "solution_func": "def g() -> list:\n    import random\n    nums = random.sample(range(1, 10), 4)\n    return nums + nums[::-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a list generated by a function is equal to its reverse, and the solution generates a list of 4 random numbers and appends its reverse to it."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a list is equal to its reverse, which tests the student's understanding of list manipulation in Python. The solution generates a list of random numbers and appends its reverse to it to satisfy the condition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5352482199668884,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return nums == nums[::-1]\n\ndef g(length=5):\n    palindrome = list(range(1, length + 1)) + list(range(length, 0, -1))\n    return palindrome\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking if a list of numbers is a palindrome or not by comparing it with its reverse. The solution generates a palindrome list of numbers based on a given length.",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(length: int) -> bool:\n    return length == 4\n\ndef g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    return nums == nums[::-1]",
        "solution_func": "def g(length=5):\n    palindrome = list(range(1, length + 1)) + list(range(length, 0, -1))\n    return palindrome",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a list of numbers generated by the function g is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a list of numbers in a specific pattern and checking if it is a palindrome using the function f.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49946069717407227,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(s: str) -> bool:\n    return s == s[::-1]\n\ndef g(input_str=\"pythonrocks\"):\n    palindrome_str = input_str + input_str[::-1]\n    return palindrome_str\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    return words == sorted(words)\n\ndef g():\n    import random\n\n    words = ['apple', 'banana', 'cherry', 'date', 'grape']\n    random.shuffle(words)  # Shuffle the list of words\n    return sorted(words)\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(length: int) -> bool:\n    return length == 4\n\ndef g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    return s == s[::-1]",
        "solution_func": "def g(input_str=\"pythonrocks\"):\n    palindrome_str = input_str + input_str[::-1]\n    return palindrome_str",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a given string is a palindrome by comparing it with its reverse."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a string is a palindrome and another function that generates a palindrome string based on the input. The assertion at the end verifies if the generated palindrome string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 5,
        "yes_finetuning_deepseek-1.3b": 0.5648497343063354,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g(length=5) -> str:\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    left_half = ''.join(random.choice(letters) for _ in range(half_length))\n    right_half = left_half[::-1] if length % 2 == 0 else left_half[:-1][::-1]\n    return left_half + right_half\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g(length=5) -> str:\n    import random\n    import string\n\n    letters = string.ascii_lowercase\n    half_length = length // 2\n    left_half = ''.join(random.choice(letters) for _ in range(half_length))\n    right_half = left_half[::-1] if length % 2 == 0 else left_half[:-1][::-1]\n    return left_half + right_half",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated string is a palindrome or not."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle consists of two functions, f(word: str) -> bool which checks if a given word is a palindrome, and g(length=5) -> str which generates a random string and checks if it is a palindrome using f. The assert statement at the end ensures that the generated string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.42385154962539673,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) == len(set(nums))\n\ndef g(length=6) -> List[int]:\n    import random\n\n    return random.sample(range(1, length * 2), length)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations to check for uniqueness of elements in a list.",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g():\n    import random\n\n    n = random.randint(5, 10)\n    permutation = random.sample(range(1, n+1), n)\n    return permutation\n\nassert f(g()) == True\n",
            "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[List[int]]) -> bool:\n    return set(tuple(perm) for perm in permutations_list) == {(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)}\n\ndef g(nums=[1, 2, 3]) -> List[List[int]]:\n    return list(permutations(nums))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(nums: List[int]) -> bool:\n    return len(nums) == len(set(nums))",
        "solution_func": "def g(length=6) -> List[int]:\n    import random\n\n    return random.sample(range(1, length * 2), length)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to generate a list of random numbers and check if there are any duplicates in the list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves generating a list of random numbers and checking if there are any duplicates in the list using a function f(nums) that returns True if there are no duplicates. The solution function g(length) generates a list of random numbers of a specified length.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5027062892913818,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Number theory is used in the puzzle to check if a number is prime or not.",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10\n\ndef g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]\n\nassert f(g()) == True\n",
            "\ndef f(moves: list) -> bool:\n    def is_valid_move(move):\n        return move[0] == 0 or move[1] == 0\n\n    current_position = (0, 0)\n    for move in moves:\n        new_position = (current_position[0] + move[0], current_position[1] + move[1])\n        if not is_valid_move(move) or new_position[0] < 0 or new_position[1] < 0:\n            return False\n        current_position = new_position\n\n    return True\n\ndef g(board_size=8):\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    return moves\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True",
        "solution_func": "def g() -> int:\n    return 17",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves two functions, f(number: int) -> bool and g() -> int. Function f checks if a given number is a prime number, while function g always returns the number 17. The puzzle asserts that f(g()) should return True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a specific number (17 in this case) is a prime number. The solution function g always returns the number 17, which is a prime number. Therefore, the puzzle is valid and can be used to teach Python programming concepts related to prime numbers and function composition.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6431896686553955,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    if result == 8:\n        return True\n    else:\n        return False\n\ndef g(n=6):\n    if n <= 1:\n        return n\n    else:\n        return g(n - 1) + g(n - 2)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations.",
        "idx_generation": 87,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int) -> bool:\n    if result == 120:\n        return True\n    else:\n        return False\n\ndef g(number=5):\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    if result == 8:\n        return True\n    else:\n        return False",
        "solution_func": "def g(n=6):\n    if n <= 1:\n        return n\n    else:\n        return g(n - 1) + g(n - 2)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires students to implement a recursive function to calculate the Fibonacci sequence and check if the result is equal to 8."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and the Fibonacci sequence to calculate the result. The solution should return the nth Fibonacci number and check if it equals 8.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.642147958278656,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return combination[0] * combination[1] * combination[2] == 24\n\ndef g():\n    nums = [1, 2, 3, 4, 6, 8]\n    for comb in itertools.combinations(nums, 3):\n        if comb[0] * comb[1] * comb[2] == 24:\n            return comb\n\nassert f(g()) == True\n",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Importing Modules (Itertools, etc.), Mathematical Operations",
        "idx_generation": 87,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int) -> bool:\n    if result == 120:\n        return True\n    else:\n        return False\n\ndef g(number=5):\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import itertools\n\ndef f(combination: tuple) -> bool:\n    return combination[0] * combination[1] * combination[2] == 24",
        "solution_func": "def g():\n    nums = [1, 2, 3, 4, 6, 8]\n    for comb in itertools.combinations(nums, 3):\n        if comb[0] * comb[1] * comb[2] == 24:\n            return comb",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding a combination of 3 numbers from a given list such that their product is equal to 24."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves using itertools to generate combinations of 3 numbers from a list and checking if their product is equal to 24.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.5394552946090698,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int) -> bool:\n    if result == 55:\n        return True\n    else:\n        return False\n\ndef g():\n    return sum([i**2 for i in range(1, 6)])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "idx_generation": 87,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(result: int) -> bool:\n    if result == 120:\n        return True\n    else:\n        return False\n\ndef g(number=5):\n    if number == 0:\n        return 1\n    else:\n        return number * g(number - 1)\n\nassert f(g()) == True\n",
            "\nimport itertools\n\ndef f(combination: tuple) -> bool:\n    return sum(combination) == 10\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    for r in range(1, len(nums)+1):\n        for comb in itertools.combinations(nums, r):\n            if sum(comb) == 10:\n                return comb\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int) -> bool:\n    if result == 55:\n        return True\n    else:\n        return False",
        "solution_func": "def g():\n    return sum([i**2 for i in range(1, 6)])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to write a function that calculates the sum of squares of numbers from 1 to 5, and then check if the result is equal to 55."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic understanding of list comprehension and function return values in Python. It tests the student's ability to write a function that performs a specific calculation and then check if the result meets a certain condition.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6669120192527771,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(max_product: int) -> bool:\n    return max_product == 63\n\ndef g(numbers=[1, 7, 3, 9, 4, 3, 2]) -> int:\n    numbers.sort()\n    return max(numbers[-1] * numbers[-2], numbers[0] * numbers[1])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and sorting and ordering topics.",
        "idx_generation": 87,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(sorted_list: list) -> bool:\n    return sorted_list == [0, 1, 2, 4, 8, 3, 5, 6, 9, 10]\n\ndef g(numbers=[1, 2, 3, 4, 5, 6, 8, 9, 10, 0]) -> list:\n    return sorted(numbers, key=lambda x: bin(x).count('1'))\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(target_value: int, sequence_length=100) -> bool:\n    random.seed(1)\n    sequence = [random.randint(1, 100) for _ in range(sequence_length)]\n    sorted_sequence = sorted(sequence)\n    median_index = len(sorted_sequence) // 2\n    median_value = sorted_sequence[median_index]\n    return abs(median_value - target_value) < 10\n\ndef g():\n    return 50\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(max_product: int) -> bool:\n    return max_product == 63",
        "solution_func": "def g(numbers=[1, 7, 3, 9, 4, 3, 2]) -> int:\n    numbers.sort()\n    return max(numbers[-1] * numbers[-2], numbers[0] * numbers[1])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires finding the maximum product of two numbers in a list and checking if it equals 63."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of numbers, finding the maximum product of two numbers in the list, and checking if it equals 63.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.6357040405273438,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]",
        "solution_func": "def g(s=\"A man, a plan, a canal: Panama\"):\n    return s",
        "quality": [
            null
        ],
        "description": [
            "Given a string, the puzzle checks if the string is a palindrome after removing non-alphanumeric characters and ignoring case."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking if a given string is a palindrome after removing non-alphanumeric characters and ignoring case. The solution function returns the given string, and the puzzle function checks if the string is a palindrome after processing it.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.5019134879112244,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != '.']\n        return len(set(arr)) == len(arr)\n\n    for i in range(9):\n        if not is_valid(board[i]) or not is_valid([board[j][i] for j in range(9)]):\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if not is_valid([board[m][n] for n in range(3*j, 3*(j+1)) for m in range(3*i, 3*(i+1))]):\n                return False\n\n    return True\n\ndef g(board=[\n    [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n    [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n    ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n    [8, '.', '.', '.', 6, '.', '.', '.', 3],\n    [4, '.', '.', 8, '.', 3, '.', '.', 1],\n    [7, '.', '.', '.', 2, '.', '.', '.', 6],\n    ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n    ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n    ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n]):\n    return board\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Sudoku validation, which includes elements of backtracking and set operations.",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutation: List[int]) -> bool:\n    n = len(permutation)\n    return set(permutation) == set(range(1, n+1)) and all(abs(permutation[i] - permutation[i-1]) > 1 for i in range(1, n))\n\ndef g(n=5):\n    def backtrack(nums, path):\n        if len(path) == n:\n            return path\n        for num in nums:\n            if not path or abs(num - path[-1]) > 1:\n                new_path = path + [num]\n                new_nums = nums.copy()\n                new_nums.remove(num)\n                res = backtrack(new_nums, new_path)\n                if res:\n                    return res\n        return None\n\n    return backtrack(list(range(1, n+1)), [])\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != '.']\n        return len(set(arr)) == len(arr)\n\n    for i in range(9):\n        if not is_valid(board[i]) or not is_valid([board[j][i] for j in range(9)]):\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if not is_valid([board[m][n] for n in range(3*j, 3*(j+1)) for m in range(3*i, 3*(i+1))]):\n                return False\n\n    return True",
        "solution_func": "def g(board=[\n    [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n    [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n    ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n    [8, '.', '.', '.', 6, '.', '.', '.', 3],\n    [4, '.', '.', 8, '.', 3, '.', '.', 1],\n    [7, '.', '.', '.', 2, '.', '.', '.', 6],\n    ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n    ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n    ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n]):\n    return board",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking the validity of a Sudoku board represented as a 9x9 grid."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle function f(board) checks if the given Sudoku board is valid according to the rules of Sudoku. The solution function g(board) provides a sample Sudoku board to be checked for validity.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.43958529829978943,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport math\n\ndef f(target_sum: float, numbers=[1, 2, 3, 4]) -> bool:\n    sum_of_sqrts = sum(math.sqrt(num) for num in numbers)\n    return sum_of_sqrts == target_sum\n\ndef g(numbers=[1, 2, 3, 4]) -> float:\n    return sum(math.sqrt(num) for num in numbers)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Importing Modules (Itertools, etc.), and Assertion Testing.",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nimport math\nimport random\n\ndef f(factorial: int, n=5) -> bool:\n    return math.factorial(n) == factorial\n\ndef g(n=5) -> int:\n    return math.factorial(n)\n\nassert f(g()) == True\n",
            "\ndef f(length: int) -> bool:\n    target_length = 4\n    return length == target_length\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import math\n\ndef f(target_sum: float, numbers=[1, 2, 3, 4]) -> bool:\n    sum_of_sqrts = sum(math.sqrt(num) for num in numbers)\n    return sum_of_sqrts == target_sum",
        "solution_func": "def g(numbers=[1, 2, 3, 4]) -> float:\n    return sum(math.sqrt(num) for num in numbers)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves calculating the sum of square roots of a list of numbers and checking if it equals a target sum."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of list comprehension, mathematical operations, and function calls in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5924575328826904,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    def is_convex(points):\n        def cross_product(p1, p2, p3):\n            return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n        n = len(points)\n        if n < 3:\n            return False\n\n        sign = None\n        for i in range(n):\n            p1, p2, p3 = points[i], points[(i + 1) % n], points[(i + 2) % n]\n            current_sign = cross_product(p1, p2, p3)\n            if current_sign != 0:\n                if sign is None:\n                    sign = current_sign\n                elif sign != current_sign:\n                    return False\n        return True\n\n    return is_convex(points)\n\ndef g(num_points=4):\n    return [(i, i) for i in range(num_points)]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to determine if a given set of points forms a convex polygon.",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    def is_convex(points):\n        def cross_product(p1, p2, p3):\n            return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n        n = len(points)\n        if n < 3:\n            return False\n\n        sign = None\n        for i in range(n):\n            p1, p2, p3 = points[i], points[(i + 1) % n], points[(i + 2) % n]\n            current_sign = cross_product(p1, p2, p3)\n            if current_sign != 0:\n                if sign is None:\n                    sign = current_sign\n                elif sign != current_sign:\n                    return False\n        return True\n\n    return is_convex(points)",
        "solution_func": "def g(num_points=4):\n    return [(i, i) for i in range(num_points)]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves checking if a given set of points forms a convex polygon or not using cross product calculations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of nested functions, cross product calculation, and convex polygon properties in order to determine if a set of points forms a convex polygon.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.33319681882858276,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    return sorted(combinations) == [[0, 1], [0, 2], [1, 2]]\n\ndef g(nums=[0, 1, 2]):\n    def generate_combinations(k, start, path, result):\n        if k == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            generate_combinations(k - 1, i + 1, path, result)\n            path.pop()\n\n    combinations = []\n    generate_combinations(2, 0, [], combinations)\n    return combinations\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Sorting and Ordering",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    return sorted(permutations) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\ndef g(nums=[1, 2, 3]):\n    def backtrack(perm, nums, result):\n        if not nums:\n            result.append(perm)\n            return\n        for i in range(len(nums)):\n            backtrack(perm + [nums[i]], nums[:i] + nums[i+1:], result)\n    \n    permutations = []\n    backtrack([], nums, permutations)\n    return permutations\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(permutations: List[List[int]]) -> bool:\n    def is_valid_permutation(perm):\n        return all(perm.count(num) == perm.count(num) for num in perm)\n\n    return all(is_valid_permutation(perm) for perm in permutations)\n\ndef g(nums=[1, 2, 2]):\n    def backtrack(perm, path):\n        if not perm:\n            path.append(path[:])\n            return\n        for i in range(len(perm)):\n            if i > 0 and perm[i] == perm[i - 1]:\n                continue\n            backtrack(perm[:i] + perm[i+1:], path + [perm[i]])\n\n    permutations = []\n    nums.sort()\n    backtrack(nums, permutations)\n    return permutations\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(combinations: List[List[int]]) -> bool:\n    return sorted(combinations) == [[0, 1], [0, 2], [1, 2]]",
        "solution_func": "def g(nums=[0, 1, 2]):\n    def generate_combinations(k, start, path, result):\n        if k == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            generate_combinations(k - 1, i + 1, path, result)\n            path.pop()\n\n    combinations = []\n    generate_combinations(2, 0, [], combinations)\n    return combinations",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating combinations of elements from a given list and checking if the generated combinations match a specific pattern."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires generating all possible combinations of 2 elements from a list of [0, 1, 2] and checking if the generated combinations match the pattern [[0, 1], [0, 2], [1, 2]].",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.37565433979034424,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(result: int, n=5) -> bool:\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    return result == fibonacci_recursive(n)\n\ndef g(n=5):\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    return fibonacci_recursive(n)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion and mathematical operations (specifically, Fibonacci sequence).",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(result: int, n=5) -> bool:\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    return result == fibonacci_recursive(n)",
        "solution_func": "def g(n=5):\n    def fibonacci_recursive(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    return fibonacci_recursive(n)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the result of a given function g matches the result of a recursive Fibonacci function for a given input n. The solution function g calculates the Fibonacci sequence recursively for a given input n."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding recursion and function calls in Python, specifically related to calculating the Fibonacci sequence. It tests the student's ability to define functions and compare their results.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.5470888614654541,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sum_primes: int, n=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum_primes_calculated = sum([num for num in range(2, n+1) if is_prime(num)])\n    return sum_primes == sum_primes_calculated\n\ndef g(n=10):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return sum([num for num in range(2, n+1) if is_prime(num)])\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to prime numbers, loops, and function composition.",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
            "\nimport sys\n\ndef f(max_product: int, nums=[-2, 3, -4, 6]) -> bool:\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global == max_product\n\ndef g(nums=[-2, 3, -4, 6]):\n    max_product_so_far = nums[0]\n    min_product_so_far = nums[0]\n    max_product_global = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n\n        max_product_so_far = max(num, max_product_so_far * num)\n        min_product_so_far = min(num, min_product_so_far * num)\n\n        max_product_global = max(max_product_global, max_product_so_far)\n\n    return max_product_global\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sum_primes: int, n=10) -> bool:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum_primes_calculated = sum([num for num in range(2, n+1) if is_prime(num)])\n    return sum_primes == sum_primes_calculated",
        "solution_func": "def g(n=10):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return sum([num for num in range(2, n+1) if is_prime(num)])",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where the first function checks if the sum of prime numbers up to a given limit is equal to a specified sum, and the second function calculates the sum of prime numbers up to a given limit. The solution function is then used to verify the correctness of the algorithm by checking if the output of the solution function satisfies the condition of the first function."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding prime numbers, sum calculation, function definitions, and function composition in Python. It provides a practical exercise in implementing and testing algorithms related to prime numbers and sums.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.44345444440841675,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(strings: List[str]) -> bool:\n    for string in strings:\n        if string == string[::-1]:\n            return True\n    return False\n\ndef g() -> List[str]:\n    return [\"level\", \"python\", \"radar\"]  # Example list with palindrome strings\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(strings: List[str]) -> bool:\n    for string in strings:\n        if string == string[::-1]:\n            return True\n    return False",
        "solution_func": "def g() -> List[str]:\n    return [\"level\", \"python\", \"radar\"]  # Example list with palindrome strings",
        "quality": [
            null
        ],
        "description": [
            "Given a list of strings, the puzzle function f checks if any of the strings in the list is a palindrome. The solution function g returns a list of example palindrome strings."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for palindromes in a list of strings, which is a common programming concept. The solution provides a list of example palindrome strings to test the puzzle function.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.4749511480331421,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=15) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(numbers):\n            return False\n        return subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]) or subset_sum(numbers, target_sum, index + 1, current_sum)\n\n    return subset_sum(numbers, target_sum, 0, 0)\n\ndef g() -> List[int]:\n    return [3, 7, 5]  # Subset that sums up to the target value\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves recursion, backtracking, and conditional logic to solve the subset sum problem.",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(numbers: List[int], target_sum=15) -> bool:\n    def subset_sum(numbers, target_sum, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(numbers):\n            return False\n        return subset_sum(numbers, target_sum, index + 1, current_sum + numbers[index]) or subset_sum(numbers, target_sum, index + 1, current_sum)\n\n    return subset_sum(numbers, target_sum, 0, 0)",
        "solution_func": "def g() -> List[int]:\n    return [3, 7, 5]  # Subset that sums up to the target value",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a subset of numbers from a list that sums up to a target value using recursion."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of recursion and how to find subsets that sum up to a target value in a list of numbers.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.44448211789131165,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List, Set\n\ndef f(sets: List[Set[int]]) -> bool:\n    seen_elements = set()\n    for set_ in sets:\n        for element in set_:\n            if element in seen_elements:\n                return True\n            seen_elements.add(element)\n    return False\n\ndef g() -> List[Set[int]]:\n    return [{1, 2, 3}, {3, 4, 5}, {6, 7, 8}]  # Example list with sets containing a common element\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and conditional logic.",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(target=10) -> List[int]:\n    return [2, target - 2]  # Example pair that sums up to the target value\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(num_list: List[int], target_sum=10) -> bool:\n    seen = set()\n    for num in num_list:\n        if target_sum - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(num_list=[2, 4, 6, 8]):\n    return num_list\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List, Set\n\ndef f(sets: List[Set[int]]) -> bool:\n    seen_elements = set()\n    for set_ in sets:\n        for element in set_:\n            if element in seen_elements:\n                return True\n            seen_elements.add(element)\n    return False",
        "solution_func": "def g() -> List[Set[int]]:\n    return [{1, 2, 3}, {3, 4, 5}, {6, 7, 8}]  # Example list with sets containing a common element",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires defining a function f that takes a list of sets of integers and checks if there is a common element in any of the sets. The solution function g returns a list of sets with a common element to test the function f."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves checking for common elements in sets, which is a common programming concept. It also requires understanding of sets and list manipulation in Python.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.48900842666625977,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport sys\n\ndef f(target_sum: int, nums=[-5, 2, 10, 8, -3]) -> bool:\n    if not nums:\n        return False\n    min_num = sys.maxsize\n    max_num = -sys.maxsize\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n    return min_num + max_num == target_sum\n\ndef g(nums=[-5, 2, 10, 8, -3]) -> int:\n    if not nums:\n        return 0\n    min_num = sys.maxsize\n    max_num = -sys.maxsize\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n    return min_num + max_num\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Conditional Logic, and Importing Modules (Itertools, etc.)",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(max_product: int, nums=[-2, 3, -4, 5, -6]) -> bool:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result == max_product\n\ndef g(nums=[-2, 3, -4, 5, -6]) -> int:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result\n\nassert f(g()) == True\n",
            "\ndef f(unique_paths: int) -> bool:\n    def count_unique_paths(m, n):\n        dp = [[1] * n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    return count_unique_paths(3, 3) == unique_paths\n\ndef g():\n    m, n = 3, 3\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import sys\n\ndef f(target_sum: int, nums=[-5, 2, 10, 8, -3]) -> bool:\n    if not nums:\n        return False\n    min_num = sys.maxsize\n    max_num = -sys.maxsize\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n    return min_num + max_num == target_sum",
        "solution_func": "def g(nums=[-5, 2, 10, 8, -3]) -> int:\n    if not nums:\n        return 0\n    min_num = sys.maxsize\n    max_num = -sys.maxsize\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n    return min_num + max_num",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python, where function f checks if the sum of the minimum and maximum numbers in a list equals a target sum, and function g calculates the sum of the minimum and maximum numbers in a list. The assertion at the end checks if function f returns True when called with the result of function g."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves basic list manipulation and comparison operations in Python, making it suitable for teaching Python programming concepts such as loops, conditionals, and function calls.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43737170100212097,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(longest_subsequence_length: int) -> bool:\n    def length_of_LIS(nums):\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    return length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == longest_subsequence_length\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Dynamic Programming",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\n\ndef f(max_product: int, nums=[-2, 3, -4, 5, -6]) -> bool:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result == max_product\n\ndef g(nums=[-2, 3, -4, 5, -6]) -> int:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result\n\nassert f(g()) == True\n",
            "\ndef f(unique_paths: int) -> bool:\n    def count_unique_paths(m, n):\n        dp = [[1] * n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    return count_unique_paths(3, 3) == unique_paths\n\ndef g():\n    m, n = 3, 3\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(longest_subsequence_length: int) -> bool:\n    def length_of_LIS(nums):\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    return length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == longest_subsequence_length",
        "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that checks if the length of the longest increasing subsequence in a given list matches a specified length. The solution function g calculates the length of the longest increasing subsequence in a specific list and checks if it matches the specified length."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding dynamic programming concepts and implementing a solution to find the length of the longest increasing subsequence in a list. It tests the student's ability to define functions, work with lists, and compare results for correctness.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.3816203773021698,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(word: str) -> bool:\n    return word == word[::-1]\n\ndef g(length=5):\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        palindrome_half = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[:-1][::-1])\n        return palindrome\n\n    return generate_palindrome(length)\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation to generate palindromes and check if a word is a palindrome.",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(number: int) -> bool:\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef g():\n    import random\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime = random.randint(2, 100)\n    while not is_prime(prime):\n        prime = random.randint(2, 100)\n\n    return prime\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(coins_used: List[int], target_amount=11) -> bool:\n    return sum(coins_used) == target_amount\n\ndef g(coin_denominations=[1, 3, 5, 7]):\n    target_amount = 11\n    coin_denominations.sort(reverse=True)\n    coins_used = []\n\n    amount_left = target_amount\n    for coin in coin_denominations:\n        while amount_left >= coin:\n            coins_used.append(coin)\n            amount_left -= coin\n\n    return coins_used\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(word: str) -> bool:\n    return word == word[::-1]",
        "solution_func": "def g(length=5):\n    import random\n    import string\n\n    def generate_palindrome(length):\n        half_length = length // 2\n        palindrome_half = ''.join(random.choices(string.ascii_lowercase, k=half_length))\n        palindrome = palindrome_half + (palindrome_half[::-1] if length % 2 == 0 else palindrome_half[:-1][::-1])\n        return palindrome\n\n    return generate_palindrome(length)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if a randomly generated palindrome string is indeed a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves defining a function to check if a given word is a palindrome and another function to generate a palindrome string. The assertion at the end verifies if the generated palindrome string is indeed a palindrome.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.42131879925727844,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(lcs: str, str1=\"ABAZDC\", str2=\"BACBAD\") -> bool:\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n\n    return longest_common_subsequence(str1, str2) == len(lcs)\n\ndef g(str1=\"ABAZDC\", str2=\"BACBAD\"):\n    return \"ABAD\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Dynamic Programming",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "\n\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != '.']\n        return len(set(arr)) == len(arr)\n\n    for i in range(9):\n        if not is_valid(board[i]) or not is_valid([board[j][i] for j in range(9)]):\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if not is_valid([board[m][n] for n in range(3*j, 3*(j+1)) for m in range(3*i, 3*(i+1))]):\n                return False\n\n    return True\n\ndef g(board=[\n    [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n    [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n    ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n    [8, '.', '.', '.', 6, '.', '.', '.', 3],\n    [4, '.', '.', 8, '.', 3, '.', '.', 1],\n    [7, '.', '.', '.', 2, '.', '.', '.', 6],\n    ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n    ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n    ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(lcs: str, str1=\"ABAZDC\", str2=\"BACBAD\") -> bool:\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n\n    return longest_common_subsequence(str1, str2) == len(lcs)",
        "solution_func": "def g(str1=\"ABAZDC\", str2=\"BACBAD\"):\n    return \"ABAD\"",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the longest common subsequence between two strings and checking if it matches a given input string."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle defines a function f that calculates the longest common subsequence between two default strings and compares it to a provided input string. The solution function g returns a specific string, and the puzzle checks if the longest common subsequence between the default strings matches the output of g.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.4108632802963257,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(factorial: int, num=5) -> bool:\n    def calculate_factorial(n):\n        if n == 0:\n            return 1\n        return n * calculate_factorial(n - 1)\n\n    return calculate_factorial(num) == factorial\n\ndef g(num=5):\n    return 120\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves recursion and mathematical operations.",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
            "\n\nfrom typing import List\n\ndef f(board: List[List[int]]) -> bool:\n    def is_valid(arr):\n        arr = [i for i in arr if i != '.']\n        return len(set(arr)) == len(arr)\n\n    for i in range(9):\n        if not is_valid(board[i]) or not is_valid([board[j][i] for j in range(9)]):\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if not is_valid([board[m][n] for n in range(3*j, 3*(j+1)) for m in range(3*i, 3*(i+1))]):\n                return False\n\n    return True\n\ndef g(board=[\n    [5, 3, '.', '.', 7, '.', '.', '.', '.'],\n    [6, '.', '.', 1, 9, 5, '.', '.', '.'],\n    ['.', 9, 8, '.', '.', '.', '.', 6, '.'],\n    [8, '.', '.', '.', 6, '.', '.', '.', 3],\n    [4, '.', '.', 8, '.', 3, '.', '.', 1],\n    [7, '.', '.', '.', 2, '.', '.', '.', 6],\n    ['.', 6, '.', '.', '.', '.', 2, 8, '.'],\n    ['.', '.', '.', 4, 1, 9, '.', '.', 5],\n    ['.', '.', '.', '.', 8, '.', '.', 7, 9]\n]):\n    return board\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int, num=5) -> bool:\n    def calculate_factorial(n):\n        if n == 0:\n            return 1\n        return n * calculate_factorial(n - 1)\n\n    return calculate_factorial(num) == factorial",
        "solution_func": "def g(num=5):\n    return 120",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function f that calculates the factorial of a given number and compares it to a provided factorial value. The solution function g returns a hardcoded factorial value for a specific number. The puzzle checks if the solution function g correctly calculates the factorial for the given number."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding factorial calculation and function comparison in Python. It provides a simple algorithmic challenge and tests the student's ability to implement the factorial calculation correctly.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6597519516944885,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(triplet: list) -> bool:\n    a, b, c = sorted(triplet)\n    return a**2 + b**2 == c**2\n\ndef g() -> list:\n    for a in range(1, 100):\n        for b in range(a, 100):\n            for c in range(b, 100):\n                if a**2 + b**2 == c**2:\n                    return [a, b, c]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Brute Force Search, and Conditional Logic.",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g()) == True",
            "\nfrom typing import List, Tuple\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            min_dist = min(min_dist, distance(points[i], points[j]))\n    return min_dist < 10\n\ndef g() -> List[Tuple[int, int]]:\n    return [(0, 0), (3, 4), (7, 1), (9, 9), (2, 8)]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(triplet: list) -> bool:\n    a, b, c = sorted(triplet)\n    return a**2 + b**2 == c**2",
        "solution_func": "def g() -> list:\n    for a in range(1, 100):\n        for b in range(a, 100):\n            for c in range(b, 100):\n                if a**2 + b**2 == c**2:\n                    return [a, b, c]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding a Pythagorean triplet within a specified range of numbers."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of Pythagorean triplets and nested loops in Python to find a solution.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.49674662947654724,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(target_sum: int, nums=[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]) -> bool:\n    def max_non_adjacent_sum(nums):\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n\n        return max(incl, excl)\n\n    return max_non_adjacent_sum(nums) == target_sum\n\ndef g(nums=[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]) -> int:\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n        if i == 1:\n            dp[i] = max(nums[0], nums[1])\n        else:\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[-1]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to find the maximum sum of non-adjacent elements in a list. It also includes conditional logic and list manipulation.",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\nimport random\n\ndef f(target_value: int, sequence_length=100) -> bool:\n    random.seed(1)\n    sequence = [random.randint(1, 100) for _ in range(sequence_length)]\n    sorted_sequence = sorted(sequence)\n    median_index = len(sorted_sequence) // 2\n    median_value = sorted_sequence[median_index]\n    return abs(median_value - target_value) < 10\n\ndef g():\n    return 50\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(target_sum: int, nums=[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]) -> bool:\n    def max_non_adjacent_sum(nums):\n        incl = 0\n        excl = 0\n\n        for num in nums:\n            new_excl = max(incl, excl)\n            incl = excl + num\n            excl = new_excl\n\n        return max(incl, excl)\n\n    return max_non_adjacent_sum(nums) == target_sum",
        "solution_func": "def g(nums=[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]) -> int:\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n        if i == 1:\n            dp[i] = max(nums[0], nums[1])\n        else:\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[-1]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of non-adjacent elements in a list of numbers and checking if this sum equals a target sum."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding dynamic programming to find the maximum sum of non-adjacent elements in a list. The solution function g implements dynamic programming to solve this problem and the puzzle function f checks if the solution is correct by comparing the sum to a target sum.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.43348637223243713,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nfrom typing import List\n\ndef f(sorted_list: List[int]) -> bool:\n    return sorted_list == sorted(sorted_list)\n\ndef g(numbers=[5, 2, 7, 1, 4, 3]):\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of integers using a specific algorithm and checking if the list is sorted correctly.",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(length: int) -> bool:\n    return length == 4\n\ndef g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(sorted_list: List[int]) -> bool:\n    return sorted_list == sorted(sorted_list)",
        "solution_func": "def g(numbers=[5, 2, 7, 1, 4, 3]):\n    n = len(numbers)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if numbers[j] > numbers[j+1]:\n                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that checks if a given list of integers is sorted in ascending order. The solution provided is a bubble sort algorithm that sorts the list in ascending order."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding the concept of sorting algorithms and implementing a basic sorting algorithm (bubble sort) in Python. It also tests the student's ability to compare lists for equality.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.3684515953063965,
        "judgeLM-7b-abs_finetuning": 6.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\nimport random\n\ndef f(probability: float, target=1/6) -> bool:\n    return abs(probability - target) < 0.01\n\ndef g():\n    outcomes = 0\n    total_trials = 10000\n    for _ in range(total_trials):\n        dice1 = random.randint(1, 6)\n        dice2 = random.randint(1, 6)\n        if dice1 + dice2 == 7:\n            outcomes += 1\n    return outcomes / total_trials\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Probability and Statistics",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(length: int) -> bool:\n    return length == 4\n\ndef g(nums=[3, 4, -1, 0, 6, 2, 3]):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\nassert f(g()) == True\n",
            "\nfrom typing import List, Tuple\n\ndef f(tuples: List[Tuple[int, int]], data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]) -> bool:\n    return tuples == sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef g(data=[(1, 5), (2, 3), (4, 6), (2, 1), (3, 7)]):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import random\n\ndef f(probability: float, target=1/6) -> bool:\n    return abs(probability - target) < 0.01",
        "solution_func": "def g():\n    outcomes = 0\n    total_trials = 10000\n    for _ in range(total_trials):\n        dice1 = random.randint(1, 6)\n        dice2 = random.randint(1, 6)\n        if dice1 + dice2 == 7:\n            outcomes += 1\n    return outcomes / total_trials",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating random dice rolls and calculating the probability of the sum being equal to 7. The solution function g() simulates multiple dice rolls and calculates the probability of the sum being 7, then checks if this probability is within a small margin of error from the expected value."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves concepts of probability, random number generation, and comparison of values. It provides a practical application of these concepts in a programming context.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.5904141068458557,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(smallest_num: int) -> bool:\n    return smallest_num == 2520\n\ndef g() -> int:\n    # Find the smallest positive number divisible by all numbers from 1 to 10\n    num = 1\n    while True:\n        if all(num % i == 0 for i in range(1, 11)):\n            return num\n        num += 1\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations, Conditional Logic, and Brute Force Search.",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(max_sum: int) -> bool:\n    return max_sum == 6\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    # Check if any pair of numbers in the list sums up to the target_sum\n    return any((x + y == target_sum) for i, x in enumerate(numbers) for y in numbers[i + 1:])\n\ndef g(numbers=[2, 4, 6, 8]) -> List[int]:\n    # Generate a list of integers based on the input numbers\n    return numbers\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(smallest_num: int) -> bool:\n    return smallest_num == 2520",
        "solution_func": "def g() -> int:\n    # Find the smallest positive number divisible by all numbers from 1 to 10\n    num = 1\n    while True:\n        if all(num % i == 0 for i in range(1, 11)):\n            return num\n        num += 1",
        "quality": [
            null
        ],
        "description": [
            "Find the smallest positive number divisible by all numbers from 1 to 10."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires finding the smallest positive number that is divisible by all numbers from 1 to 10.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6172181963920593,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(sorted_list: list, tuples=[(3, 4), (1, 2), (5, 6)]) -> bool:\n    expected = [(1, 2), (3, 4), (5, 6)]\n    return sorted_list == sorted(tuples, key=lambda x: sum(x))\n\ndef g(tuples=[(3, 4), (1, 2), (5, 6)]) -> list:\n    return sorted(tuples, key=lambda x: sum(x))\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Sorting and Ordering",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\ndef f(result: int) -> bool:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return result == factorial(5)\n\ndef g() -> int:\n    return 120\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(sorted_list: list, tuples=[(3, 4), (1, 2), (5, 6)]) -> bool:\n    expected = [(1, 2), (3, 4), (5, 6)]\n    return sorted_list == sorted(tuples, key=lambda x: sum(x))",
        "solution_func": "def g(tuples=[(3, 4), (1, 2), (5, 6)]) -> list:\n    return sorted(tuples, key=lambda x: sum(x))",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to define a function f that checks if a given list is sorted in a specific way, and a function g that sorts a list of tuples based on the sum of elements in each tuple. The assertion at the end checks if f(g()) returns True."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves sorting a list of tuples based on the sum of elements in each tuple and then checking if the sorted list matches a predefined expected order.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.6125344634056091,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nimport string\n\ndef f(palindrome: str) -> bool:\n    cleaned_palindrome = ''.join(char.lower() for char in palindrome if char.isalnum())\n    return cleaned_palindrome == cleaned_palindrome[::-1]\n\ndef g() -> str:\n    return \"A Santa at NASA\"\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Importing Modules (Itertools, etc.)",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(int_list: List[int]) -> bool:\n    return any(a**2 + b**2 == c**2 for a in int_list for b in int_list for c in int_list if a < b < c)\n\ndef g():\n    return [3, 4, 5]\n\nassert f(g()) == True\n",
            "\n\ndef f(max_product: int, nums=[-2, 3, -4, 5, -6]) -> bool:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result == max_product\n\ndef g(nums=[-2, 3, -4, 5, -6]) -> int:\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        temp_max = max_prod\n        max_prod = max(num, num * max_prod, num * min_prod)\n        min_prod = min(num, num * temp_max, num * min_prod)\n        result = max(result, max_prod)\n    return result\n\nassert f(g()) == True\n"
        ],
        "problem_func": "import string\n\ndef f(palindrome: str) -> bool:\n    cleaned_palindrome = ''.join(char.lower() for char in palindrome if char.isalnum())\n    return cleaned_palindrome == cleaned_palindrome[::-1]",
        "solution_func": "def g() -> str:\n    return \"A Santa at NASA\"",
        "quality": [
            null
        ],
        "description": [
            "Given a function f that checks if a string is a palindrome after removing non-alphanumeric characters, write a function g that returns a string to test if it is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves creating a function g that returns a specific string to test the palindrome function f. The string should be 'A Santa at NASA' to pass the palindrome check after removing non-alphanumeric characters and ignoring case.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.522683322429657,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(second_largest: int, nums=[3, 8, 1, 10, 5, 7]) -> bool:\n    max_num = float('-inf')\n    second_max = float('-inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max = max_num\n            max_num = num\n        elif max_num > num > second_max:\n            second_max = num\n\n    return second_largest == second_max\n\ndef g(nums=[3, 8, 1, 10, 5, 7]) -> int:\n    max_num = float('-inf')\n    second_max = float('-inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max = max_num\n            max_num = num\n        elif max_num > num > second_max:\n            second_max = num\n\n    return second_max\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting and finding the second largest element in a list, which falls under Sorting and Ordering topic.",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(kth_smallest: int, matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> bool:\n    def count_less_equal(matrix, mid):\n        count = 0\n        i = len(matrix) - 1\n        j = 0\n\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return count\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = count_less_equal(matrix, mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return kth_smallest == left\n\ndef g(matrix=[[1, 5, 9], [10, 11, 13], [12, 13, 15]], k=8) -> int:\n    return sorted([elem for row in matrix for elem in row])[k - 1]\n\nassert f(g()) == True\n",
            "\ndef f(subset: list, limit=100) -> bool:\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return set(subset).issubset(fibonacci)\n\ndef g(limit=100):\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] <= limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(second_largest: int, nums=[3, 8, 1, 10, 5, 7]) -> bool:\n    max_num = float('-inf')\n    second_max = float('-inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max = max_num\n            max_num = num\n        elif max_num > num > second_max:\n            second_max = num\n\n    return second_largest == second_max",
        "solution_func": "def g(nums=[3, 8, 1, 10, 5, 7]) -> int:\n    max_num = float('-inf')\n    second_max = float('-inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max = max_num\n            max_num = num\n        elif max_num > num > second_max:\n            second_max = num\n\n    return second_max",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining two functions in Python. The first function f(second_largest: int, nums=[3, 8, 1, 10, 5, 7]) checks if the second largest number in a list matches a given input. The second function g(nums=[3, 8, 1, 10, 5, 7]) finds and returns the second largest number in a list."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to find the second largest number in a list and comparing it with a given input. It tests the student's knowledge of list manipulation and conditional statements in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.41338682174682617,
        "judgeLM-7b-abs_finetuning": 4.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6  # Check if the maximum sum of a subarray is 6\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Brute Force Search, Dynamic Programming",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index]) or can_partition(nums, index + 1, current_sum)\n\n    return can_partition(nums, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\n\ndef f(result: int) -> bool:\n    return result == 5  # Check if the nth Fibonacci number is 5\n\ndef g(n=5) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(max_sum: int) -> bool:\n    return max_sum == 6  # Check if the maximum sum of a subarray is 6",
        "solution_func": "def g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves finding the maximum sum of a subarray in a given list of integers and checking if the maximum sum is equal to 6."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires students to implement a function that calculates the maximum sum of a subarray in a list of integers and then verify if the maximum sum is equal to 6.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 3,
        "yes_finetuning_deepseek-1.3b": 0.4169237017631531,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return set(permutations) == {'ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'}  # Check if all valid permutations are generated\n\ndef g(s: str = 'ABC') -> List[str]:\n    def backtrack(path, s, result):\n        if not s:\n            result.append(''.join(path))\n            return\n\n        for i in range(len(s)):\n            path.append(s[i])\n            backtrack(path, s[:i] + s[i+1:], result)\n            path.pop()\n\n    result = []\n    backtrack([], s, result)\n    return result\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations, Backtracking",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index]) or can_partition(nums, index + 1, current_sum)\n\n    return can_partition(nums, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\n\ndef f(result: int) -> bool:\n    return result == 5  # Check if the nth Fibonacci number is 5\n\ndef g(n=5) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\n\ndef f(permutations: List[str]) -> bool:\n    return set(permutations) == {'ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'}  # Check if all valid permutations are generated",
        "solution_func": "def g(s: str = 'ABC') -> List[str]:\n    def backtrack(path, s, result):\n        if not s:\n            result.append(''.join(path))\n            return\n\n        for i in range(len(s)):\n            path.append(s[i])\n            backtrack(path, s[:i] + s[i+1:], result)\n            path.pop()\n\n    result = []\n    backtrack([], s, result)\n    return result",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves generating all permutations of a given string 'ABC' and checking if the generated permutations match a specific set of valid permutations."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle requires understanding of backtracking algorithm to generate all permutations of a string and set comparison to check if the generated permutations match the valid set.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.33482086658477783,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 4.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 3.0
    },
    {
        "fitness": 1.0,
        "program_str": "\n\ndef f(factorial: int) -> bool:\n    return factorial == 120  # Check if the factorial of the number is 120\n\ndef g(n: int = 5) -> int:\n    if n == 0:\n        return 1\n    else:\n        return n * g(n - 1)\n\nassert f(g()) == True\n",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Factorial calculation and verification",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "puzzle_history": [
            "\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def can_partition(nums, index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n\n        return can_partition(nums, index + 1, current_sum + nums[index]) or can_partition(nums, index + 1, current_sum)\n\n    return can_partition(nums, 0, 0)\n\ndef g(nums = [1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
            "\n\ndef f(result: int) -> bool:\n    return result == 5  # Check if the nth Fibonacci number is 5\n\ndef g(n=5) -> int:\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\nassert f(g()) == True\n"
        ],
        "problem_func": "def f(factorial: int) -> bool:\n    return factorial == 120  # Check if the factorial of the number is 120",
        "solution_func": "def g(n: int = 5) -> int:\n    if n == 0:\n        return 1\n    else:\n        return n * g(n - 1)",
        "quality": [
            null
        ],
        "description": [
            "The puzzle checks if the factorial of a given number is equal to 120."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves calculating the factorial of a number and checking if it equals 120. The solution recursively calculates the factorial of a number.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.6333301067352295,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[str]) -> bool:\n    def generate_permutations(s):\n        return [''.join(p) for p in permutations(s)]\n\n    return set(generate_permutations(\"abc\")) == set(permutations_list)\n\ndef g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "Permutations and Combinations",
        "idx_generation": 90,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "puzzle_history": [
            "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
            "\nfrom typing import List\n\ndef f(parentheses: List[str]) -> bool:\n    def generate_parentheses(n):\n        def backtrack(s, open_count, close_count):\n            if len(s) == 2 * n:\n                parentheses.append(s)\n                return\n            if open_count < n:\n                backtrack(s + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(s + ')', open_count, close_count + 1)\n\n        parentheses = []\n        backtrack(\"\", 0, 0)\n        return parentheses\n\n    return set(generate_parentheses(2)) == set(parentheses)\n\ndef g():\n    return [\"(())\", \"()()\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import List\nfrom itertools import permutations\n\ndef f(permutations_list: List[str]) -> bool:\n    def generate_permutations(s):\n        return [''.join(p) for p in permutations(s)]\n\n    return set(generate_permutations(\"abc\")) == set(permutations_list)",
        "solution_func": "def g():\n    return [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
        "quality": [
            null
        ],
        "description": [
            "The puzzle requires the student to implement a function that generates all permutations of a given string and compares it with a list of permutations to check if they match."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to generate permutations of a string and compare them with a given list of permutations.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 2,
        "yes_finetuning_deepseek-1.3b": 0.39433443546295166,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 2.0
    },
    {
        "fitness": 1.0,
        "program_str": "\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: Optional[TreeNode]) -> bool:\n    def is_bst(node, min_val, max_val):\n        if not node:\n            return True\n\n        if not min_val < node.val < max_val:\n            return False\n\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root, float('-inf'), float('inf'))\n\ndef g():\n    # Construct a binary search tree\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root\n\nassert f(g()) == True\n",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "Recursion, Binary Operations, Algorithm Optimization",
        "idx_generation": 90,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ],
        "puzzle_history": [
            "\ndef f(board: list) -> bool:\n    def is_valid_move(board, row, col):\n        if row >= 0 and col >= 0 and row < len(board) and col < len(board) and board[row][col] == -1:\n            return True\n        return False\n\n    def solve_knights_tour_util(board, row, col, move_count):\n        if move_count == len(board) ** 2:\n            return True\n\n        for x, y in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            next_row, next_col = row + x, col + y\n            if is_valid_move(board, next_row, next_col):\n                board[next_row][next_col] = move_count\n                if solve_knights_tour_util(board, next_row, next_col, move_count + 1):\n                    return True\n                board[next_row][next_col] = -1\n\n        return False\n\n    start_row, start_col = 0, 0\n    board[start_row][start_col] = 0\n    return solve_knights_tour_util(board, start_row, start_col, 1)\n\ndef g(n=5):\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    return board\n\nassert f(g()) == True\n",
            "\nfrom typing import List\n\ndef f(parentheses: List[str]) -> bool:\n    def generate_parentheses(n):\n        def backtrack(s, open_count, close_count):\n            if len(s) == 2 * n:\n                parentheses.append(s)\n                return\n            if open_count < n:\n                backtrack(s + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(s + ')', open_count, close_count + 1)\n\n        parentheses = []\n        backtrack(\"\", 0, 0)\n        return parentheses\n\n    return set(generate_parentheses(2)) == set(parentheses)\n\ndef g():\n    return [\"(())\", \"()()\"]\n\nassert f(g()) == True\n"
        ],
        "problem_func": "from typing import Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: Optional[TreeNode]) -> bool:\n    def is_bst(node, min_val, max_val):\n        if not node:\n            return True\n\n        if not min_val < node.val < max_val:\n            return False\n\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root, float('-inf'), float('inf'))",
        "solution_func": "def g():\n    # Construct a binary search tree\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    return root",
        "quality": [
            null
        ],
        "description": [
            "The puzzle involves defining a function to check if a given binary tree is a binary search tree (BST) or not. The function f(root) takes a TreeNode object as input and recursively checks if the tree satisfies the properties of a BST. The solution function g() constructs a specific binary search tree and then calls f() to check if it is a valid BST."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves a common algorithmic problem of checking if a binary tree is a binary search tree. It requires understanding of binary search tree properties and recursive traversal. This puzzle can be used to teach concepts of binary search trees and recursive algorithms in Python.",
        "pass_5": 1.0,
        "n_sample": 5,
        "n_correct": 1,
        "yes_finetuning_deepseek-1.3b": 0.2868424952030182,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 3.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    },
    {
        "fitness": 1.0,
        "program_str": "\ndef f(solution, s='radar') -> bool:\n    return solution == solution[::-1]\n\ndef g(s='radar'):\n    return s + s[-2::-1]\n\nassert f(g()) == True\n",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "puzzle_history": [
            "\ndef f(solution, board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                        [0, 0, 0, 0, 8, 0, 0, 7, 9]]) -> bool:\n    def is_valid(board):\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num != 0:\n                    row_key = f\"r{i}:{num}\"\n                    col_key = f\"c{j}:{num}\"\n                    square_key = f\"s{i//3*3 + j//3}:{num}\"\n                    if row_key in seen or col_key in seen or square_key in seen:\n                        return False\n                    seen.update([row_key, col_key, square_key])\n        return True\n\n    return is_valid(solution)\n\ndef g(board=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    return board\n\nassert f(g()) == True\n",
            "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True"
        ],
        "problem_func": "def f(solution, s='radar') -> bool:\n    return solution == solution[::-1]",
        "solution_func": "def g(s='radar'):\n    return s + s[-2::-1]",
        "quality": [
            null
        ],
        "description": [
            "Given a function f that checks if a string is a palindrome and a function g that creates a palindrome from a given string, the puzzle requires finding a string that is a palindrome."
        ],
        "is_valid": [
            true
        ],
        "is_valid_explanation": "The puzzle involves understanding how to check for palindromes in a string and how to manipulate strings to create palindromes.",
        "pass_5": 0.0,
        "n_sample": 5,
        "n_correct": 0,
        "yes_finetuning_deepseek-1.3b": 0.6199755072593689,
        "judgeLM-7b-abs_finetuning": 8.0,
        "OpenCodeInterpreter-1-gpt35-abs_finetuning": 2.0,
        "OpenCodeInterpreter-2-gpt35-abs_finetuning": 1.0
    }
]